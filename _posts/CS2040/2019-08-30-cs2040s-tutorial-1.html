---
layout: post
title: 'CS2040S: Tutorial 1'
date: '2019-08-30T04:24:00.001-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-08-30T04:24:41.835-07:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-5260740766995316716
blogger_orig_url: https://nusmods.blogspot.com/2019/08/cs2040s-tutorial-1.html
---

<h3>Time complexity</h3><h4>Problem 1</h4><div>Q1.</div><div><br /></div><div>T(N)</div><div>S(1)</div><div>Reason: The second for loop is unreachable so it only runs one loop</div><div><br /></div><div>Q2.</div><div>T(1)</div><div>S(1)</div><div><br /></div><div>Reason: It does not rely on input x (Independent of input) so the run time is always the same no matter what.</div><div><br /></div><div>Q3.</div><div>T(1)</div><div>S(1)</div><div>The function look like it depends as n but we are considering large n.</div><div>For Large n, the run time is 1.</div><div><br /></div><div>Q4.</div><div>T(NlogN)</div><div>S(logN)</div><div>Each recursive call divide by 3 so is Logn times. Because of the for loop, its nlogn</div><div>For space, we look at how deep it goes.</div><div>The final level would have n/3^k</div><div><br /></div><div>Q5,</div><div>T(n)</div><div>S(1)</div><div><br /></div><div>Time is n because even thou the time is divided by half, we round off to n with a multiple of 1/2</div><div>Since n is use as a condition, we do not divide by 2 each time,</div><div>run time is n.</div><div>Space is one as we just push and pop at the same time</div><div><br /></div><div>Q6/</div><div>T(n)</div><div>S(n)</div><div><br /></div><div>Property of logarithms:</div><div>a^(log[a]B) = B</div><div><br /></div><div>We run recursion twice each time, we divide n by 2.</div><div>We realised as the level increase, we will reach</div><div>2^log[2]N * c</div><div>which is rounded to Nc</div><div><br /></div><div>The space is n because queue is n time only</div><div><br /></div><h4>Problem 2</h4><div>a)</div><div>F (n^4)</div><div>Reason: Its obvious that the largest n is to the power of 4</div><div><br /></div><div>b)</div><div>C(n)</div><div>Reason:</div><div>T(n/4) is a recursion that will evaluate to</div><div>3n + 3n/4 + 3n/4^2 + ...</div><div>which in turn, the largest value sum to 3n</div><div><br /></div><div>c)</div><div>D (nlogn)</div><div>Its paranoid quicksort,</div><div>Each time it recurse, it does 3n</div><div>It doesnt change the work done because both recursion added does the same amount of job</div><div>The number of 3n is logn</div><div><br /></div><div>d)</div><div>e (n^2)</div><div>Similar to the prev but instead of having equal work, each time the work gets smaller.</div><div>The largest value in the fn is still n^2</div><div><br /></div><div>e)</div><div>H (n^log[2]5)</div><div>Each time it divides by 5 due to the summation, we will reach the time complexity of</div><div>t(N/2)*5 + c</div><div>As we decrease the levels, it will see a pattern off</div><div>c + 5c + 5^2C + .... 5^log[2]nC , where log[2] n &gt; 2</div><div>Therefore the largest value is&nbsp; 5^log[2]n</div><div><br /></div><div>f)</div><div>G (2^n)</div><div>It splits into two each time,&nbsp;</div><div>even if the work is n-1 each time, the time constant was</div><div>c, 2c .... 2^n C</div><div>Largest is 2^2</div><div><br /></div><div><br /></div><div><br /></div>