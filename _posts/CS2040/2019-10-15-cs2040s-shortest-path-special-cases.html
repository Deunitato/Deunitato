---
layout: post
title: 'CS2040s: Shortest path (Special Cases)'
date: '2019-10-15T03:16:00.000-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-10-23T03:20:20.287-07:00'
thumbnail: https://1.bp.blogspot.com/-eoPL3UoOhVk/XbAnW4L_HrI/AAAAAAAACPg/PgUVjYRkkkYjscYz5Pa7MJW17nTRI0mJwCLcBGAsYHQ/s72-c/10.PNG
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-2753428584342834698
blogger_orig_url: https://nusmods.blogspot.com/2019/10/cs2040s-shortest-path-special-cases.html
---

<h2>Recap</h2><h3>Simple path</h3><div>There are no cycles, if a graph contains no negative weight cycles then the shortest path is a simple path where</div><div>it has at most v - 1 edges</div><div><br /></div><h3>Shortest Path</h3><div>Maintain estimate for each distance: Relax(s,B)</div><div>Update the current shortest path when a shorter path is found</div><div>(relax)</div><div><br /></div><div><b>The subpath of shortest path are always the shortest path.</b></div><h4>BellManFord</h4><div>We dont know the shortest path, so we use bellman ford to relax all the edges.</div><div>Relaxing all the edges will allow us to cover the correct edge to relax.</div><div>We only need to repeat the iteration for v-1 iterations&nbsp;</div><div><br /></div><div>Set all distance to infinity at first.&nbsp;</div><div>Later we update. This ensure that we can identify when the path is&nbsp; disconnected</div><div><br /></div><div>Order:</div><div>Any Order is fine.</div><div><br /></div><div>Storing the shortest path:</div><div>Update it when we update the shortest path</div><div>Use an array to store the shortest path.</div><div><br /></div><h2>Dijkstra's Algorithm</h2><div>Key idea: Relax the edges in the right order, relaxing the shortest weight.&nbsp;</div><div>Works on graph with non negative edges.</div><div>Only relax each edge once.</div><div>- Maintain distance estimate for every node</div><div>- Begin with empty shortest path tree</div><div><br /></div><div>1. Start at node s</div><div>2. Add the s into the queue</div><div>3. Remove s and relax</div><div>4. Update the paths and add it to&nbsp;</div><div>5. Look at the node in the queue with the minimum distance, relax that node</div><div>6. repeat 4</div><div><br /></div><div>Basically only update/relax the neighbour with what seems to be the smallest distance.</div><div>Stop when you reach the end</div><div><br /></div><div><br /></div><div><span class="fontstyle0">Dijkstra(G, s)<br />&nbsp; create vertex set Q<br />&nbsp; for each v in G<br />&nbsp; &nbsp; &nbsp; &nbsp;dist[v] = INFTY<br />&nbsp; &nbsp; &nbsp; &nbsp;prev[v] = UNDEF<br />&nbsp; &nbsp;dist[s] = 0<br />&nbsp; &nbsp;while Q is not empty<br />&nbsp; &nbsp; &nbsp; &nbsp; u = vertex in Q with min dist[u]<br />&nbsp; &nbsp; &nbsp; &nbsp; remove u from Q<br />&nbsp; &nbsp; &nbsp; &nbsp; for each neighbor v of u:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;relax(u,v)<br />&nbsp; &nbsp; return dist, prev</span>&nbsp;<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-eoPL3UoOhVk/XbAnW4L_HrI/AAAAAAAACPg/PgUVjYRkkkYjscYz5Pa7MJW17nTRI0mJwCLcBGAsYHQ/s1600/10.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="415" data-original-width="675" height="245" src="https://1.bp.blogspot.com/-eoPL3UoOhVk/XbAnW4L_HrI/AAAAAAAACPg/PgUVjYRkkkYjscYz5Pa7MJW17nTRI0mJwCLcBGAsYHQ/s400/10.PNG" width="400" /></a></div><br /></div><div><b><span style="color: red;"><br /></span></b></div><div><b><span style="color: red;">Use a PQ as the data structure to store the path distance</span></b></div><div><b><span style="color: red;">-&gt; AVL trees , (heap is fine)</span></b></div><div><b><span style="color: red;"><br /></span></b></div><div><b><span style="color: red;">Time complexity: O((V+E) LogV)</span></b><br />-&gt; Insert/delMin O(V), each node is added to pq once<br /><span style="color: red;">-&gt; Relax/decreaseKey O(E), each edge relax once</span></div><div>-&gt; PQ is LogV</div><div><br /></div><h3>Proof: Induction</h3><div>Every finish vertex has a correct estimate.</div><div><br /></div><div>Base case:</div><div>The source itself is the shortest path</div><div><br /></div><div>Inductive step:</div><div><br /></div><div>Proof by contradiction.&nbsp;</div><div>Assume the shortest path is not the shortest path.</div><div>The real path have distance r</div><div>There will be a contradiction because pq ensure that only the smallest will be taken out.</div><div><br /></div><div><br /></div><h3>Negative weights</h3><div>Destroy the proof.</div><div><br /></div><div>Dystra only look at the smallest distance but there might be a case where adding a negative will make the other path shorter but we fail to look at that because we only pick the smallest edge in that instance</div><div><br /></div><div>Re-Weight will not work, we do not preserve the shortest path.</div><div><br /></div><div><br /></div><h3>Comparison to BFS and DFS</h3><div>Maintain a set of explored vertices.</div><div>Add vertices to explored set (hashmap) by following edges that go from a vertex in the explored set to a vertex outside explored set</div><div><br /></div>BFS: Vertex that was discovered least recently<br /><div>DFS: Vertex that was discovered most recently</div><div>DIjkstra: Vertex that is closest to the&nbsp; source</div><div><br /></div><div><br /></div><h2>Directed Acyclic Graph</h2><div>1. Topological sort</div><div>2. Relax in order</div><div>-&gt; Relax the neighbours first<br /><br />This is because DAG is in order and has no cycles<br /><br /><span style="color: red;"><b>Time Complexity-&gt; O(V+E)</b></span></div><div><br /></div><div><br /></div>