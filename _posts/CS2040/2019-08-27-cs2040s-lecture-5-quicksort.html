---
layout: post
title: 'CS2040S: Lecture 5 - QuickSort'
date: '2019-08-27T22:31:00.003-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-09-05T02:15:22.931-07:00'
thumbnail: https://1.bp.blogspot.com/-Xlu8jln2JNg/XW6CyZLt71I/AAAAAAAACEA/iOuTECKk3U0WW4bUuHAQYKfe6xPIvefqQCLcBGAs/s72-c/1.png
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-4910206313483479526
blogger_orig_url: https://nusmods.blogspot.com/2019/08/cs2040s-lecture-5-quicksort.html
---

<h3>Quick sort</h3><div>Does a clever split, a recursive solve and trivial combine</div><div><span class="fontstyle0">function </span><span class="fontstyle0" style="color: #3e8853;">Quicksort</span><span class="fontstyle0">(</span><span class="fontstyle0" style="color: #0e5772;">A, low, high</span><span class="fontstyle0">)<br />if </span><span class="fontstyle0" style="color: #335b74;">low </span><span class="fontstyle0">&lt; </span><span class="fontstyle0" style="color: #335b74;">high</span><span class="fontstyle0">&nbsp;</span><br /><span class="fontstyle0">p = Partition(A, </span><span class="fontstyle0" style="color: #0e5772;">low</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #0e5772;">high</span><span class="fontstyle0">) //split<br />Quicksort (</span><span class="fontstyle0" style="color: #335b74;">A</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #335b74;">low</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #335b74;">p-1</span><span class="fontstyle0">) //recursive<br />Quicksort (</span><span class="fontstyle0" style="color: #335b74;">A</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #335b74;">p+1</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #335b74;">high</span><span class="fontstyle0">)</span>  </div><div><br /></div><div><h3>Lumoto's partition algo:</h3></div><div><span class="fontstyle0">function </span><span class="fontstyle0" style="color: #3e8853;">Partition</span><span class="fontstyle0">(</span><span class="fontstyle0" style="color: #0e5772;">A, low, high</span><span class="fontstyle0">)</span><span class="fontstyle0" style="color: #0e5772;">&nbsp; &nbsp;</span><br /><span class="fontstyle0" style="color: #0e5772;">&nbsp;&nbsp; &nbsp;v </span><span class="fontstyle0">= </span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">low</span><span class="fontstyle0">]</span><span class="fontstyle0" style="color: #0e5772;">&nbsp;</span><span class="fontstyle0" style="color: #0e5772;">&nbsp;</span><br /><span class="fontstyle0" style="color: #0e5772;">&nbsp; &nbsp; m </span><span class="fontstyle0">= </span><span class="fontstyle0" style="color: #0e5772;">low</span><br /><span class="fontstyle0" style="color: #0e5772;">&nbsp; &nbsp; &nbsp;i </span><span class="fontstyle0">= </span><span class="fontstyle0" style="color: #0e5772;">low</span><br /><span class="fontstyle0" style="color: #0e5772;">//Initialisation</span><br /><span class="fontstyle0"><span style="color: #0e5772;">&nbsp; &nbsp; &nbsp; &nbsp;</span>for </span><span class="fontstyle0" style="color: #0e5772;">i </span><span class="fontstyle0">= (</span><span class="fontstyle0" style="color: #0e5772;">low </span><span class="fontstyle0">+ 1) to </span><span class="fontstyle0" style="color: #0e5772;">high</span><span class="fontstyle0"><span style="color: #0e5772;">&nbsp;</span></span><br /><span class="fontstyle0"><span style="color: #0e5772;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>if </span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">i</span><span class="fontstyle0">] &lt; v</span><span class="fontstyle0" style="color: #0e5772;">&nbsp;</span><br /><span class="fontstyle0" style="color: #0e5772;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m</span><span class="fontstyle0">++<br /><span style="color: #0e5772;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>swap(</span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">i</span><span class="fontstyle0">], </span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">m</span><span class="fontstyle0">])<br />&nbsp; &nbsp; &nbsp; &nbsp;swap(</span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">m</span><span class="fontstyle0">], </span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">low</span><span class="fontstyle0">])<br /><span style="color: #0e5772;">&nbsp; &nbsp; &nbsp; &nbsp;</span>return </span><span class="fontstyle0" style="color: #0e5772;">m</span><br /><br /><div><b>Precondition</b></div><div>1. A is an array</div><div>2. 0&lt; = low &lt; = high &lt; = A.length</div><div>3. A has no duplicate</div><div><br /></div><div><b>Post condition</b><br />1. A[m] = v //mid</div><div>2. low&lt;= k &lt;= m-1 , A[k] &lt; v //lower box</div><div>3. m+1 &lt; = k &lt; = high , A[k] &gt; v&nbsp; //upper box<br /><br /><b>Loop Invariances</b><br />1. A[low] = v<br />2. if low+1 &lt;= k &lt;= m, A[k] &lt; v<br />3. if m+1 &lt;= k &lt;= i, A[k] &gt; k</div><div><br /></div></div><div><br /></div><div><div>"Quick sort assumes that left is already sorted"</div><div>1. Choose a pivot (first index)</div><div>2. Iterate from pivot up</div><div>3. If element is smaller than pivot, m++, swap element with element at counter m</div><div>4. i++, repeat 3<br />5. Stop only when i = high</div><div><br />The idea is put all the smaller than pivot at the left, put all the bigger in the right.<br />Finally, put the median in the correct position<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-Xlu8jln2JNg/XW6CyZLt71I/AAAAAAAACEA/iOuTECKk3U0WW4bUuHAQYKfe6xPIvefqQCLcBGAs/s1600/1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="499" data-original-width="538" height="370" src="https://1.bp.blogspot.com/-Xlu8jln2JNg/XW6CyZLt71I/AAAAAAAACEA/iOuTECKk3U0WW4bUuHAQYKfe6xPIvefqQCLcBGAs/s400/1.png" width="400" /></a></div><br /></div></div><div><br /></div><h4>Correctness and Efficiency:</h4><div>There are algorithms that are fast but sometimes incorrect.</div><div><b><i><span style="color: red;">Quicksort is n^2 depending on the situation.</span></i></b><br />This is due to the fact that Lumoto's algo will still partition even if the data structure is already sorted when the wrong pivot is chosen.<br /><br /></div><div><br /></div><div><i><b><span style="color: red;">A deterministic quicksort is</span></b></i></div><div><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0" style="color: red;"><i><b>T(n-1) + T(1) +cn</b></i></span></span></span><br /><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0">T(n-1) -&gt; Cost of quicksort on n-1 elements</span></span></span><br /><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0">T(1) -&gt; Cost of Quicksort on 1 element</span></span></span><br /><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0">cn -&gt; Cost of partition on n elements</span></span></span><br /><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><br /></span></span></span></div><div><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0">//Partition takes n time</span></span></span></div><div><span class="fontstyle0">p = Partition(A, </span><span class="fontstyle0" style="color: #0e5772;">low</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #0e5772;">high</span><span class="fontstyle0">) //cn time<br />Quicksort (</span><span class="fontstyle0" style="color: #335b74;">A</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #335b74;">low</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #335b74;">p-1</span><span class="fontstyle0">)&nbsp; // n-1<br />Quicksort (</span><span class="fontstyle0" style="color: #335b74;">A</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #335b74;">p+1</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #335b74;">high</span><span class="fontstyle0">)</span>&nbsp; //1<br /><br /><br /></div><div><br /></div><div>The problem is that we always pick A[low] for a pivot so instead of doing that,</div><div>we can pick the median value.</div><div><br />Better quicksort,</div><div><b><i><span style="color: red;">Our time complexity will&nbsp; be 2T(n/2) + cn</span></i></b></div><div>T(n/2) -&gt; Cost of Quicksort on n/2 high elements<br />t(n/2) - &gt; Cost of quicksort on n/2 low elements<br />cn -&gt; cost of partition of n elements<br /><br /><b><i><span style="color: red;">But for quick sort the worst is nlogn</span></i></b></div><div><br /><br /><br /><h3>Hoare's Partition algo</h3></div><div>Unlike lumoto, Hoare's partition method is harder but is more efficient as it runs 3 times faster and does fewer sorts on average compared to Lumoto. Like Lumoto, it will be n^2 if the array is already sorted.</div><div><br /></div><div>(Check if low&lt; high)&nbsp;</div><div>1. Iterate from the left up</div><div>2. If larger or equal to pivot then break out of the loop with i at the index</div><div>3. Iterate from the right down</div><div>4. If smaller than pivot, break out of the loop with j at the index</div><div>5. If the two pointers (i&gt;= j), return j</div><div>else</div><div>swap elements at i and j<br />6. After left side and right side is partitioned, swap the pivot with A[j] ,which is smaller than pivot</div><div>7. Quick sort the lower half, and Quick sort the upper half<br /><br /><br /><span class="fontstyle0">function </span><span class="fontstyle0" style="color: #3e8853;">Partition</span><span class="fontstyle0">(</span><span class="fontstyle0" style="color: #0e5772;">A, low, high</span><span class="fontstyle0">)</span><br /><span class="fontstyle0" style="color: #0e5772;">&nbsp; &nbsp; &nbsp;v </span><span class="fontstyle0">= </span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">low</span><span class="fontstyle0">]</span><br /><span class="fontstyle0" style="color: #0e5772;">&nbsp; &nbsp; &nbsp;i = low+1;<br />&nbsp; &nbsp; &nbsp;j = high;</span><br /><span class="fontstyle0"><span style="color: #0e5772;">&nbsp; &nbsp; &nbsp;</span>while </span><span class="fontstyle0" style="color: #0e5772;">i </span><span class="fontstyle0">&lt; </span><span class="fontstyle0" style="color: #0e5772;">j</span><br /><span class="fontstyle0"><span style="color: #0e5772;">&nbsp; &nbsp; &nbsp;</span></span><span style="color: #0e5772;">&nbsp; &nbsp; &nbsp;</span><span class="fontstyle0">while (</span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">i</span><span class="fontstyle0">] &lt; v) and (i &lt;= high) i++</span><br /><span class="fontstyle0"><span style="color: #0e5772;">&nbsp; &nbsp; &nbsp;</span></span><span style="color: #0e5772;">&nbsp; &nbsp; &nbsp;</span><span class="fontstyle0">while (</span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">j</span><span class="fontstyle0">] &gt; v) and (j &gt;= low) j--</span><br /><span class="fontstyle0"><span style="color: #0e5772;">&nbsp; &nbsp; &nbsp;</span></span><span style="color: #0e5772;">&nbsp; &nbsp; &nbsp;</span>if (i&lt;j) swap(A[i], A[j])<br /><span class="fontstyle0"><span style="color: #0e5772;">&nbsp; &nbsp; &nbsp;</span>swap(A[j], A[low])<br /><span style="color: #0e5772;">&nbsp; &nbsp; &nbsp;</span>return j</span><br /><br /></div><h3>Pivot choices</h3><h4>Selecting Median</h4><div><span class="fontstyle0">function&nbsp;</span><span class="fontstyle0" style="color: #3e8853;">Quicksort</span><span class="fontstyle0">(</span><span class="fontstyle0" style="color: #0e5772;">A, low, high</span><span class="fontstyle0">)<br />if&nbsp;</span><span class="fontstyle0" style="color: #335b74;">low&nbsp;</span><span class="fontstyle0">&lt;&nbsp;</span><span class="fontstyle0" style="color: #335b74;">high</span><span class="fontstyle0">&nbsp;</span><br /><span class="fontstyle0">mid = (low+ high) /2</span><br /><span class="fontstyle0">p = Partition(A, mid,&nbsp;</span><span class="fontstyle0" style="color: #0e5772;">low</span><span class="fontstyle0">,&nbsp;</span><span class="fontstyle0" style="color: #0e5772;">high</span><span class="fontstyle0">) //split<br />Quicksort (</span><span class="fontstyle0" style="color: #335b74;">A</span><span class="fontstyle0">,&nbsp;</span><span class="fontstyle0" style="color: #335b74;">low</span><span class="fontstyle0">,&nbsp;</span><span class="fontstyle0" style="color: #335b74;">p-1</span><span class="fontstyle0">) //recursive<br />Quicksort (</span><span class="fontstyle0" style="color: #335b74;">A</span><span class="fontstyle0">,&nbsp;</span><span class="fontstyle0" style="color: #335b74;">p+1</span><span class="fontstyle0">,&nbsp;</span><span class="fontstyle0" style="color: #335b74;">high</span><span class="fontstyle0">)</span><br /><span class="fontstyle0"><br /></span><span class="fontstyle0">This will allow the split to be 50:50</span><br /><span class="fontstyle0"><br /></span><span class="fontstyle0"><br /></span></div><div><h4>But,we don't need a 50:50 split for it to be nlogn</h4></div><div>Because its always Cnlogn<br /><br />Imagine a 90:10 Partition,<br />T(n) = T(n/10) + T(9n/10) + cn<br /><br /></div><div>Base case is 1 element,<br />If each time we split, we will reach 1 = n(9/10)^h where h is the total height<br />We use 9/10 because it have more elements, so it will spread the deepest</div><div>then h = clog(2) n<br /><br />At every level, we take n effort to partition each level,<br />the time complexity is then nlogn</div><div><br /></div><h4>Randomized quicksort</h4><div><span class="fontstyle0">function </span><span class="fontstyle0" style="color: #3e8853;">RandomizedPartition</span><span class="fontstyle0">(</span><span class="fontstyle0" style="color: #0e5772;">A, low, high</span><span class="fontstyle0">)</span><br /><span class="fontstyle0" style="color: #0e5772;">&nbsp; &nbsp; &nbsp; &nbsp;r </span><span class="fontstyle0">= Random(</span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #0e5772;">low</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #0e5772;">high</span><span class="fontstyle0">) //median is randomised<br />&nbsp; &nbsp; &nbsp; &nbsp;swap(</span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">r</span><span class="fontstyle0">], </span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">low</span><span class="fontstyle0">])<br />&nbsp; &nbsp; &nbsp; &nbsp;return Partition(</span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #0e5772;">low</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #0e5772;">high</span><span class="fontstyle0">)</span>&nbsp;&nbsp;</div><div><br /></div><div>Randomly sort an elements<br />Just swap a random element with the first element.<br /><br /></div><div>Intuition: Random element should result in balance split on average</div><div><br /></div><h4>Paranoid Quicksort</h4><div>Make sure that it will never satisfy the condition of 1:9 partition<br />Will continue to randomise until the low and high is not a pivot<br /><br /></div><div><br /></div><div><br /></div><h4>Probability of picking a good pivot</h4><div>8/10 (Pick the numbers 2-9)</div><div>Bad pivots would be 1 and 10</div><div><br /></div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-BTP3INeMajs/XWYLyytwGTI/AAAAAAAACDc/RAi7RL04kZo00SDrWcHvDsOGy2euRJIYwCLcBGAs/s1600/3.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="313" data-original-width="783" height="158" src="https://1.bp.blogspot.com/-BTP3INeMajs/XWYLyytwGTI/AAAAAAAACDc/RAi7RL04kZo00SDrWcHvDsOGy2euRJIYwCLcBGAs/s400/3.PNG" width="400" /></a></div><h4 style="clear: both; text-align: left;">Problem: Duplicates</h4><div>Quicksort will take longer when there is duplicates.</div><div><br /></div><h3>3 way partition + quicksort:</h3><div>1. Cuts into 3&nbsp;</div><div>&nbsp; &nbsp;a. Less than v</div><div>&nbsp; &nbsp;b. Equal to V</div><div>&nbsp; &nbsp;c. Greater than V</div><div>2. If find a duplicate, increase partition</div><div>3. Else do the same as normal quick sort</div><div><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-ar6A7a9puW4/XW6LRdJOUCI/AAAAAAAACEM/wG9GV-RAaA479WLU7j9rNCHp6p1kiVWHwCLcBGAs/s1600/2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="507" data-original-width="767" height="262" src="https://1.bp.blogspot.com/-ar6A7a9puW4/XW6LRdJOUCI/AAAAAAAACEM/wG9GV-RAaA479WLU7j9rNCHp6p1kiVWHwCLcBGAs/s400/2.png" width="400" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-M7taYMYC4Fw/XW6LduIx3uI/AAAAAAAACEQ/Ey3sIy_uC_0IapRYn9HETZKPjjvGXqHmACLcBGAs/s1600/3.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="345" data-original-width="556" height="247" src="https://1.bp.blogspot.com/-M7taYMYC4Fw/XW6LduIx3uI/AAAAAAAACEQ/Ey3sIy_uC_0IapRYn9HETZKPjjvGXqHmACLcBGAs/s400/3.png" width="400" /></a></div><br /></div><h4>Quick sort is unstable</h4><div>Stable: Everything remains unsorted if the key is the same.</div><div>Unstable: The keys may be swapped even if they are the same</div><div><br /></div><div>Quicksort is unstable because it just swaps the value without considering the original position.<br /><br /><h4>Stable</h4>- Mergesort<br />- Insertion sort<br />- Bubble sort<br /><br /><h4>Unstable</h4>- Selection sort (Arrays)<br />- Quick sort<br /><br /><a href="https://nusmods.blogspot.com/2019/08/cs2040s-binary-search-and-merge-sort.html">&lt;Prev</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="https://nusmods.blogspot.com/2019/09/cs2040s-binary-heap-and-priority-queue.html">Next&gt;</a></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div>