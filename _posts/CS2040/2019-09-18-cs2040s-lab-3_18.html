---
layout: post
title: 'CS2040s: Lab 3'
date: '2019-09-18T22:14:00.000-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-09-18T22:24:24.026-07:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-4886575098964234618
blogger_orig_url: https://nusmods.blogspot.com/2019/09/cs2040s-lab-3_18.html
---

<h2>B - Trees</h2><div>Form of balanced tree</div><div><br /></div><h3>Anatomy of CPU</h3><div><br /></div><div>ALU does arithmetic</div><div>Cache lines</div><div>Disk&nbsp;</div><div>Ram</div><div><br /></div><div>The alu puts in cache lines,</div><div>it will check the ram then if dont have it will check the disk and push back</div><div>After the cache check the value it will stoer it</div><div><br /></div><div>If alu wants the same value, it will go to cache and just take it back. It does nit need to go to ther am and disk -&gt; Cache hit</div><div><br /></div><div>But what if we go to the cache line and it have to go to ram/ disk -&gt; Cache miss</div><div><br /></div><div>We want to maximise the amount of cache hits.&nbsp;</div><div><br /></div><div>1. Assume that accessing the cache takes 1 second, accessing ram is 28 mins</div><div>2. SSD will take 5 days</div><div>3. HD will take 1-5 years</div><div><br /></div><div>We try to utilise the cache.</div><div><br /></div><h3>Structure of B tree</h3><div>- Can hold more than 3 children</div><div>- Sorted</div><div>- One node can hold more than one value</div><div>- Leaf nodes at same depth</div><div>- All non root nodes between b-1 to 2b-1 keys.</div><div>- Nodes can only be 2b-1 values</div><div>- The root has at most 2b-1 (b=2 means the root has at most 3 keys)</div><div>- If one node has c values, it must have c-1 subtrees</div><div><br /></div><div>Properties:</div><div>1. All leaf nodes are of same depth</div><div>2. All non root nodes have b-1 to 2b-1 keys</div><div>3. the root has at most 2b-1 keys</div><div>4. An internal node with k keys must have k+1 subtrees</div><div><br /></div><div>Analysis</div><div>Prove the height is logn</div><div>Each node beside root needs to have n-1 keys</div><div>first level = 1 key</div><div>2nd level = 2* (b-1)</div><div>We will see a heomteric prhression</div><div>2b^h -1 keys</div><div><br /></div><div><br /></div><div>which means the k has n-tree</div><div><br /></div><div>Insertion</div><div>1. If current node has less than 2b keys, we do nothing</div><div>2. Else check our siblings, if either of them has less than 2b-1 keys, we rotate a value to them</div><div>3. Else do a split, meaning break current node into 3 parts, one node contain middle key (taken from median) and the other two contain the b keys each. Then push the middle key up into the parent</div><div>4. Recurse this upwards if we split</div><div><br /></div><div>It will always grows up so the depth will always be the same<br /><br />For top down insertion, when we do traversal, everytime we encounter a full node, we will split the node. We will only insert only after everything is done.</div><div>However, top down creates too much levels but for down up only splits when we need to</div><div>Deletion</div><div>1. If current node is still has b-1 keys, do nothing</div><div>2. Else we look at siblings, if either of them has greater than b-1 keys, we can take one from either</div><div>3. Else we pick one of the siblings and merge them using a key from the parent, then recurse on the parent node to check its size.</div><div>IF Unbalance</div><div>4. If parent is bare minimum, bring child up (successor), else if parent not bare minimum. bring parent down</div><div><br /></div>