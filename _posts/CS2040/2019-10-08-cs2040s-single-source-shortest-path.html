---
layout: post
title: 'CS2040s: Single-Source Shortest Path for graphs'
date: '2019-10-08T22:21:00.001-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-10-25T05:40:19.719-07:00'
thumbnail: https://1.bp.blogspot.com/-DxRHLxo8AbA/XbAYmALkJOI/AAAAAAAACOo/Q-l4euzKtScszP32B0TXoDIHWBG1krDiACLcBGAsYHQ/s72-c/5.PNG
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-7539721339978891282
blogger_orig_url: https://nusmods.blogspot.com/2019/10/cs2040s-single-source-shortest-path.html
---

<h2>Single Source Shortest Path</h2><h3>Weighted Graph</h3><div>w(e) : E -&gt; R</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-DxRHLxo8AbA/XbAYmALkJOI/AAAAAAAACOo/Q-l4euzKtScszP32B0TXoDIHWBG1krDiACLcBGAsYHQ/s1600/5.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="378" data-original-width="739" height="203" src="https://1.bp.blogspot.com/-DxRHLxo8AbA/XbAYmALkJOI/AAAAAAAACOo/Q-l4euzKtScszP32B0TXoDIHWBG1krDiACLcBGAsYHQ/s400/5.PNG" width="400" /></a></div><br /></div><div>Each edge have a weight.</div><h4>Shortest Path</h4><div><u><b>Shortest path is not the minimum distance</b></u></div><div>- What is the path from a certain node to another?</div><div>- Shortest path from a node to every other node?</div><div>- Shortest path between every pair of node</div><div><br /></div><div>We cant use BFS because it finds the minimum number of hops not minimum distance.<br />Minimum distance is not the shortest path due to the weights the edges hold.</div><div>Minimum distance -&gt; sum of edges weight</div><div>Minimum hops -&gt; Least number of nodes passing to get to destination</div><div><br /><b>#1&nbsp;</b><b>If all weights are positive, can the shortest path contain a cycle? =&gt; no</b></div><div><b><br /></b></div><div><b>PROOF</b><br /><b><u>by contradiction</u></b></div><div>Suppose the shortest path p is not a simple path<br /><i>[A simple path have no repeated vertex meaning no cycle]</i></div><div>Then p must contain at least one cycle c</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-tfmiSEg_tIA/XbAZ2leBm8I/AAAAAAAACO0/MLa0zxbmi_kzCIcKylXVoYu_PsNhQL2QACLcBGAsYHQ/s1600/6.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="71" data-original-width="202" height="112" src="https://1.bp.blogspot.com/-tfmiSEg_tIA/XbAZ2leBm8I/AAAAAAAACO0/MLa0zxbmi_kzCIcKylXVoYu_PsNhQL2QACLcBGAsYHQ/s320/6.PNG" width="320" /></a></div><br /></div><div>Suppose there is a cycle c in p with positive weight</div><div>If we remove c then we have a shorter path then the previous shortest path<br />There was not suppose to have another shortest path.</div><div><b>CONTRADICTION!&nbsp;</b></div><div><b><u><span style="color: red;">Conclusion: P is a simple path</span></u></b></div><div><br /></div><div>Even in non positive weight,</div><div>0 weight cycle can be remove even if it occurs<br />ie 0 weight cycles does not matter<br /><br /><br /></div><div>Negative weight cycles are bad<br />=&gt; Infinite loop<br /><br /><b>#2 If the graph have no negative weight cycles, shortest path from source is a simple path</b></div><div><br /></div><div><span style="color: red;"><u><b>The shortest path can at most have |v| - 1 edges</b></u></span></div><div><br /></div><div><b>#3 Triangle Inequality</b><br />In a triangle the base is either shorter or equal to the sum of the other two edges</div><div><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-kG_fSjGJ3Yc/XbAcB67z2DI/AAAAAAAACPA/qu2xj1ROYxI0xLmQctPzHgyanrE2QZ7kQCLcBGAsYHQ/s1600/7.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="170" data-original-width="365" height="149" src="https://1.bp.blogspot.com/-kG_fSjGJ3Yc/XbAcB67z2DI/AAAAAAAACPA/qu2xj1ROYxI0xLmQctPzHgyanrE2QZ7kQCLcBGAsYHQ/s320/7.PNG" width="320" /></a></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-u_xgaNU4bnI/XbAcIp6SUKI/AAAAAAAACPE/SJC1-EnH0gw-rv3yQ9TXDPdaK-bUpgBPgCLcBGAsYHQ/s1600/8.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="290" data-original-width="329" height="282" src="https://1.bp.blogspot.com/-u_xgaNU4bnI/XbAcIp6SUKI/AAAAAAAACPE/SJC1-EnH0gw-rv3yQ9TXDPdaK-bUpgBPgCLcBGAsYHQ/s320/8.PNG" width="320" /></a></div><br /></div><div>Assume the shortest path is k</div><div>k &lt; = a + w</div><div>where a and w is not the base of the triangle</div><div><br /></div><div>By proving by contradiction, assume that</div><div>k&gt; a + w</div><div><br /></div><div>Then k is not the shortest path already since we can take a+w as the path&nbsp;</div><div><h3>Relaxing (Finding shortest path)</h3></div><div>Reduce estimate distance between two points s and u</div><div>Invariant: Estimate d[s,u] &gt; = p[s,u]</div><div>p is shortest path and d is distance</div><div><br /><span class="fontstyle0">relax(int u, int v){<br />&nbsp; if (dist[v] &gt; dist[u] + weight(u,v))<br />&nbsp; &nbsp; dist[v] = dist[u] + weight(u,v);<br />}</span><br /><br />Key idea:<br />Test if to<br />get from s -&gt; v, v -&gt; x<br />is shorter than the path s-&gt;x</div><div><h4>Using relax to find shortest path</h4></div><div>1. Set all node distance except the original node as infinite</div><div>The starting node is 0</div><div>2. Check the setted distance of the first neighbour</div><div>if setted distance is larger than (edge + prev node distance), update the edge with the sum<br />else move on to the next neighbour for this current node<br />3. Repeat till reach the end<br />4. Backtrack and repeat from step 2 until all path have been explored</div><div><br />//step 2 is my relax step<br /><br /><br /><h3>#4 Upper Bound property</h3></div><div>The distance will always be &gt; = shortest path</div><div>Once minimum distance = shortest path, the minimum distance never changes<br /><br />Proof by Induction</div><h3>#5 Convergence Property</h3><div><span style="background-color: #36393f; color: #dcddde; font-family: &quot;whitney&quot; , &quot;helvetica neue&quot; , &quot;helvetica&quot; , &quot;arial&quot; , sans-serif; font-size: 16px; white-space: pre-wrap;">If u is a predecessor of v in some shortest path to v, and d(u) = δ(u), then after relaxing (u,v), d(v) = δ(v). By the monotonocity and upper-bound properties, d(v) = δ(v) forever after.</span></div><div><span style="background-color: #36393f; color: #dcddde; font-family: &quot;whitney&quot; , &quot;helvetica neue&quot; , &quot;helvetica&quot; , &quot;arial&quot; , sans-serif; font-size: 16px; white-space: pre-wrap;"><br /></span></div><div>If there is some path that is the shortest path from s to v,<br />no matter how many relaxation is done between s and v,<br />by upper bound property, the <u>distance and shortest path will always remain the same</u>.</div><div><br /></div><div>If we have a certain path from s to v and it is the shortest path.</div><div><br /></div><div><u>This property holds regardless if other relaxation occurs.</u></div><div>E.g</div><div>The shortest path is e1e2e3e4</div><div>even if we do e1e1e1e1e1e2e3e4, the shortest distance still holds</div><div>(Even if intermix)<br /><br /><h3>#6 Path relaxation Property</h3></div><div>If p is a shortest from from v to u then once we relax the edges of p (Look at all possible edges from v to u), then d[u] = p[u] for all nodes<br />ie. We can get every shortest subpath</div><div><br /></div><div><b>Proof:</b><br />BY INDUCTION<br /><br />1. Base case: Source node (0)</div><div>Assume that some path from 0 to k-1 is correct</div><div>d[v(k-1)] = p[v(k-1)]&nbsp;</div><div>2. Inductive step</div><div>when we relax (find the shortest path already),&nbsp;</div><div>d[v(k)] = p[v(k-1)]&nbsp; +w(e)</div><div>= p[v(k)]<br />where w(e) is the weight of the edge between k-1 and k</div><div><br /><span style="color: red;"><b>Relax algo will not always work</b></span><br />=&gt; For all edge in graph we relax<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-EKNz3PJK4Us/XbAeIQQ_bWI/AAAAAAAACPU/qT8T6s84uBkrz8Jm1R8pabktodD97kUBACLcBGAsYHQ/s1600/9.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="472" data-original-width="659" height="228" src="https://1.bp.blogspot.com/-EKNz3PJK4Us/XbAeIQQ_bWI/AAAAAAAACPU/qT8T6s84uBkrz8Jm1R8pabktodD97kUBACLcBGAsYHQ/s320/9.PNG" width="320" /></a></div><br />Because we go through every edge once<br />=&gt; The last edge needs to be gone through 3 times to find shortest path</div><h3>BellMan- Ford Algorithm</h3><div>Find the shortest distance to all path from a specific node s<br />by making using of relaxing but using relax for each vertices present in the graph</div><div>ie. do not just go through the vertices once</div><div>If there are no neg weight, after bellman ford algo terminate, we will get the shortest distance</div><div><br /></div><div><span class="fontstyle0">BellmanFord(V,E)<br />&nbsp;n = V.length<br />&nbsp;for i = 1 to n-1<br />&nbsp; &nbsp; for Edge e in E //relax part<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;relax(e)</span></div><div><br /></div><div><b>Proof</b></div><div>k&lt;|v| - 1 where k is how long p can be (shortest path)</div><div>At each iteration we relax all e edges,</div><div>by path relaxation property, after |v| - 1 iteration,</div><div>d[t =V(k)] = s [t =V(k)]</div><div><br /></div><div><span style="color: red;"><b>The runtime is O(VE)</b></span></div><div><br /></div><div><b><span style="color: red;">We can terminate when an entire of |E| relax operation have no effect within one for loop of edges</span></b><br /><br /></div><div><br /></div><div>This will work almost the same for negative weights.. almost<br />It will not be able to work if there is a <b>negative cycle.</b></div><div><br /></div><h4>Same weight:</h4><div>Just run BFS</div><div><h4>Negative cycles:</h4></div><div>Main idea: Run bellman-ford for V iteration,</div><div>if estimate changes in last iteration then neg cycle</div><div><br /></div><div>- Run the for loop one more time</div><div><br /></div><div>for every edge</div><div>&nbsp; &nbsp; &nbsp; if need relax</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return false //Theres negative cycles</div><div>&nbsp;return true</div><h3>Trees (Redefine)</h3><div>A tree has only one way to get to one location to another without backpedaling<br />This is due to a tree property.</div><h4>Undirected Tree</h4><div>- Graph with no cycle is an undirected tree</div><div><br /></div><div><b>Rooted Tree</b></div><div><b><br /></b></div><div>A tree with a special designated root node<br /><br /><b>Source to all</b><br />What is the cost to get to all the places?<br />Shortest Path:<br /><b><span style="color: red;">We should relax the nodes using DFS Order</span></b><br /><span style="color: red;"><b>=&gt; we want to visit every node</b></span><br />=&gt; Once we update a node, we never have to update it again<br />This is because all nodes can be access in one way only<br />This works for negative weights as well.<br /><br /><span style="color: red;"><b>The running time is O(v) or O(e)</b></span><br />=&gt; All nodes got 1 parent<br />=&gt; Edges = v - 1<br /><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-J3q33uChgtw/XaBNwfAUxtI/AAAAAAAACNA/psql1HAzAX0mG-zCSwlQ7TDoq31fDJphwCLcBGAsYHQ/s1600/graph.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="772" data-original-width="723" height="640" src="https://1.bp.blogspot.com/-J3q33uChgtw/XaBNwfAUxtI/AAAAAAAACNA/psql1HAzAX0mG-zCSwlQ7TDoq31fDJphwCLcBGAsYHQ/s640/graph.png" width="598" /></a></div><br /><br /></div><div><br /></div>