---
layout: post
title: CS2040s - Binary heap and Priority Queue
date: '2019-09-02T22:25:00.000-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-10-11T02:16:44.853-07:00'
thumbnail: https://1.bp.blogspot.com/-Vjm0MVyjkSs/XYhI3qeuUOI/AAAAAAAACHw/nF_oOUZ7124BSR_5kA5KZS_4P1-AC0DSgCLcBGAsYHQ/s72-c/1.PNG
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-8488945159792568415
blogger_orig_url: https://nusmods.blogspot.com/2019/09/cs2040s-binary-heap-and-priority-queue.html
---

<h2>Priority Queue</h2><div>Its automatically sorted and sorted based on the comparator provided. Technically, a heap is a priority queue..</div><div><br /></div><div><br /></div><div>Problem:</div><div>Each patient is assigned a priority score and the doctors will look at the patients that needed help first.</div><div>What operations do we need to support?</div><div><br /></div><div><span class="fontstyle0">Operations:</span><br /><span class="fontstyle1"> </span><span class="fontstyle3">insert(x) </span><span class="fontstyle4">: inserts x</span><br /><span class="fontstyle1"> </span><span class="fontstyle3">max() </span><span class="fontstyle4">: returns element with the highest priority</span><br /><span class="fontstyle1"> </span><span class="fontstyle3">extractMax() </span><span class="fontstyle4">: returns and remove the highest priority element</span><br /><span class="fontstyle1"> </span><span class="fontstyle3">size() </span><span class="fontstyle4">: returns the size of the queue</span><br /><span class="fontstyle1"> </span><span class="fontstyle3">buildHeap(A) </span><span class="fontstyle4">: creates a priority queue from an array of patients</span>&nbsp;&nbsp;</div><div><br /></div><div><span style="color: red;"><b>Whats the worst case time complexity of insert followed by extractmax if we use a singly linked</b></span></div><div><span style="color: red;"><b>list</b></span></div><div><span style="color: red;"><b>&nbsp;n+ n = 2n&nbsp; = o(n)</b></span><br />-&gt;We have to scan through the to find the max (or next maximum) or insert have to maintain sorted order</div><div><br /></div><div><span style="color: red;"><b>What is the worst case time complexity of insert followed by extractMax if we use an array?</b></span></div><div><span style="color: red;"><b>O(logn)</b></span></div><div>-&gt;Because the cher scammed us, we are using a heap<br />Both insert and extractMax uses logn because every time we added/take we need to check heap rule violation</div><div><br /></div><h4>Exploiting Structure</h4><div>Maintaining order in a data structure is not free, We still have to pay for time/ memory</div><div><br /></div><div>Unsorted Array:</div><div>Insert -&gt; O(1)</div><div>Max - &gt; O(n)</div><div>Search -&gt; O(n)</div><div><br /></div><div>Sorted Array:</div><div><div>Insert -&gt; O(n)</div><div>Max - &gt; O(1)</div><div>Search -&gt; O(logn) //binary search</div></div><div><br /></div><div><span style="color: red;"><b>Binary Heap:</b></span></div><div><div><span style="color: red;"><b>Insert -&gt; O(logn)</b></span></div><div><span style="color: red;"><b>Max - &gt; O(1)</b></span></div><div><span style="color: red;"><b>Search -&gt; O(n)</b></span></div></div><div><br /></div><h4>Binary Tree</h4><div>A binary tree is not a binary search tree. It can be sorted or unsorted as long as it is following this structure:</div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-Vjm0MVyjkSs/XYhI3qeuUOI/AAAAAAAACHw/nF_oOUZ7124BSR_5kA5KZS_4P1-AC0DSgCLcBGAsYHQ/s1600/1.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="257" data-original-width="271" src="https://1.bp.blogspot.com/-Vjm0MVyjkSs/XYhI3qeuUOI/AAAAAAAACHw/nF_oOUZ7124BSR_5kA5KZS_4P1-AC0DSgCLcBGAsYHQ/s1600/1.PNG" /></a></div><div>A binary tree can have at most 2 children.</div><div>Values can be repeated.</div><div><br /></div><div>Height of Node: Number of edges on the longest path from node to a leaf (from its children)<br />Depth of Node: Number of edges to the root. (from the root)<br />Edges: Each arrow<br /><br />The height of the tree is equal to the dept of its deepest node.</div><div>The height of a node is the number of edges on the longest path from node to a left<br /><br /></div><div><br /></div><div>We do not count the first node as part of the height</div><div><br /></div><div><br /><br /><h4>Complete Binary Tree</h4></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-b3ZSSHXh7XQ/XYhLg14EOVI/AAAAAAAACH8/CNkxacR2uz8Fq84NTRWSK6lxOp4k0p8SACLcBGAsYHQ/s1600/2.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="229" data-original-width="654" height="136" src="https://1.bp.blogspot.com/-b3ZSSHXh7XQ/XYhLg14EOVI/AAAAAAAACH8/CNkxacR2uz8Fq84NTRWSK6lxOp4k0p8SACLcBGAsYHQ/s400/2.PNG" width="400" /></a></div><div><br /></div><div>The tree is perfectly balance, except for bottom level.</div><div>All levels are completely filled except possibly last level where the keys are filled from left to right.</div><div><br /></div><div><b><span style="color: red;">The height h of a complete binary tree is {logn} &lt;- floor</span></b></div><div>where n is the number of values in the tree.</div><h2>Binary Heap</h2><div>A binary heap should have each parent be larger/smaller or equal than the child depending if its Max/Min heap respectively.</div><div><br /></div><h4>Tree Representation</h4><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-XqwS6RqICMM/XYhOhq85YeI/AAAAAAAACII/zIHm8fWkG_0rU6AxJ4Y_IPN_OXkwgDtcwCLcBGAsYHQ/s1600/3.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="197" data-original-width="282" height="223" src="https://1.bp.blogspot.com/-XqwS6RqICMM/XYhOhq85YeI/AAAAAAAACII/zIHm8fWkG_0rU6AxJ4Y_IPN_OXkwgDtcwCLcBGAsYHQ/s320/3.PNG" width="320" /></a></div><div><br /></div><div><span class="fontstyle0">Class Node<br />&nbsp; &nbsp; &nbsp; Object key<br />&nbsp; &nbsp; &nbsp; Object data<br />&nbsp; &nbsp; &nbsp; Node leftchild<br />&nbsp; &nbsp; &nbsp; Node rightchild<br />&nbsp; &nbsp; &nbsp; Node parent</span>&nbsp;&nbsp;</div><div><br /></div><h4>Array Representation</h4><div>Indices start at 1</div><div>Takes nodes in level order</div><div>There's no need to link</div><div><u>Every parent with index n will have its child being n*2 (left) or n*2+1 (right)</u><br /><u><br /></u></div><div><br /></div><div><br /></div><h3>Sink and Swim</h3><div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-gvCtVpsgUy4/XYhQxafK_wI/AAAAAAAACI4/GkgSR3i4NxkO55MGCUWsar2pSg79xlGQwCLcBGAsYHQ/s1600/5.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="270" data-original-width="429" src="https://1.bp.blogspot.com/-gvCtVpsgUy4/XYhQxafK_wI/AAAAAAAACI4/GkgSR3i4NxkO55MGCUWsar2pSg79xlGQwCLcBGAsYHQ/s1600/5.PNG" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><br /></div><div><b>Swim (Shiftup, Bubbleup, IncreaseKey)</b></div><div>To go up the heap</div><div><br /></div><div>Problem: If the key becomes larger than the parent</div><div>Solution:</div><div>- Swap Child with parent</div><div>- Repeat until heap order is restored</div><div><br /></div><div>PseudoCode for array implementation<br /><br /></div><div><span class="fontstyle0">function swim(A, k)<br />while (k &gt; 1) and A[k/2].key &lt; A[k].key<br />swap(A[k], A[k/2])<br />k = k/2</span>&nbsp;&nbsp;</div><div><br /></div><div><br /></div><div><div><b>Sink (ShiftDown, BubbleDown, Heapify)</b></div><div>To go down the heap</div></div><div><br /></div><div>Problem: If key is smaller than the one or both of its child<br /><br /></div><div>Solution:</div><div>- Swap with the larger child</div><div>- Repeat until the order is restored</div><div><br /></div><div>Pseudocode</div><div><span class="fontstyle0">function sink(A, k)<br />while (2k &lt;= n) //number of items in subheap<br />&nbsp; &nbsp; &nbsp;j = 2k<br />&nbsp; &nbsp; &nbsp;if (j&lt;n and (A[j].key &lt; A[j+1].key)) j++<br />&nbsp; &nbsp; &nbsp;if not (A[k].key &lt; A[j].key), break<br />&nbsp; &nbsp; &nbsp;swap(A[k], A[j])<br />&nbsp; &nbsp; &nbsp;k = j</span>&nbsp; //change index<br /><br /><br /></div><div><h4>Extracting the largest value</h4></div><div>When extracting the max/min for a max/min heap sort respectively, we must</div><div>1. Swap the last index with the first (The first is assumed the largest)</div><div>2. Remove the last index (pop)</div><div>3. Sort</div><div><br /></div><div><b>Sorting a binary heap takes logn time</b><br /><b><br /></b></div><div><div><b><span style="color: red;">Insertion of a binary heap cost logn</span></b></div><div>-&gt; Add node o(1), swim/sink o(logn)<br />-&gt; Swim/sink is logn because its traversing not the whole tree<br /><br /></div></div><div><span style="color: red;"><b>ExtractMax takes up to O(logn)</b></span></div><div>-&gt; We need to sort (swim/sink) again</div><div><br /></div><div><b><span style="color: red;">Building a binary heap cost n time</span></b></div><div>To put in -&gt; n //theres n items</div><div>To sort -&gt; N //still need to traverse</div><div>n+n =&gt; O(n)</div><div><br /></div><div>Robert Floyd's creation:</div><div>- View the input array as binary tree</div><div>- Bottom up fixing of the tree to satisfy maxheap property<br />- Make use of recursion to go from bottom to up, viewing each 2 sub heap as wanting to merge together.</div><div><br /></div><div>If we want to merge a root to two heaps, we combined them and we <u><span style="color: red;">sink</span></u></div><div><br /></div><div>Its N time because the sorting of the binary heap still has to iterate every element and checking its parents by taking childindex/2.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-_pg1OKbc14M/XYhgq4qjTtI/AAAAAAAACJI/k9sj8cK7i58yS_FUDOue4bLc3Eod0CihACLcBGAsYHQ/s1600/6.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="259" data-original-width="532" height="155" src="https://1.bp.blogspot.com/-_pg1OKbc14M/XYhgq4qjTtI/AAAAAAAACJI/k9sj8cK7i58yS_FUDOue4bLc3Eod0CihACLcBGAsYHQ/s320/6.PNG" width="320" /></a></div><br /><u>The iteration goes from the back of the binary heap to the front.</u><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-TKwOn61CZBw/XYhiRxuv6WI/AAAAAAAACJU/YDRLaC85kDMBlS4QrwNDAZhFcsTM2qTxQCLcBGAsYHQ/s1600/7.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="255" data-original-width="485" height="168" src="https://1.bp.blogspot.com/-TKwOn61CZBw/XYhiRxuv6WI/AAAAAAAACJU/YDRLaC85kDMBlS4QrwNDAZhFcsTM2qTxQCLcBGAsYHQ/s320/7.PNG" width="320" /></a></div><br /><br />PseudoCode:<br /><span class="fontstyle0">function buildHeap(A)<br />for i from A.length/2 to 1 //i is the counter for index<br />sink(i)</span><br />//its counting down<br /><br />we realised that the divide by 2 ensures that we will only look at the elements that are not the last element.<br /><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-EbG91jAcrgA/XYhjvF1wCOI/AAAAAAAACJg/x0ddL33nEDwGWx4u8C8Nkbny3z4Nt39xQCLcBGAsYHQ/s1600/8.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="278" data-original-width="621" height="178" src="https://1.bp.blogspot.com/-EbG91jAcrgA/XYhjvF1wCOI/AAAAAAAACJg/x0ddL33nEDwGWx4u8C8Nkbny3z4Nt39xQCLcBGAsYHQ/s400/8.PNG" width="400" /></a></div><br /></div><div>There will never be any violation at the last height of the heap (one element heap) so we don't need to iterate the , but as the height increase, there is a more amount of work done because we need to check each child at the bottom if the rule is violated.</div><div>At level h, there are 2^(H-h) nodes so work down per level is ch2^(H-h), where H is total height<br /><br /><br /></div><div><h4>HeapSort</h4></div><div><i><span style="color: red;"><b>The computational complexity of sorting using a binary heap is O(nlogn), space is O(n)</b></span></i></div><div><span class="fontstyle0">function heapsort(A)<br />&nbsp; &nbsp; n = length(A)<br />&nbsp; &nbsp; sorted = new Array[n]<br />&nbsp; &nbsp; binheap = buildHeap(A)<br />&nbsp; &nbsp; for i = n-1 to 0 <span style="color: red;">//iterate n times</span><br />&nbsp; &nbsp; a = binheap.extractMax()&nbsp; <span style="color: red;">//log n times</span><br />&nbsp; &nbsp; &nbsp;sorted[i] = a</span><br /><br /><i>But we can change the space to O(1)</i></div><div><br /><br /></div><div>- Take the largest element, swap with last index<br />- Move pointer down</div><div>- Ensure heap not violated without including sorted section</div><div>- Repeat 2<br />- Stop until reach first index</div><div><br /></div><div><br /></div><div><span class="fontstyle0">function heapsort(A)<br />n = A.length</span></div><div><span class="fontstyle0">&nbsp;</span><span class="fontstyle0" style="color: #3e8853;">// create the binary heap</span><br /><span class="fontstyle0">for i = n/2 to 1 //takes n time</span><br /><table class="NormalTable"><tbody><tr><td width="353"><span class="fontstyle0">&nbsp; &nbsp; &nbsp; &nbsp; sink(A, k, n)</span><span class="fontstyle0" style="color: #3e8853;">// swap and sink</span><br /><span class="fontstyle0">while (n &gt; 1) //takes logn<br />&nbsp; &nbsp; swap(A, 1, n);</span></td></tr></tbody></table><span class="fontstyle0">&nbsp; &nbsp; &nbsp;sink(A, 1, --n);</span>&nbsp;&nbsp;</div><div><br /></div><div><span style="color: red;"><b><i>Space complexity is O(1), Swap and sink takes O(nlogn)</i></b></span><br /><span style="color: red;"><b><i>-&gt; Creation is O(n)</i></b></span><br /><span style="color: red;"><b><i>-&gt; Swap and Sink O(nlogn)</i></b></span></div><div><span style="color: red;"><b><i><br /></i></b></span></div><div><h3>HeapSort Compared to Quicksort</h3></div><div><br /></div><div>Heapsort is optimal for time and space but</div><div>- Inner loop is longer than quicksort</div><div>- Bad Caching (Children are far from parent)</div><div>- Not stable<br /><br /></div><div>Quicksort is still faster in practice because it does not do unnecessary swaps<br /><h3>MinHeap</h3><div>The top is the minimum item.</div><div><br /></div><div>- Negate all keys</div><div>- Change comparator</div><div class="separator" style="clear: both; text-align: center;"></div>- Instead of sink we swim (Possible)</div><h3>IntroSort (Additional Info)</h3><div>- Run quicksort</div><div>- Cutoff to heapsort if stack depth exceeds 2logn</div><div>- Cutoff to insertion sort for n=16</div><div><br />This is nlogn<br /><br /><h3>Summary:</h3><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-QzQoBjYnXvE/XYholKbo9kI/AAAAAAAACJ0/Mi0JP0QwZ8IvJL-6eHHgjeL649TVTismQCLcBGAsYHQ/s1600/9.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="753" data-original-width="1046" height="459" src="https://1.bp.blogspot.com/-QzQoBjYnXvE/XYholKbo9kI/AAAAAAAACJ0/Mi0JP0QwZ8IvJL-6eHHgjeL649TVTismQCLcBGAsYHQ/s640/9.PNG" width="640" /></a></div><div><h3></h3></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-BNmd817ZmiY/XaBIK4U94yI/AAAAAAAACMs/cZzDW2QI0ucQxLv9yvdaz3hBKnoCpbEkQCLcBGAsYHQ/s1600/sort1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="401" data-original-width="1055" height="243" src="https://1.bp.blogspot.com/-BNmd817ZmiY/XaBIK4U94yI/AAAAAAAACMs/cZzDW2QI0ucQxLv9yvdaz3hBKnoCpbEkQCLcBGAsYHQ/s640/sort1.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-CbPKQeYAoqc/XaBIRJiIlKI/AAAAAAAACMw/SpK8gqqfShA9QjqeG0tSBJgE5FE0bV6wwCLcBGAsYHQ/s1600/sort2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="261" data-original-width="1339" height="124" src="https://1.bp.blogspot.com/-CbPKQeYAoqc/XaBIRJiIlKI/AAAAAAAACMw/SpK8gqqfShA9QjqeG0tSBJgE5FE0bV6wwCLcBGAsYHQ/s640/sort2.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-U9Xeix06jT8/XaBHw_E9xMI/AAAAAAAACMk/Ksyy-Jya5AkNELvY4H5eKHheXIEOKUxIQCLcBGAsYHQ/s1600/ds.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="667" data-original-width="1465" height="291" src="https://1.bp.blogspot.com/-U9Xeix06jT8/XaBHw_E9xMI/AAAAAAAACMk/Ksyy-Jya5AkNELvY4H5eKHheXIEOKUxIQCLcBGAsYHQ/s640/ds.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><br /></div><div><br /></div><div><a href="https://nusmods.blogspot.com/2019/08/cs2040s-lecture-5-quicksort.html">&lt;Prev</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Next&gt;</div>