---
layout: post
title: 'CS2040s: Algo analysis'
date: '2019-08-21T08:31:00.000-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-09-03T02:43:21.894-07:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-6148729318958684403
blogger_orig_url: https://nusmods.blogspot.com/2019/08/cs2040s-algo-analysis.html
---

<h3>Types of sorts</h3><br /><b>Bubble sort</b><br />1. Start from index 0<br />2. Each time element is compared (ie current index) with the next element<br />3. If the next is bigger than current, do nothing, move to the next element<br />&nbsp;If the next is smaller than current, swap with next and then increment index counter<br />4. Repeat step 2<br /><br />The back is always sorted first<br />Sorted Right to left<br />O(n^2)<br />S(1)<br />Swaps: n^2<br /><br /><b>Selection sort</b><br />1.&nbsp; Start for index 0, pointer 1 will point at this element<br />2.&nbsp; As iterate up each index, compare each of the remaining values with my pointer 1<br />3. If its smaller, a new pointer 2 will point to it, everytime a smaller value is encountered, reassign pointer 2 with it<br />4. When reach the end, swap pointer 2 with pointer 1.<br />5. Move on to the next index, with pointer 1 pointing at that element<br />6. repeat step 2<br /><br />The front is sorted first<br />Sorted Left to Right<br />O(n^2)<br />S(1)<br />Swaps N<br /><br /><b>Insertion sort</b><br />1. Start from index 1<br />2. Iterate backwards if the prev index is larger than current<br />3. Insert if the prev index element is smaller than current<br />5. Stop iterating backwards<br />6. Iterate forwards once o the next element<br />7. Repeat 2<br /><br />The front is sorted first<br />Sorts from left to right<br />The left is almost sorted<br />O(n^2)<br />S(1)<br />Swaps N^2<br /><br /><h4>Merge sort:</h4>Using recursion, we do wishful thinking and we have a merge function already<br />We merge left and right<br />Then combine it together.<br /><br />Visually<br />1. Split the ADT into half<br />2. Continue splitting it into half until there's only one element in each half<br />3. Combine by comparison, sorting each half each time<br /><br />Algo:<br />1. Find mid by dividing high+low<br />2, In sort function, check that low&lt; high,&nbsp; sort right and left, merge it afterwards<br />3. In merge function, while low&lt;high, create two temp copies of arrays left and right with mid as the border<br />4. 3 while loops:<br />- If left counter and right counter haven exit the index<br />&nbsp; &nbsp;put the smaller element into final<br />&nbsp; &nbsp;increase respective counter. ie left index counter or right<br /><br />- If left counter haven exit index and right has finish<br />&nbsp; &nbsp;put all remain left elements into array<br /><br />- If right counter haven exit index and lefthas finish<br />&nbsp; &nbsp;put all remain right elements into array<br /><br />O(nlogn)<br />S(n)<br />Divide and conquer<br />No swaps<br /><br /><h4>Order of Growth</h4><div><u>Joshua Wee Shing Hao sucks and snakes all the time</u></div><div><br /></div><div>If the function is f(x) = t^2 + t</div><div>we can just take it as t^2 since t is insignificant compared to t^2</div><div><br /></div><div>3 ways to express:</div><div><br /><h4>Big O</h4></div><div><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0">O(g(n)) is a set that contains non-neg function that are smaller than cg(n) for large n.</span></span></span></span></span></span><br /><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0">If i can find a constant and multiply it to a g(n), if its bigger than f(n), our original function, then its the upper bound</span></span></span></span></span></span><br /><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><br /></span></span></span></span></span></span></div><div><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0">"Upper bound" for some function fn</span></span></span></span></span></span></div><div>f(n) = O(g(n))</div><div>where 0&lt;= f(n) &lt;= cg(n)</div><div><br /></div><div>Question:</div><div><b><i><span style="color: red;">Is 2^n+1 = o(2^n)</span></i></b></div><div><b><i><span style="color: red;">-&gt; Yes</span></i></b></div><div>because o(2^n) is some constant * f(c)</div><div>thus if we let constant = 2, it holds true as 2^n+1 is 2^n * 2</div><div><br /></div><div><b><i><span style="color: red;">This is for worst case scenario</span></i></b></div><div>If we say an algo is O(n^2), the worse running time is O(n^2) and the running time will not exceed cn^2 for large n<br /><br /><b><i><span style="color: red;">Worst Case running time for statement x=1</span></i></b><br /><b><i><span style="color: red;">O(1)</span></i></b></div><div><br /><b>Big Omega (EXTRA)</b></div><div>Is a set that contains non-negative functions that are larger or equal than cg(n) for large n and some constant c.<br /><br /></div><div>"Lower bound"&nbsp;</div><div><br /></div><div><b>Big theta (EXTRA)</b></div><div><div>Is a set that contains non negative functions that are larger than c1g(n) and smaller than c2g(n) for large n and some constants c2 and c1</div><div>"sandwich"<br /><br />We can prove the equation true by making c the subject of the inequality equation<br /><br /><span style="color: red;"><i><b>Even thou selection sort and bubble sort are both O(n^2), they are not equivalent in performance.</b></i></span><br /><br /><br /><br /><a href="https://nusmods.blogspot.com/2019/08/cs2040s-adt-linked-list-vs-arrays.html">&lt; Prev&nbsp; </a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="https://nusmods.blogspot.com/2019/08/cs2040s-binary-search-and-merge-sort.html"> Next &gt;</a></div></div>