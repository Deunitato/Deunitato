---
layout: post
title: 'CS2040s: BST'
date: '2019-09-09T22:13:00.000-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-09-23T02:05:03.343-07:00'
thumbnail: https://1.bp.blogspot.com/-qWwzsPKpCMc/XXu9P7SJo_I/AAAAAAAACFc/HN0FZ7RZdZwsWrwvRaLzEqUfzyksIEU6wCLcBGAsYHQ/s72-c/1.PNG
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-7692381791344927780
blogger_orig_url: https://nusmods.blogspot.com/2019/09/cs2040s-bst.html
---

<h2>Binary Search Tree</h2><div>Is an ordered dictionary ADT.<br /><span class="fontstyle0">Operations with k = key, v = value:</span><span class="fontstyle2">&nbsp;</span><br /><span class="fontstyle2"><br /></span><br /><ul><li><span class="fontstyle0">insert(k, v):inserts an element with value v and key k</span></li></ul><ul><li><span class="fontstyle2">search(k): </span><span class="fontstyle0">returns the value with key k</span></li></ul><ul><li><span class="fontstyle2">delete(k): </span><span class="fontstyle0">deletes the element with key k</span></li></ul><ul><li><span class="fontstyle2">contains(k): </span><span class="fontstyle0">true if the dictionary contains an element with key k</span></li></ul><ul><li><span class="fontstyle2">floor(k): </span><span class="fontstyle0">returns next key </span><span class="fontstyle3">≤ </span><span class="fontstyle0">k</span></li></ul><ul><li><span class="fontstyle2">ceiling(k): </span><span class="fontstyle0">returns next key </span><span class="fontstyle3">≥ </span><span class="fontstyle0">k</span></li></ul><ul><li><span class="fontstyle2">size(): </span><span class="fontstyle0">returns the size of the dictionary</span>&nbsp;</li></ul><br />This is also called Ordered Symbol Tables<br /><br /><br /></div><div>The left child is smaller than the parent and the right child is larger than the parent.</div><div>The height is the number of edges on the longest path from node to a leaf</div><div>Depth of anode is the number of edges to the root.</div><div>Height of tree = depth of deepest node</div><div><br /></div><h3>Properties</h3><div>- Nodes left subtree contains keys with strictly less than node's keys</div><div>- Nodes right subtree contains keys with strictly more than node's keys.</div><div>- The left and right subtrees are binary trees</div><div><u>- There cannot be the same keys</u></div><div><br />Are these trees:<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-qWwzsPKpCMc/XXu9P7SJo_I/AAAAAAAACFc/HN0FZ7RZdZwsWrwvRaLzEqUfzyksIEU6wCLcBGAsYHQ/s1600/1.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="287" data-original-width="465" height="196" src="https://1.bp.blogspot.com/-qWwzsPKpCMc/XXu9P7SJo_I/AAAAAAAACFc/HN0FZ7RZdZwsWrwvRaLzEqUfzyksIEU6wCLcBGAsYHQ/s320/1.PNG" width="320" /></a></div><br /></div><div><div style="text-align: center;"><span style="color: red;"><b>Yes</b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-V15IOfxA9CE/XXu9WL3Ug4I/AAAAAAAACFg/5Ja4sf3oCj4BQD1VQ3JDpoK84Czf_sNUgCLcBGAsYHQ/s1600/2.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="278" data-original-width="466" height="190" src="https://1.bp.blogspot.com/-V15IOfxA9CE/XXu9WL3Ug4I/AAAAAAAACFg/5Ja4sf3oCj4BQD1VQ3JDpoK84Czf_sNUgCLcBGAsYHQ/s320/2.PNG" width="320" /></a></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div></div><div><div style="text-align: center;"><span style="color: red;"><b>No</b></span><br /><span style="color: red;"><b>-&gt; 50 is bigger than 12</b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-Mc89GyX_JG0/XXu9bFvQtPI/AAAAAAAACFk/dEv2Zq1IPUcfNcWNaIEbVPQ091qR5GlvwCLcBGAsYHQ/s1600/3.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="277" data-original-width="459" height="193" src="https://1.bp.blogspot.com/-Mc89GyX_JG0/XXu9bFvQtPI/AAAAAAAACFk/dEv2Zq1IPUcfNcWNaIEbVPQ091qR5GlvwCLcBGAsYHQ/s320/3.PNG" width="320" /></a></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div></div><div><div style="text-align: center;"><span style="color: red;"><b>Yes</b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-PwoFfUKFgMw/XXu9eiSZbiI/AAAAAAAACFo/hczbdyYiYcQCkM_m2_OfBOGciJWjdz3AACLcBGAsYHQ/s1600/4.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="285" data-original-width="382" height="238" src="https://1.bp.blogspot.com/-PwoFfUKFgMw/XXu9eiSZbiI/AAAAAAAACFo/hczbdyYiYcQCkM_m2_OfBOGciJWjdz3AACLcBGAsYHQ/s320/4.PNG" width="320" /></a></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div></div><div><div style="text-align: center;"><span style="color: red;"><b>Yes</b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-yN-59L0Lp3w/XXu9iXfDqpI/AAAAAAAACFs/srfbBj2GagM8pE3CGKNpbMrC8oyO3W8QQCLcBGAsYHQ/s1600/5.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="288" data-original-width="442" height="208" src="https://1.bp.blogspot.com/-yN-59L0Lp3w/XXu9iXfDqpI/AAAAAAAACFs/srfbBj2GagM8pE3CGKNpbMrC8oyO3W8QQCLcBGAsYHQ/s320/5.PNG" width="320" /></a></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div></div><div><div style="text-align: center;"><span style="color: red;"><b>No</b></span><br /><span style="color: red;"><b>-&gt; 13 is bigger than 12</b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-Ckz3BDVshSY/XXu9mdZglVI/AAAAAAAACF0/pKcUYsvDYZkX90YVyDLvQbtbrFPXYKWBQCLcBGAsYHQ/s1600/6.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="265" data-original-width="321" height="264" src="https://1.bp.blogspot.com/-Ckz3BDVshSY/XXu9mdZglVI/AAAAAAAACF0/pKcUYsvDYZkX90YVyDLvQbtbrFPXYKWBQCLcBGAsYHQ/s320/6.PNG" width="320" /></a></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div></div><div><div style="text-align: center;"><span style="color: red;"><b>Yes</b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-VSAWtUqK2EU/XXu9qZlTSlI/AAAAAAAACF4/Zjkjq9gsRJ84W3bOPns_ylDr9vwgfujUgCLcBGAsYHQ/s1600/7.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="285" data-original-width="426" height="214" src="https://1.bp.blogspot.com/-VSAWtUqK2EU/XXu9qZlTSlI/AAAAAAAACF4/Zjkjq9gsRJ84W3bOPns_ylDr9vwgfujUgCLcBGAsYHQ/s320/7.PNG" width="320" /></a></div><div style="text-align: center;"><span style="color: red;"><b><br /></b></span></div></div><div><div style="text-align: center;"><span style="color: red;"><b>No</b></span><br /><span style="color: red;"><b>-&gt; repeats</b></span></div></div><div><div style="text-align: center;"><br /></div></div><div>Problem:</div><div>We are doing a charity call but we need to know exactly how many families earn exactly $a amount and less than $a amount or more than $a amount.</div><div>What kind of Operation do we need?</div><div><br /></div><h3>Operations:</h3><div><br /><br /><ul><li><span class="fontstyle0">height(): </span><span class="fontstyle2">returns the height of the node</span></li></ul><ul><li><span class="fontstyle0">search(k) : </span><span class="fontstyle2">returns an object v with key k</span></li></ul><ul><li><span class="fontstyle0">searchMin() : </span><span class="fontstyle2">finds the minimum key k</span></li></ul><ul><li><span class="fontstyle0">searchMax() : </span><span class="fontstyle2">finds the maximum key k</span></li></ul><ul><li><span class="fontstyle0">successor()</span><span class="fontstyle0">: </span><span class="fontstyle2">returns next key &gt; k</span></li></ul><ul><li><span class="fontstyle0">predecessor():</span><span class="fontstyle0"> </span><span class="fontstyle2">returns next key &lt; k</span></li></ul><ul><li><span class="fontstyle0">insert(k,v): </span><span class="fontstyle2">inserts an object v with key k</span></li></ul><ul><li><span class="fontstyle0">delete(k) : </span><span class="fontstyle2">deletes the node with key k</span>&nbsp;&nbsp;</li></ul><br /></div><div><br /></div><h4>Height</h4><div>Makes use of recursion to get the height.</div><div>We will check the height of the left and the right tree and return the biggest +1<br />ie. h(o) = max(h(o.left),h(o.right)) +1</div><div>We will stop checking when reach the base case,<br />ie. h(o) = 0 where o is the tree<br /><br />PSEUDOCODE<br /><span class="fontstyle0">function height()<br />&nbsp; leftHeight = -1 //this is a zero becos we will return a +1 (Basecase)<br />&nbsp; rightHeight = -1<br />&nbsp; if m_leftTree is not null<br />&nbsp; &nbsp; &nbsp; &nbsp;leftHeight = m_leftTree.height()<br />&nbsp; if m_rightTree is not null<br />&nbsp; &nbsp; &nbsp; &nbsp;rightHeight = m_rightTree.height()<br />&nbsp; return</span>&nbsp;max(leftHeight, rightHeight)&nbsp;+ 1<br /><br /><div><span style="color: red;">In a standard BST with N nodes, what is worst case height?</span></div><div><span style="color: red;">-&gt;O(n)</span></div><div>It can be one sided and form a chain</div></div><h4>Searching&nbsp;</h4><div>We binary search inside a bst using recussion</div><div>If the searchingkey &lt; currentKey</div><div>-&gt; Go left</div><div>&nbsp; &nbsp; -&gt; If left is null, return not found</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else continue recusion</div><div>else if searchingkey &gt; currentKey</div><div>&nbsp;-&gt; Go Right</div><div>&nbsp; &nbsp; &nbsp;-&gt; if right is null, return not found</div><div>else</div><div>return this</div><div><br /></div><div><br /><br /><h4>MinMax keys</h4></div><div>The minimum key is at the left most node and the maximum key is the right most node&nbsp;</div><div><span class="fontstyle0">function searchMin()<br />&nbsp; &nbsp;if m_leftTree is not null<br />&nbsp; &nbsp; &nbsp; &nbsp;return m_leftTree.searchMin()</span></div><div><span class="fontstyle0"><br />return this</span></div><div><span class="fontstyle0"><br /></span></div><div><span class="fontstyle0"><br />function searchMax()<br />&nbsp; &nbsp;if m_rightTree is not null<br />&nbsp; &nbsp; &nbsp; &nbsp;return m_rightTree.searchMax()<br />&nbsp; &nbsp; return this</span>&nbsp;&nbsp;</div><div><b><br /></b></div><div><div><span style="color: red;"><b>In the standard BST, which search have the worst time case?</b></span></div><div><span style="color: red;"><b>Searchmin , searchmax , search</b></span></div><div><span style="color: red;"><b>-&gt;They are all the same O(h)</b></span></div><div></div></div><h4>&nbsp;Successor</h4><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-9ZXKcWdaevg/XYh6zeEaRjI/AAAAAAAACKA/QpQGUrHZ4c4pH2bwUS6Ge69LWTHDzH85ACLcBGAsYHQ/s1600/4.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="176" data-original-width="268" src="https://1.bp.blogspot.com/-9ZXKcWdaevg/XYh6zeEaRjI/AAAAAAAACKA/QpQGUrHZ4c4pH2bwUS6Ge69LWTHDzH85ACLcBGAsYHQ/s1600/4.PNG" /></a></div><div><br /></div><div>Successor is the node with the smallest key that is larger than K</div><div><br /></div><div>If o has right subtree</div><div>-&gt; min of right tree</div><div>else</div><div>&nbsp; &nbsp;If o is left child, its parent is successor</div><div>&nbsp; &nbsp;-&gt; Move up one</div><div>&nbsp; &nbsp;If o is right child, the successor is an ancestor that is bigger than myself</div><div>&nbsp; &nbsp;-&gt; Keep going up till find bigger</div><div><br /></div><div><br /></div><div><table class="NormalTable"><tbody><tr><td width="550"><span class="fontstyle0">function successor()<br />if m_rightTree is not null then<br />&nbsp; &nbsp;return m_rightTree.searchMin()<br />else</span></td></tr></tbody></table><span class="fontstyle0">&nbsp; &nbsp; p = m_parent, temp = this //p is my parent<br />&nbsp; &nbsp;&nbsp;</span>while (p is not null) and (temp == p.rightTree)<br />//continue going up, stop loop when i am left tree<br /><span class="fontstyle0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp = p, p = temp.m_parent //change p into my parent<br />&nbsp; &nbsp; &nbsp; if p is null then return -1 //theres no successor<br />&nbsp; &nbsp; &nbsp; else return p</span><br /><br /></div><div><b><span style="color: red;">O(logn)/O(h)</span></b></div><div><br />For predecessor, everything reversed,<br />continue the loop if I am still left tree,<br />stop when I am the right child,<br />Return parent<br /><br /></div><h4>Insertion</h4><div>if insertedKey &gt; current</div><div>-&gt; go right</div><div>&nbsp; &nbsp;-&gt; if key is null, put here //create new node right</div><div>&nbsp; &nbsp; &nbsp; else recurse insert</div><div>else if insertedKey &lt; current</div><div>-&gt; go left</div><div>&nbsp; &nbsp;-&gt; Key is null, put here //create new node left</div><div>&nbsp; &nbsp;else recurse insert</div><div>return<br /><br /><span class="fontstyle0"><br /></span><span class="fontstyle1">function insert(Key k)<br />&nbsp; &nbsp;if k &lt; m_key<br />&nbsp; &nbsp; &nbsp; &nbsp; if m_leftTree is not null<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return m_leftTree.insert(k)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m_leftTree = new BinaryTree(k)<br />&nbsp; &nbsp; else if k &gt; m_key<br />&nbsp; &nbsp; &nbsp; &nbsp;if m_rightTree is not null<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return m_rightTree.insert(k)<br />&nbsp; &nbsp; &nbsp; &nbsp;else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m_rightTree = new BinaryTree(k)<br />&nbsp; &nbsp; else return</span>&nbsp;&nbsp;</div><div><br />Just need to go left or right and check for null each time, insert when see null<br />If not continue recursion<br /><br />This is not AVL, we don't need to make it balance/ do swaps<br />This is the reason why there is a case where the bst is lopsided.<br /><br /><b><span style="color: red;">O(h)</span></b><br /><br /><h4>Shape of the tree &amp; Order of Insertion</h4><span class="fontstyle2">Performance of searching and inserts depends on height.<br />Height depends on shape<br />Shape depends on order of insertion (and deletions)</span><br /><br />But it is not infinite amount of shapes when inserted in different order. There is always the same amount of shapes of BST. But they might be different to each other.</div><h4>Delete</h4><div>- Node not found, do nothing</div><div>- Node is a leaf, remove</div><div>- Node has one child, remove node and connect child to parent</div><div>- Node has 2 children, replace node with its successor. ,<br />if successor have child, reattach loose successor nodes with parents</div><div><br /></div><div>Condition:</div><div>1. Successor s maintains the BST property when inserted to where k use to be</div><div>2. The successor s has at most 1 right child so we can reattach<br /><br /><b><br /></b><span style="color: red;"><b>O(h)</b></span><br /><span style="color: red;"><b>-&gt; Traversal + Successor</b></span></div><div><br /></div><h4>Ceiling</h4><div>-&gt; Number does not have to be from the tree.</div><div><br /></div><div><span class="fontstyle0">function ceiling(Node x, k)<br />if x is null then return null<br />if x.key == k then return x //if equal<br />if k &gt; x.key then //go right<br />&nbsp; &nbsp; return ceiling(x.righttree,K)<br />if k &lt; x.key then</span><br /><span class="fontstyle0">&nbsp; &nbsp; &nbsp;t= ceiling(x.leftTree,k)</span></div><div><span class="fontstyle0">&nbsp; &nbsp;// enter left tree check if its larger than key, if it is then recurse there</span><br /><span class="fontstyle0">&nbsp; &nbsp; &nbsp;if t is not null, return t</span></div><div><span class="fontstyle0">&nbsp; &nbsp; else return me</span></div><div><span class="fontstyle0"><br /></span></div><div><span class="fontstyle0" style="color: red;"><b>O(h)</b></span></div><h4><span class="fontstyle0">Printing nodes in Order</span></h4><div><span class="fontstyle0"><span class="fontstyle0">1. InOrder</span></span><br /><span class="fontstyle0"><span class="fontstyle0">Left, self, Right</span></span><br /><span class="fontstyle0"><span class="fontstyle0"><br /></span></span><span class="fontstyle0"><span class="fontstyle0">function </span><span class="fontstyle0">in-order-traversal()</span></span><br /><span class="fontstyle0"><span class="fontstyle0" style="color: #00b050;">// Traverse left sub-tree</span></span><br /><span class="fontstyle0"><span class="fontstyle0">if </span><span class="fontstyle0" style="color: #2683c6;">m_leftTree </span><span class="fontstyle0">is not </span><span class="fontstyle0">null</span></span><br /><span class="fontstyle0"><span class="fontstyle0" style="color: #2683c6;">&nbsp; &nbsp; &nbsp; &nbsp;m_leftTree</span><span class="fontstyle0">.in-order-traversal()</span></span><br /><span class="fontstyle0"><span class="fontstyle0"><br />visit(this)</span></span><br /><span class="fontstyle0"><span class="fontstyle0"><br /></span></span><span class="fontstyle0"><span class="fontstyle0" style="color: #00b050;">// Traverse right sub-tree</span></span><br /><span class="fontstyle0"><span class="fontstyle0">if </span><span class="fontstyle0" style="color: #2683c6;">m_rightTree </span><span class="fontstyle0">is not null then</span></span><br /><span class="fontstyle0"><span class="fontstyle0" style="color: #2683c6;">&nbsp; &nbsp; &nbsp;m_rightTree</span><span class="fontstyle0">.in-order-traversal()</span>&nbsp;&nbsp;</span><br /><span class="fontstyle0"><br /></span><span class="fontstyle0">- If theres a left subtree, traverse left</span><br /><span class="fontstyle0">- else print myself, the right subtree downwards then go to parent</span></div><div><span class="fontstyle0"><br /></span><span class="fontstyle0"><br /></span></div><div><span class="fontstyle0">2. Pre-Order (Deep-Copy)</span></div><div><span class="fontstyle0">Self, Left, Right</span><br /><span class="fontstyle0"><br /></span><span class="fontstyle0"><span class="fontstyle0">function </span><span class="fontstyle0">deepCopy()<br />n = new Node(key, value)</span></span><br /><span class="fontstyle0"><span class="fontstyle0" style="color: #00b050;">// Traverse left sub-tree</span></span><br /><span class="fontstyle0"><span class="fontstyle0">if </span><span class="fontstyle0" style="color: #2683c6;">m_leftTree </span><span class="fontstyle0">is not </span><span class="fontstyle0">null</span></span><br /><span class="fontstyle0"><span class="fontstyle0">&nbsp; &nbsp; n.</span><span class="fontstyle0" style="color: #2683c6;">m_leftTree = m_leftTree</span><span class="fontstyle0">.deepCopy()</span></span><br /><span class="fontstyle0"><span class="fontstyle0"><br /></span><span class="fontstyle0" style="color: #00b050;">// Traverse right sub-tree</span></span><br /><span class="fontstyle0"><span class="fontstyle0">if </span><span class="fontstyle0" style="color: #2683c6;">m_rightTree </span><span class="fontstyle0">is not </span><span class="fontstyle0">null</span></span><br /><span class="fontstyle0"><span class="fontstyle0">&nbsp; &nbsp; &nbsp;n.</span><span class="fontstyle0" style="color: #2683c6;">m_rightTree </span><span class="fontstyle0">= </span><span class="fontstyle0" style="color: #2683c6;">m_rightTree</span><span class="fontstyle0">.deepCopy()<br />return n</span>&nbsp;&nbsp;</span></div><div><span class="fontstyle0"><br /></span><span class="fontstyle0"><br /></span></div><div><span class="fontstyle0">3. Post-Order (Good for deleting)</span></div><div><span class="fontstyle0">Left, Right, Self</span><br /><span class="fontstyle0"><br /></span><span class="fontstyle0"><span class="fontstyle0">function </span><span class="fontstyle0">deleteTree(Node n)</span></span><br /><span class="fontstyle0"><span class="fontstyle0" style="color: #00b050;">// Traverse left sub-tree</span></span><br /><span class="fontstyle0"><span class="fontstyle0">if </span><span class="fontstyle0">n.</span><span class="fontstyle0" style="color: #2683c6;">m_leftTree </span><span class="fontstyle0">is not </span><span class="fontstyle0">null</span></span><br /><span class="fontstyle0"><span class="fontstyle0">&nbsp; &nbsp; &nbsp;deleteTree(n.</span><span class="fontstyle0" style="color: #2683c6;">m_leftTree</span><span class="fontstyle0">)</span></span><br /><span class="fontstyle0"><span class="fontstyle0"><br /></span><span class="fontstyle0" style="color: #00b050;">// Traverse right sub-tree</span><span class="fontstyle0">if </span><span class="fontstyle0">n.</span><span class="fontstyle0" style="color: #2683c6;">m_rightTree </span><span class="fontstyle0">is not </span><span class="fontstyle0">null </span><span class="fontstyle0">then<br />&nbsp; &nbsp; &nbsp; deleteTree(n.</span><span class="fontstyle0" style="color: #2683c6;">m_rightTree</span><span class="fontstyle0">)<br />free(n)</span>&nbsp;&nbsp;</span></div><h3></h3><div><br /></div><div><br /></div>