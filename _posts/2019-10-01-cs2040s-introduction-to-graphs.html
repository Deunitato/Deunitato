---
layout: post
title: 'CS2040s: Introduction To Graphs'
date: '2019-10-01T22:19:00.001-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-10-22T22:45:30.316-07:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-1097021883731878692
blogger_orig_url: https://nusmods.blogspot.com/2019/10/cs2040s-introduction-to-graphs.html
---

<h2>Graphs</h2><div>Graphs are a couple denoted by G={V,E} (a tuple of two sets)</div><div>where V is the set of vertices and E is set of Edges</div><div>Vertices is the nodes</div><div>Edges are the path connected the nodes</div><div><br /></div><h4>Simple graphs</h4><div>=&gt; A node cannot have edges pointing at itself&nbsp;</div><div>=&gt; only one edge per pair of nodes.</div><div><br /></div><h4>Connected Graphs</h4><div>=&gt; Every node is connected by a path</div><div><br /></div><div><b>Clique</b></div><div>=&gt; A complete graph<br />=&gt; Fully connected<br />=&gt; Every node is connected to every other node<br />=&gt; Every node is only 1 hope from other node<br />=&gt;Dia : 1</div><div>=&gt; All pairs connected by edges</div><div><br /></div><div>Diameter</div><div>=&gt; The maximum distance between two (different) nodes<br />=&gt; Distance is the shortest path</div><div>Check for every two nodes, whats the shortest path of these two nodes<br />&nbsp;Choose the longest (short path) out of all the pair of nodes</div><div><br /></div><div><b>Star</b></div><div>=&gt; One central node</div><div>=&gt; All edges connect to the center to the other nodes</div><div>=&gt; Diameter is 2 always</div><div><br /></div><div>Degree</div><div>=&gt; Number of edges incident upon a node</div><div>=&gt; Loops are counted twice</div><div><br /></div><div>Line</div><div>=&gt; Diameter is n-1</div><div>=&gt; max degree : 2</div><div><br /></div><div>Circle</div><div>=&gt; Diameter is n/2</div><div>=&gt; Max Degree: 2</div><div><br /></div><h3>Representing a Graph</h3><h4>Adjacency List</h4><div>For each node, there is a linked list that store what each node is connected to</div><div><br /></div><div>Memory usage (Space):<br />array of size |v|, linked list of size |E|</div><div>Total O(V+E)</div><div>For a cycle: O(V)</div><div>For clique: O(v^2)</div><h4>Adjacency Matrix</h4><div>Just like a multiplication table, if it connects its denoted by a 1 and 0 if its not connected</div><div>A[v][w] = 1 means that (v,w) is an element of graph E</div><div><br /></div><div>A^2 = length 2 path</div><div><br /></div><div>To find out if c and d are 2 hop neighbours just take B=A^2</div><div>B[c,d] = 1 if it exist</div><div><br /></div><div>if we want length 3 path just take A^3</div><div><br />Memory usage(Space):</div><div>array of size |v| x |V|</div><div>Total: O(V^2)</div><div>For a cycle: O(V^2)</div><div>For Clique: O(V^2)</div><div><br /></div><div><br /></div><div><u>But if a graph is dense (A lot of value) , use a adjacency matrix otherwise use an adjacency list</u></div><div><br /></div><h3>Query</h3><div>To check for connection, its easier to use Adjacency Matrix.</div><div>To check for friend Enumeration (List of friends/connection), its easier to use adjacency list</div><div><br /></div><div><b>Trade-offs</b></div><div><b><br /></b></div><div><u>Adjacency Matrix:</u></div><div><u><br /></u></div><div>- Fast query =&gt; are v and w neighbours?</div><div>- Slow query =&gt; find me any neighbour of v</div><div>- Slow query =&gt; list all neighbour</div><div><br /></div><div><u>Adjacency List</u></div><div><u><br /></u></div><div>- Fast Query=&gt; Find me any neighbour</div><div>- Fast Query=&gt; list all neighbour</div><div>- Slower Query =&gt; Are v and w neighbours (friends)?</div><div><br /></div><div><br /></div><div><b>Directed Graphs</b></div><div>When the edges have a certain direction</div><div>(v,w) means an edge pointing from v-&gt; w</div><div><span style="color: red;">Order Matters</span></div><div><br /></div><div>Degree of nodes:</div><div>In- Degree=&gt; Incoming edges</div><div>Out-degree =&gt; Outgoing edges</div><div><br /></div><div>We can represent Directed Graph using Adjacency list and matrix</div><div><br /></div><div><b>Directed Adjacency List</b></div><div>Only store the outgoing edges in the list</div><div><br /></div><div><b>Directed Adjacency Matrix</b></div><div>Only store if&nbsp; A[v][w] = 1 iff v is connected to w for outgoing edges</div><div>where A[row][col]</div><div><br /></div><div><b>Text Generation (Extra)</b></div><div>All nodes are Kgrams where kgrams is a contiguous sequence of k items</div><div>e.g syllables, letters ,words</div><div><br /></div><div>Edges = one kgram follows another</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div>