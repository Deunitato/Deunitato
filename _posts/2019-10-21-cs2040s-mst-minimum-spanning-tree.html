---
layout: post
title: 'CS2040s: MST (Minimum Spanning Tree)'
date: '2019-10-21T22:23:00.002-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-11-10T22:03:03.547-08:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-4377191629583935214
blogger_orig_url: https://nusmods.blogspot.com/2019/10/cs2040s-mst-minimum-spanning-tree.html
---

<h2>Minimum Spanning Tree</h2><div>A spanning tree is a acyclic subset of the edges that connects all nodes.<br />A minimum spanning tree is a spanning tree with minimum weight</div><div>The weight is the sum of all the weights of all the edges in the tree.</div><div><br /></div><div><span style="color: red;"><b>Can we use MST to find shortest paths? Nope</b></span></div><div>=&gt; Shortest path are not related to MST</div><div>The MST may not cover the edge of the shortest path.</div><div><br /></div><div>Application:</div><div>- Network designs</div><div>- Machine learning</div><div>- Data mining<br />- Electrical networks<br />- Ethernet autoconfig<br />- Road networks<br />- Bottleneck paths<br />- Telephone networks</div><div><br /></div><h3>Properties</h3><div>Assumptions:</div><div>- Edge weight are distinct</div><div>- Graph is connected and undirected</div><div><br /></div><div>1. No cycles</div><div>=&gt; If there are a cycle, removing the edge will reduce the weight<br /><br /></div><div>2. Cutting an MST will result in two MST<br /><br /></div><div>3. Cycle property<br />=&gt;For every cycle, the maximum edge is not in the MST<br />=&gt;For every cycle, Minimum weight (in cycle) is not always in the MST</div><div><br /></div><div>4. Cut property<br />=&gt;for every partition of nodes, the minimum weight edge across the cut must be in the MST</div><div>=&gt; A cut is the splitting of graph such that there is two disjoint subsets.<br /><br /></div><div><span style="color: red;"><b>For every vertex, the minimum&nbsp;outgoing edge is always part of the MST,&nbsp;</b></span><br /><span style="color: red;"><b>True</b></span></div><div>=&gt; Due to the cut property, if we cut every one node from the rest of the graph, the connected is always minimum weight edge</div><div><b><span style="color: red;">For every vertex the maximum outgoing edge could be part of the mst</span></b><br /><b><span style="color: red;">True</span></b></div><div>=&gt; A maximum edge for an node might be the minimum for another</div><div><br /></div><h3>PRIM's Algorithm</h3><div>Build spanning tree</div><div><br /></div><div>Basic Idea:</div><div>Imagine a set S of nodes where it contains some random nodes.</div><div>1. Init: S = {A}</div><div>2. Identify cut: {S, V-S}</div><div>3. Find min weight edge on cut by taking the shortest edge among all nodes in set S</div><div>4. Add new node connected to S</div><div>5. Repeat 2 onward<br /><span style="background-color: white;"><br /></span><span style="background-color: white; font-family: Whitney, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 16px; white-space: pre-wrap;">computeMST (G)   foreach v in V do     key[v] = ∞      pred[v] = -1   key[0] = 0   PQ = empty Priority Queue   foreach v in V do     insert (v, key[v]) into PQ    while PQ is not empty do     u = getMin(PQ)      foreach edge(u,v) in E do       if PQ contains v then         w = weight of edge (u,v)         if w &lt; key[v] then            pred[v] = u           key[v] = w           decreasePriority (PQ, v, w) end</span></div><div><br /></div><div>We can find the lightest edge with min weight on a cut using a PQ</div><div><b><span style="color: red;">Running time: O(ElogV)</span></b></div><div>=&gt; Each vertex is added/remove from PQ</div><div>=&gt; Using a PQ O(nlogn) -&gt; O(VlogV) where logV is the sort and V is the number of vertices went through</div><div>=&gt; Each edge -&gt; One decrease Key [Each time we are decreasing an edge]<br />=&gt; Look through all the edges for each node -&gt; O(E)</div><div>-&gt; O(ELogV)</div><div><br /></div><h2>Dijkstra vs Prim</h2><div>Both are greedy</div><div>- Efficient</div><div>- Optimum</div><div>- Both using a PQ</div><div>Dij =&gt; PQ for distance</div><div>Prim=&gt; PQ for Edge weight</div><div><br /></div><h2>Longest Path in a DAG</h2><div>Solution 1:</div><div>Shortest path relaxation:</div><div>Modify it, flip the sign in the condition for the relax function</div><div>Initialised everything to negative infinity</div><div><br /></div><div>Time: O(V+E)</div><div>Negate the edges.</div><div>Run the shortest path algorithm</div><div>This work because it is a DAG.</div><div><span style="color: red;"><b>THIS CANT WORK IF IT IS NOT A DAG</b></span></div><div>=&gt; Create negative cycles</div><div><br /></div><h2>Scheduling</h2><div><span class="fontstyle0">Given a set of tasks {A, B, C, D, E, F} and a set of constraints:</span><br /><span class="fontstyle2"> </span><span class="fontstyle0">A must be completed at least 10 mins before C</span><br /><span class="fontstyle2"> </span><span class="fontstyle0">D must be completed at most 20 minutes after E</span><br /><span class="fontstyle2"> </span><span class="fontstyle0">B must be done after F</span><span class="fontstyle0">Devise an efficient algorithm to tell if there is a feasible schedule.</span>  </div><div>When there are a series of relationship, it is a graph.</div><div>We must model this problem using graph and find how to solve it using the graph algo that we already know.</div><div><br /></div><div>Represent each node as a job, split that node into two nodes that signifies the start and end</div><div>e.g if job 0 takes 5 mins,</div><div>the s0 and e0 is two nodes connected by a weight 4 edge</div><div><br /></div><div>The e0 is then connected to the next node s1 connected using the weight edges required before 1 can be runned after completing 0</div><div><br /></div><div>We can have a dummy start node and dummy end node.</div><div><br /></div><div>We use to get the longest path.</div><div>=&gt; This is because we need to pass through everything</div><div>Using bellman ford we can do this.</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div>