---
layout: post
title: 'CS2100: Processor - Data Path'
date: '2019-09-11T02:09:00.000-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-09-24T21:29:48.918-07:00'
thumbnail: https://1.bp.blogspot.com/-J2p7BaxhAOg/XXpRc0cAnKI/AAAAAAAACFI/eoUHaq9hFikVklUtRsvtqO4Oryv3ImmRgCEwYBhgL/s72-c/3.PNG
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-4168383339231109363
blogger_orig_url: https://nusmods.blogspot.com/2019/09/cs2100-processor-data-path.html
---

<h2>Data Path</h2><h3>Datapath</h3><div>- Collection of Components that transform data (Arithmetic/logical/memory)<br /><br /></div><div><br /></div><h3>Control</h3><div>- Tells datapath,memory, I/O devices and tells them what to do base on instructions</div><br /><h3>Implementation</h3><h4>Instruction Execution Cycles</h4><div>- Fetch</div><div>Bring the instruction from memory.</div><div>We need the PC/ Storage (IR) to hold the address</div><div><br /></div><div>- Decode</div><div>We have a 32 bits 1 and 0s</div><div>Decode to find out what the instruction is.</div><div><br /></div><div>- Operand Fetch</div><div>Fetch the operands, take the values from the register</div><div><br /></div><div>- Execute</div><div>Do the operation</div><div><br /></div><div>- Result write</div><div>Store the result back to register or memory.</div><div><br /></div><h4>Clock Signal</h4><div>Uses a stable clock signal which are square wave</div><div>One cycle is define as one up and one down</div><div>Every cycle can be define on how long (0.5s)</div><div>In one second, how many cycle?</div><div><br /></div><div><u>The clock time is measured in seconds</u></div><div><br /></div><div>Clock rate = 1/ cycle time (sec) HZ</div><div>1 HZ = 1 cycle / second</div><h3>Mips instruction execution</h3><div><br /></div><div><br /></div><div><b>LoadWord</b></div><div><u>Fetch</u></div><div>lw $3, 20($1)</div><div><br /></div><div><u>Decode</u></div><div>Read $1 as op1</div><div>Use 20 as op2</div><div><br /></div><div><u>Execute</u></div><div>1. Memadd = OPr1 +opr2</div><div><br /></div><div><u>Memory Access</u></div><div>Use memadd to read from memory</div><div><br /></div><div><u>Result/Write</u></div><div>Memory data stored in $3</div><div><br /></div><div><b>BEQ</b></div><div>beq $1, $2, label</div><div><br /></div><div><div><u>Fetch</u></div><div>lw $3, 20($1)</div><div><br /></div><div><u>Decode</u></div><div>Read $1 as op1</div><div>Use $2 as op2</div><div><br /></div><div><u>Execute</u></div><div><div>1. Compare if op1 == op2</div><div>2. Calculate target</div><div><br /></div></div><div><u>Result/Write</u></div><div>If jump,&nbsp;</div></div><div>PC is target</div><div><br /></div><h3>Building a Mips Processor</h3><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-J2p7BaxhAOg/XXpRc0cAnKI/AAAAAAAACFI/eoUHaq9hFikVklUtRsvtqO4Oryv3ImmRgCEwYBhgL/s1600/3.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="681" data-original-width="1015" height="267" src="https://1.bp.blogspot.com/-J2p7BaxhAOg/XXpRc0cAnKI/AAAAAAAACFI/eoUHaq9hFikVklUtRsvtqO4Oryv3ImmRgCEwYBhgL/s400/3.PNG" width="400" /></a></div><div><br /></div><h3>Fetch Stage</h3><div>1. Use PC register to fetch instruction from memory</div><div>Pass the address to instruction memory.&nbsp;</div><div><br /></div><div>2. Increment PC by 4 bytes</div><div>Use a adder to add a hard-coded 4</div><div><br /></div><div>3. Pass added address to decoder</div><div><br /></div><div><b>Clocking</b></div><div>The clock signal (Rising edge) is use to determine when the address is calculated and pass.</div><div>During rising edge, the address is pass to adder and decoding stage.</div><div>The added address will only override the PC during the next clock edge</div><div><br /></div><div>The clock speed controls how fast instruction is being passed.</div><div><br /></div><div><h3><b>Decoding Stage (Op fetch)</b></h3></div><div><b><br /></b></div><div>1. Gather data from instruction field</div><div>2. Input from fetch stage</div><div>3. Pass to execution stage<br /><div>- Uses regWrite control signal to control when to write and read.</div></div><div><br /></div><div><br /></div><div>(Element) Register file:</div><div>A collection of 32 register (like an array)</div><div>Read at most 2 reg per instruction</div><div>Write at most 1 reg per instruction<br />Take 5 bits each.</div><div><br /></div><div><b>R Type Instruction</b><br />add $8 $9 $10</div><div>$10 -&gt; Read&nbsp;</div><div>$9 -&gt; Read</div><div>$8-&gt;Write</div><div><br /></div><div><b>I type instruction</b></div><div>addi $21, $22 , -50</div><div><br /></div><div>$22 -&gt; read</div><div>$21 -&gt; read (Mistake)</div><div>&nbsp; &nbsp; &nbsp; &nbsp;-&gt; Write (Use a multiplexer)</div><div><br /></div><div><u>Multiplexer</u></div><div>Selects one input from multiple input lines</div><div><br /></div><div>Using a control pin, control which input is allowed to go through</div><div>There is only one output.</div><div><br /></div><div><br /></div><div>R type instruction -&gt; read the 5 bits from RD for WR</div><div>I type instruction -&gt; do not read from imm for WR, but from RT<br />-&gt; the RR2 is redundant except branch instructions</div><div><br /></div><div>Use sign extend and a multiplexer to add the immediate to the solution.<br /><u>Sign extend is because immediate is 16 bits and multiplexer is expecting 32 bit.</u></div><div><br /></div><div><br /></div><div><h3><b>Execute Stage (ALU stage)</b></h3></div><div>Input: two 32- bit number</div><div>Control: 4 bit to decide the particular operation<br /><br /></div><div>e.g</div><div>if we want to do add, supply 0010</div><div><br /></div><div>Output:</div><div>- Result of operation</div><div>- Gives you separate one bit if results is equal to 0</div><div><br /></div><div><b>Branching</b></div><div><b><br /></b></div><div>1. Calculate if the branch is taken (Compare register)</div><div><br /></div><div>Take one register minus the other and check if its equal to 0 (Equal)</div><div>Since ALU returns a bit if result is 0, use that to check if its equal.</div><div><br /></div><div>2. Calculate where to jump to (Branch target address)</div><div>BTA = PC+4 + (Imm *4)</div><div>(1)Take the value from the immediate, left shift 2 times (*4)</div><div>(2)Using the previous fetch operation, use it to add to (1)</div><div>(3) Put in multiplexer (To check if added because we are sharing it with fetch sequence), put in fetch sequence. Iszero pin from ALU is use as a control for this multiplexer<br />(4) Mux checks if to go to PC+4 or BTA</div><div><br /></div><div><h3>Memory access stage&nbsp;</h3></div><div>Only the load and store instruction uses this.</div><div>Use the memory address calculated by ALU</div><div>All other instruction remain idle</div><div><br /></div><div>ALU: Computation result to be use as memory address</div><div>Result write: Result to be stored into memory</div><div><br /></div><div>ALU -&gt; Memory -&gt; Result store stage<br /><br />Input:<br />Memory address and data to be written for SW<br />Output:<br />Data read from memory for LW<br />Control:<br />Read and write control, only one instruction can be asserted at any point of time.<br />If I read, I can't write since I follow a byte.<br /><br /><br /><br /><h3>Result write stage</h3>LW $21, -50($22)<br />Alu result is pass into address<br /><br />Store word needs to supply content to be stored<br />SW $21, -50($22)<br />$22 is my source register , $21 is target register<br />Insert the read data 2 into the write data of the data memory.<br /><br /><b>Non-memory Instruction</b><br />Ensure that the result produce is correct.<br />Since the ALU is routed to address, we will route another path to MUX and use MemtoReg control to ensure that it works for non memory instruction<br /><br />1. Use the mux to check when it is a non memory instruction<br />2. The mux is then connect back to WD in the register. This will allow us to write data for the result.<br />3. Supply the correct control signal for each of these components.<br /><br /><br /><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><br /><a href="https://nusmods.blogspot.com/2019/09/cs2100-encoding-instruction-format.html">&lt;Prev</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="https://nusmods.blogspot.com/2019/09/cs2100-processor-control.html">Next&gt;</a>