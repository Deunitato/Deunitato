---
layout: post
title: 'CS2100: MIPs Memory and Branch'
date: '2019-09-04T02:21:00.004-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-09-23T22:45:52.689-07:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-1064499466268249090
blogger_orig_url: https://nusmods.blogspot.com/2019/09/cs2100-mips-memory-and-branch.html
---

<h2>MIPS: Memory and Branch</h2><h3>Memory</h3><h4><br />Organisation</h4><div>The main memory is a one dimension array with each location of the memory with an address where</div><div>k-bit address = 2^k locations</div><div><br /></div><div>e.g 4 bit&nbsp; = 16 location</div><div>0000 to 1111</div><div><br /></div><div>Each memory slot (Byte) is 8 bits<br /><br /></div><div><br /></div><div><br /></div><h4>Transfer unit</h4><div>Byte addressable</div><div>Word is 2^n bytes&nbsp;</div><div>However, machines can only be one of each addressable and not both</div><div><br /></div><div>The transfer unit is the size of the transferable item between the processor and the memory. Commonly, the size if the same as the register size, the integer size and instruction size in most architecture</div><div><br /></div><div><b>MIPs Memory instruction</b></div><div>It has 32 register which is 32 bit long (4 bytes)</div><div>Each word contains 32 bits</div><div>Memory address are 32 bits</div><div>There are 2^30 words because each word is 4 bytes thus there are 2^32 memory slots (Byte)</div><div><br /></div><div>Mip uses byte addressable so consecutive words differ by 4.</div><div><br /></div><h4>Load word</h4><div>Load word from memory</div><div><br /></div><div>lw $t10 , 4($s0)</div><div>4 is a offset,</div><div>this is saying that we take the memory stored in $s0 and add 4</div><div>let says $s0 contains 4000 memory</div><div>then the value at memory 4004 will be loaded in $t10</div><div><br /></div><h4>Store word</h4><div>sw $t0, 12($s0)</div><div><br /></div><div>Lets say $t0 contains 0xFFF, when run run this, the value is stored into $s0 + 12 memory</div><div>Offset is calculated by index * size of element</div><div><br /></div><div>The offsets represents the number of bytes offsetted</div><div><br /></div><div>There is load byte and store byte as well. We will retrieve and load one byte into the memory.</div><div><br /></div><div>char is use for Byte.</div><div><br /></div><h4>Word Alignment</h4><div>Word alignment is important because mips likes to read only multi - byte values from memory at an address that's a multiple of the data size</div><div>They begin at a byte address thats a multiple of the number of bytes in the word.</div><div>E.g&nbsp;</div><div>if a word consists of 4 bytes, it can start from 0 or 4 or 8.</div><div>Between the ranges are unaligned bytes</div><div><br /></div><div>Mips don't allow us to load/store any unaligned using lw/sw</div><div>It will throw hardware exception</div><div>We can use ulw and usw instead</div><div><br /></div><div>Register is 32 bits</div><h4>Byte vs Word</h4><div>Address of the next word is <u>not</u> the current word + 1<br />If we have a code:<br />int temp<br />temp = v[k]<br />v[k+1] = temp<br /><br />How do we get the address at v[k]?<br /><u>1. Find offset</u><br />k*itemsize<br />sll $2 , $5, 2<br />where 2 is actually 2^2<br />and we are multiplying it to k (the index) which is stored in $5<br />(Remember that sll is like multiplication)<br />Note: Address movement move in increments of 4 for integer, 8 for double, 1 character<br /><br />2. Add it to the the other register $4 where $4 point points to the address of the array<br />add $2, $4 , $2<br /><br />3. Load the value into temp which is $15<br />lw $15 , 0($2) //to get index k<br />lw $16, 4($2) // to get index k+1<br /><br />We are assuming that the value is an index<br /><br />We have to do the addition because the syntax dont allow us to load word without a constant</div><div><br /></div><div><h3>Branch</h3></div><div>We use branch to create loop so run a instruction multiple time.</div><div>We keep checking the condition and loop to a certain part of the code when its fufil</div><div><br /></div><h4>Conditional Branch</h4><div>beq $r1,$r2, L1</div><div>if $r1 equals to $r2, go to the label l1</div><div>if(a==b) goto l1</div><div><br /></div><div>bne $r1,$r2,l1</div><div>If its not equal</div><div><br /></div><h4>Unconditional Branching</h4><div>j l1</div><div>Just jump straight into the label</div><div><br /></div><div><span style="color: red;">Technique: Invert the condition for shorter code</span></div><div><br /></div><div>If- Else<br />e.g code<br />if(i==j){<br />&nbsp; &nbsp;f = g+ h<br />}<br />else{<br />&nbsp; &nbsp;f =&nbsp; g - h<br />}<br /><br />1.&nbsp; If i! = j, jump to else<br />2. continue<br /><br />1. If i==j, continue<br />2. Jump before reaching else<br /><br /><h4>Inequality</h4></div><div>There is no branch greater than or lesser than but we have slt (Set on less than) or slti</div><div>slt $t , $s1, $s2 //only compares less than</div><div>Slt will compare s1 and s2,&nbsp;</div><div>if s1&lt;s2, t will be 1</div><div>else 0</div><div><br /></div><div><b>BLT (Branch less than)</b><br />We want to check if s1&lt;s2<br /><br /></div><div>slt $t0 , $s1 , $s2&nbsp;</div><div>beq $zero, $t0 , false #if its !(s1&lt;s2), jump away<br /><br /><div><b>BLE (Branch lesser or Equal)</b></div><div>&nbsp;We want to check if s1&lt;= s2, we realised that s1&lt;=s2 is contrapositive to s2&gt;s1<br /><br /></div><div>slt $t0, $s2, $s1 #Returns 1 if s2&gt;s1</div><div>bne $zero, $t0, false #if returns s2&gt;s1, jump away<br /><br /></div><div><br /><b>BGT (Branch Greater than)</b><br />We want s1&gt;s2<br /><br />slt $t0, $s2, $1 #return 1 if s2&lt; s1<br />beq $zero, $t0, false #if !(s2 &lt; s1), jump away</div><br /></div><div><b>BGE (Branch Greater or Equal)</b><br />We want to check if s1&gt;= s2, we realised that it is a contrapositive to s1&lt;s2<br /><br />slt $t0, $s1, $s2 #return 1 if s1&lt; s2<br />bne $zero, $t0, false #if its s1&lt; s2 , jump away</div><div><br /></div><div><br /></div><div><br /></div><div><b><br /></b></div><h4><b>Array and Loop</b></h4><div>We want to access array in a loop in a sum</div><div>1.</div><div><br /><br /></div><div><a href="https://nusmods.blogspot.com/2019/09/cs2100-mips-memory-and-branch.html">&lt;Prev&nbsp;</a>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="https://nusmods.blogspot.com/2019/09/cs2100-encoding-instruction-format.html">Next&gt;</a></div><div><br /></div><div><br /></div>