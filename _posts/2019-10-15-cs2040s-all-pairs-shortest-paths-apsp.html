---
layout: post
title: 'CS2040s: All Pairs Shortest Paths (APSP) + Revision'
date: '2019-10-15T21:46:00.000-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-10-24T00:41:28.255-07:00'
thumbnail: https://1.bp.blogspot.com/-3wWlL48NdMU/XbFTl3oT6VI/AAAAAAAACPs/88jr8jYVh68qO57sCHoa0s7f86yr65skQCLcBGAsYHQ/s72-c/11.PNG
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-5538216008895229985
blogger_orig_url: https://nusmods.blogspot.com/2019/10/cs2040s-all-pairs-shortest-paths-apsp.html
---

<h2>Floyd Warshall</h2><div>Computes the distance between all Pairs of nodes</div><div>Key ideas: Shortest path have optimal substructure<br />All subpath of the shortest path is the shortest path</div><div><br /></div><h3>Dynamic Programming</h3><div>1. Figure out the subproblems</div><div>2. Relate the subproblem solutions</div><div>3. Recurse and memorise</div><div>4. Solve the original problem via subproblems</div><div><br /></div><h4>Optimal Sub-structure</h4><div>The optimal solution can be constructed from optimal solutions to smaller sub problems</div><div><br /></div><div><u>Greedy Structure&nbsp;</u></div><div>- Dijkstra's Algorithm</div><div>- Minimum spanning tree</div><div><br /></div><div><u>Divide and Conquer</u></div><div>- Merge sort</div><div><br /></div><h4>Overlapping subproblems</h4><div>The same smaller problem is used to solve multiple bigger different problems</div><div><br /></div><h3>The idea</h3><div>Let S[v,w,P] be the distance of the shortest path from v to w&nbsp;</div><div>that only uses intermediate nodes in the set P.</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-3wWlL48NdMU/XbFTl3oT6VI/AAAAAAAACPs/88jr8jYVh68qO57sCHoa0s7f86yr65skQCLcBGAsYHQ/s1600/11.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="257" data-original-width="693" height="147" src="https://1.bp.blogspot.com/-3wWlL48NdMU/XbFTl3oT6VI/AAAAAAAACPs/88jr8jYVh68qO57sCHoa0s7f86yr65skQCLcBGAsYHQ/s400/11.PNG" width="400" /></a></div><br /></div><div><br /></div><div>We do not have to use all the nodes in the set.&nbsp;</div><div>We will compute increasingly large sets.</div><div>This makes use of precalculation.</div><div><br /></div><div>We have two choices each time</div><div>To use the original path&nbsp;</div><div>To go through one more node</div><div><br /></div><div>Use the minimum of the two choice.</div><div><br /></div><div><br /></div><div>1. Initialised the table to all infinity</div><div>2. Fill adjacency matrix using edges</div><div>If there does not exist an edge, change to infinity</div><div>3. For every pair, look at the table an decide if</div><div>&nbsp;its better to go direct</div><div>&nbsp;or to pass through another node.</div><div>4. The Set p will only contain the nodes which must be included in graph</div><div><br /></div><div><br /></div><div><span class="fontstyle0">Function FloydWarshall(G)<br />S = Array of size |V|x|V| </span><span class="fontstyle0" style="color: green;">//memoization table S has |V| rows and |V| columns<br />// Initialize every pair of nodes O(V^2)</span><br /><span class="fontstyle0">for v = 0 to |V|-1<br />&nbsp; &nbsp;for w = 0 to |V|-1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;S[v,w] = E[v,w]</span><span class="fontstyle0" style="color: green;">// For sets P0, P1, P2, P3, …, for every pair (v,w)</span><br /><span class="fontstyle0" style="color: green;">//search for new paths O(V^3)</span><br /><span class="fontstyle0">for k = 0 to |V|-1<br />&nbsp; &nbsp; for v = 0 to |V|-1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for w = 0 to |V|-1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; S[v,w] = min(S[v,w], S[v,k]+S[k,w])<br />return S</span>&nbsp;&nbsp;</div><div><br /></div><div><span style="color: red;"><b>The time complexity is O(v^3)</b></span></div><div>How to store the path?</div><div>- For other, we store the parent but for floydd washall we can only sotre the parent for every possible</div><div>source,</div><div>We need to store into the 2D array, in each 2D array space, will show who is connected to the parent.</div><div><br /></div><div>We can use this method to precompute all the shortest path so that querying it will be easy.</div><div><br /></div><div><h2>Nearest Repeated Words Problem</h2></div><div>Imagine we are given a text:</div><div><br /></div><div><blockquote class="tr_bq"><span class="fontstyle0">“I am so happy we’re getting more problems to</span><span class="fontstyle0">solve. Nothing pleases me more than solving</span><span class="fontstyle0">problems. I love solving problems. Especially tough</span><span class="fontstyle0">problems. <u>The</u> harder <u>the</u> better! Give me more</span><span class="fontstyle0">problems!”</span>  </blockquote>We want to find the most efficient algo to find the distance between the closest repeated words.</div><div><br /></div><div>Easiest Method:</div><div>For every word, search through every word by looking through every other word and record repetition.</div><div>O(n^2)</div><div><br /></div><div>New Idea:</div><div>As we go through the text, hash the text and store the index where we last store it. Look up the word in the hashtable and find the difference in distance.</div><div>Update and move forward.&nbsp;</div><div><br /></div><div>Assume hashtable is O(1)</div><div>Look up is O(n)</div><div><br /></div><div><br /></div><h2>Graphs</h2><div><br /></div><div><br /></div>