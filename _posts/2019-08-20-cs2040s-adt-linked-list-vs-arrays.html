---
layout: post
title: 'CS2040S: ADT List, stack and queue'
date: '2019-08-20T19:16:00.003-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-09-03T01:42:06.432-07:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-3931289454857267278
blogger_orig_url: https://nusmods.blogspot.com/2019/08/cs2040s-adt-linked-list-vs-arrays.html
---

<h3>Linked List</h3><div>A linear data structure that uses pointers to point to the other nodes. Elements are not stored in contiguous memory.</div><div><br /></div><h3>Abstract Data Type</h3><div>A type or class for objects whose behavior is defined by a set of values and a set of operations.</div><div><br /></div><h3>ADT and Data structures, their relationship</h3><div>ADT is just a concept that implements some data structures.&nbsp;</div><div>E.g Arraylist and Queues are just adt concepts that makes used of arrays or linked list.</div><div><br /></div><div>Data structures on the other hand, are concrete memory spaces.</div><h3>Linked List Vs Arrays</h3><br />Based on Visual Go, we can see the way that linked list work in comparison to compact arrays:<br /><br />Get:<br />&nbsp; Arrays: O(1)<br />&nbsp; Linked List: O(n) , Iterate the entire list to get<br /><br />Search:<br />&nbsp; Arrays: O(n), To search for value, have to iterate the entire list<br />&nbsp; Linked List: O(n), Iterate entire<br /><br />Insert:<br />&nbsp; Arrays: O(n), Have to create a new array<br />&nbsp; Linked List: O(n), Iterate the entire till reach the position<br /><br />Remove:<br />&nbsp; Arrays: O(n), Have to create a new arrays<br />&nbsp; Linked List: O(n), Have to iterate the entire linked list<br /><br />Remove Node:<br />Array: No nodes<br />Linked List: O(1)<br />//We don't need to know the index<br /><br /><b><i><span style="color: red;">Detecting palindrome using a linked list will fastest up to n time</span></i></b><br /><br /><br />1. Compare each first letter with the last one<br />-&gt; n*n<br />O(n^2)<br /><br /><br />2. Use array as an buffer:<br />-&gt; Iterate the list (n)<br />-&gt; Using index, iterate twice (2n)<br />-&gt; 2n +&nbsp; n = 3n (n)<br />O(n) but cost S(n)<br /><br /><h4>Using Recursion to solve palindromes.</h4><div>e.g (Head)L-&gt;U-&gt;K-&gt;E</div><div>1. Imagine that there is a function that is already swap the last few letters</div><div>we will get:</div><div>E-&gt;K-&gt;U&lt;-L(head)-&gt;U<br /><br /></div><div>2. After swapping, we realised that there are problems</div><div>- U is pointing wrong</div><div>- Head is still at L<br /><br /></div><div>3. We can change by doing Head.next.next = head</div><div>this will give us</div><div>E-&gt;K-&gt;U-&gt;L(Head)-&gt;U<br /><br /></div><div>4. We then do Head.next = null</div><div>To set L to not point anything</div><div>E-&gt;K-&gt;U-&gt;L(head)<br /><br /></div><div>5. Finally we make sure that E is head</div><div>head = temp;</div><div>(Head) E-&gt;K-&gt;U-&gt;L<br /><br /><div><h4>Palindromes: What if we Adapt the data structure into a doubly link list?</h4></div><div>Will it save space?</div><div><span style="color: red;"><b><i>It depends</i></b></span></div><div>We don't know if the pointer will use up memory space.</div><div><br /></div><h4>Palindromes: Using stacks</h4><div>1. Get midpoint of an list, O(n)</div><div>2. Run through first half of linked list and push each element on stack O(n/2) =&gt; O(n)</div><div>3. Iterate the remaining half and check each of the pop element of the stack O(n)</div><div><br /></div><div>O(n) and S(n/2)</div><div><br /></div><div><h4>Palindromes: Reversing the second half</h4></div></div><div>1. Get midpoint of an list O(n)</div><div>2. Reverse the second half O(n)</div><div>3. Iterate and compare</div><div><br /></div><div>O(n) and S(1)</div><h3>Best time strategy</h3><div>1. Easiest way to solve the problem</div><div>2. Focus on correctness then efficiency</div><div>3. Ask</div><div>- What operations are needed</div><div>- What data structures do these operation work well</div><div>- Is data random or sorted</div><div>4. Improve</div><div>- how to make faster?</div><div>- Assumptions made</div><div>- Divide and conquer?</div><div><br /></div><div><h3>Implement queue using other ADT</h3></div><div><b>Array:</b></div><div><b><br /></b></div><div>Enqueue(x): O(1)</div><div>We just insert to the last pointer</div><div><br /></div><div>Peek(): O(1)</div><div>We just access the first variable</div><div><br /></div><div>Dequeue(): O(n)</div><div>We need to remove and shift all the variables up by one index</div><div><br /></div><div>Issues: Fixed sized</div><div><br /></div><div><b>Singly Linked List</b></div><div><b><br /></b></div><div><div>Enqueue(x): O(1)</div><div>Create a new node and put it at the back, no need to iterate</div><div><br /></div><div>Peek(): O(1)</div><div>Check the first object</div><div><br /></div><div>Dequeue(): O(1)</div><div>Remove the first object, other variables automatically become new head</div><div><br /></div><div>Issues: Variable sized</div></div><div><br /></div><div><b><span style="color: red;"><i>We should use Linked List to implement our Queue adt</i></span></b></div><div><br /></div><h3>Dynamic arrays</h3><div>Arrays that can grow, but in actual fact, we are just increasing the size of the array by generating a new array every time the end is reached.</div><div><br /><h3>Using other ADT to implement stacks</h3><h4><br />Dynamic Array</h4></div><div>Push: O(1) (Amortized)</div><div>Peek: O(1)</div><div>Pop: O(1)</div><div>Push to the back</div><div><br /><h4>Singly Linked List</h4></div><div><div>Push: O(1)&nbsp;</div><div>Peek: O(1)</div><div>Pop: O(1)</div><div>Push to the front<br /><br /><span style="color: red;"><b><i>We can use both methods to implement the stack</i></b></span></div></div><h3>Can we implement a queue using stacks?</h3><div><b><i><span style="color: red;">Yes, use two stacks</span></i></b><br /><b><i><span style="color: red;"><br /></span></i></b></div><div><div>Enqueue: Add to the top of stack A<br /><br /></div><div>Dequeue:<br />Pop all elem from stack a to be</div><div>Remove the last element</div><div>pop of all element from stack B to stack A (Not needed, just alternate)</div><div><br /></div><div>Computational Cost</div><div>Constant time for enqueue</div><div>2n Operations for dequeue<br /><br /></div></div><br /><br /><a href="https://nusmods.blogspot.com/2019/08/cs2040s-binary-search-and-merge-sort.html">&lt;Prev</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="https://nusmods.blogspot.com/2019/08/cs2040s-algo-analysis.html" target="">Next&gt;</a>