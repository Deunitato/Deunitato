---
layout: post
title: 'CS2040s: Binary search and Merge sort'
date: '2019-08-26T22:22:00.002-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-09-03T03:38:20.614-07:00'
thumbnail: https://1.bp.blogspot.com/-GFeIBMqYrvo/XWS97MAHllI/AAAAAAAACDM/O9eqyjycJVY0P2flvvGUO3tB8ukIOvjHwCLcBGAs/s72-c/2.PNG
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-8083780803817811254
blogger_orig_url: https://nusmods.blogspot.com/2019/08/cs2040s-binary-search-and-merge-sort.html
---

<h3>Problem: Find customers spending between $a and $b where b&gt;a</h3><div><b><i><span style="color: red;">How fast can we find customer who spend $a in an unsorted array?</span></i></b></div><div><b><i><span style="color: red;">-&gt; o(n) [Linear search]</span></i></b></div><div>We are not given any information so we have to look one by one.</div><div><br /></div><div>BUT!!! Our array is sorted..</div><div><br /></div><div>Strategy: Exploiting structure</div><div><br /></div><div>If our Array is already sorted, and we want a value that's less than e.g 11,</div><div>we should search the left of 11.</div><div><br /></div><h3>Binary search</h3><div><span class="fontstyle0">function </span><span class="fontstyle0" style="color: #3e8853;">binarySearch </span><span class="fontstyle0">(</span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #0e5772;">key, n</span><span class="fontstyle0">)</span><span class="fontstyle0" style="color: #0e5772;">&nbsp;</span><br /><span class="fontstyle0" style="color: #0e5772;">&nbsp;low </span><span class="fontstyle0">= 0</span><span class="fontstyle0" style="color: #0e5772;">&nbsp; high </span><span class="fontstyle0">= </span><span class="fontstyle0" style="color: #0e5772;">n - 1</span><span class="fontstyle0">&nbsp;&nbsp;</span><br /><span class="fontstyle0">while </span><span class="fontstyle0" style="color: #0e5772;">low </span><span class="fontstyle0">&lt;= </span><span class="fontstyle0" style="color: #0e5772;">high<br />&nbsp; &nbsp; mid </span><span class="fontstyle0">= (</span><span class="fontstyle0" style="color: #0e5772;">low </span><span class="fontstyle0">+ </span><span class="fontstyle0" style="color: #0e5772;">high </span><span class="fontstyle0">)/2<br />&nbsp; &nbsp; if </span><span class="fontstyle0" style="color: #0e5772;">key </span><span class="fontstyle0">&lt; </span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">mid</span><span class="fontstyle0">] then</span><br /><span class="fontstyle0">&nbsp;</span><span class="fontstyle0" style="color: #0e5772;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;high </span><span class="fontstyle0">= </span><span class="fontstyle0" style="color: #0e5772;">mid - 1 </span><span class="fontstyle0"><span style="color: blue;">//the key is below the mid, so our high is now mid</span></span><span class="fontstyle0">&nbsp; &nbsp; &nbsp;</span><br /><span class="fontstyle0">&nbsp; &nbsp; else if </span><span class="fontstyle0" style="color: #0e5772;">key </span><span class="fontstyle0">&gt; </span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">mid</span><span class="fontstyle0">]</span><span class="fontstyle0" style="color: #0e5772;">&nbsp;</span><br /><span class="fontstyle0" style="color: #0e5772;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;low </span><span class="fontstyle0">= </span><span class="fontstyle0" style="color: #0e5772;">mid + 1&nbsp; &nbsp;</span><span class="fontstyle0"><span style="color: blue;">// the key is above the mid, so low is now mid</span></span><span class="fontstyle0">&nbsp;</span><br /><span class="fontstyle0">&nbsp; &nbsp; &nbsp;else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return </span><span class="fontstyle0" style="color: #0e5772;">mid&nbsp; &nbsp;</span><span class="fontstyle0"><span style="color: blue;">//we found it!　やたあああああ</span></span><br /><span class="fontstyle0">return not_found</span>&nbsp; <span style="color: blue;">//not found 残影　:(</span></div><div><br /></div><div>Key is the number we want</div><div><br /></div><div><br /></div><div>Checking algorithm correctness:</div><h4>Precondition:</h4><div><div>Precondition: Condition that is true before some set of operation</div><div>(Like loops or function)</div></div><div><br /></div><div>1. Sorted</div><div>2. A is of size n</div><div><br /></div><h4>Postconditions:</h4><div><div>Postcondition: Condition that is true after some set of operation</div><div>(like if else)</div><div><br /></div></div><div>1. A[mid] = key</div><div>2. or key is not found</div><h4>Invariants</h4><div>Its a condition that is <span style="background-color: yellow;">true </span>during some execution of a program or a set of operation</div><div><br /></div><div>Loop Invariants:</div><div>A condition that is true before and after each iteration of a loop</div><div><br /></div><div><br /></div><div>1. The key must be between low and high if the key is in the array</div><div>2.&nbsp; Work through the loop and consider each case</div><div><br /><h4>Loop Termination:</h4></div><div>A[mid] = key</div><div>or high &lt; low (not_Found)</div><div>This is the desired results</div><div><br /></div><div>HOWEVER, THE BINARY SEARCH IS NOT EXACTLY CORRECT</div><div><br /></div><div><b>Time complexity:</b><br /><b><i><span style="color: red;">&nbsp;O(logn)</span></i></b></div><div><br /></div><div>Each iteration, we divide the search by 2</div><div>Iteration k: n/(2^k) = 1<br />1 is the base element</div><div>k = logn</div><div><br /></div><div><b>Space Complexity:</b></div><div><span style="color: red;"><b><i>O(1) - We are not creating new memory, its bounded by constant</i></b></span></div><div><span style="color: red;"><br /></span><br /></div><h3>Divide and Conquer</h3><div>1. Split into subproblems</div><div>2. Solve recursively</div><div>3. Combine solutions for each subproblem to produce a solution to original problem</div><div><br /></div><div><i><span class="fontstyle0">start = findIndex(customers, $a)<br />end = findIndex(customers, $b)<br />for (int i=start; i&lt;=end; i++)<br />println(customers[i])</span>&nbsp;</i></div><div><br /></div><div>&nbsp;<span style="color: red;">This is n time complex because the for loop is n time complexity</span></div><div><span style="color: red;"><br /></span><h4><span style="color: red;">Duplicates</span></h4></div><div>There is something wrong with the algorithm.</div><div>-&gt; IF there are people with the same amount, we will miss them out</div><div>Instead we need to find the first index rather than find index<br /><br /></div><div><br /></div><h3>Binary search to find First index</h3><div>1. Find the index using binary search</div><div>2. If find the first number, use&nbsp; binary search to decrease the high pointer till the next number</div><div>in the left is another number (Find last number)<br /><br /><span class="fontstyle0">function </span><span class="fontstyle0" style="color: #3e8853;">binarySearchFirst </span><span class="fontstyle0">(</span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #0e5772;">key, n</span><span class="fontstyle0">)</span><span class="fontstyle0" style="color: #0e5772;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low </span><span class="fontstyle0">= 0</span><span class="fontstyle0" style="color: #0e5772;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high </span><span class="fontstyle0">= </span><span class="fontstyle0" style="color: #0e5772;">n – 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = not_found</span><span class="fontstyle0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while </span><span class="fontstyle0" style="color: #0e5772;">low </span><span class="fontstyle0">&lt;= </span><span class="fontstyle0" style="color: #0e5772;">high<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mid </span><span class="fontstyle0">= (</span><span class="fontstyle0" style="color: #0e5772;">low </span><span class="fontstyle0">+ </span><span class="fontstyle0" style="color: #0e5772;">high</span><span class="fontstyle0">)/2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if </span><span class="fontstyle0" style="color: #0e5772;">key </span><span class="fontstyle0">&lt; </span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">mid</span><span class="fontstyle0">] then</span><span class="fontstyle0" style="color: #0e5772;"><span style="color: black;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>high </span><span class="fontstyle0">= </span><span class="fontstyle0" style="color: #0e5772;">mid - 1</span><span class="fontstyle0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if </span><span class="fontstyle0" style="color: #0e5772;">key </span><span class="fontstyle0">== </span><span class="fontstyle0" style="color: #0e5772;">A</span><span class="fontstyle0">[</span><span class="fontstyle0" style="color: #0e5772;">mid</span><span class="fontstyle0">] then</span><span class="fontstyle0" style="color: #0e5772;"><span style="color: black;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>result = mid<br /><span style="color: black;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>high = mid - 1</span><span class="fontstyle0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else</span><span class="fontstyle0" style="color: #0e5772;"><span style="color: black;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>low </span><span class="fontstyle0">= </span><span class="fontstyle0" style="color: #0e5772;">mid + 1</span><span class="fontstyle0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return </span><span class="fontstyle0" style="color: #0e5772;">result</span><br /><span class="fontstyle0" style="color: #0e5772;"><br /></span><span class="fontstyle2">What is the worst case<br />computational complexity of<br />binarySearchFirst()?<br />A.&nbsp;</span><span class="fontstyle3">  </span><br /><br /></div><div><span style="color: red;">Time complexity of binary search first: O(logn)</span><br />Still binary searching for the first duplicate<br /><br /><h4>Precondition</h4>- A is of size n<br />- A is sorted<br /><br /><h4>Post Condition</h4>- A[mid] = key<br />- A[mid] is the first occurrence of key<br /><br /><br /></div><div>We can find the last index in a similar way..</div><div><br /></div><div>However, there's a bug in the binary search</div><div>(mid = (low +&nbsp; high) /2)</div><div>This will overflow if low add high overflow</div><div></div><h3>Merge sort</h3><div><span class="fontstyle0">function </span><span class="fontstyle0" style="color: #3e8853;">mergeSort</span><span class="fontstyle0">(</span><span class="fontstyle0" style="color: #0e5772;">A, low, high</span><span class="fontstyle0">)<br />&nbsp; if </span><span class="fontstyle0" style="color: #335b74;">low </span><span class="fontstyle0">&lt; </span><span class="fontstyle0" style="color: #335b74;">high<br />&nbsp; mid </span><span class="fontstyle0">= (</span><span class="fontstyle0" style="color: #335b74;">high </span><span class="fontstyle0">+ </span><span class="fontstyle0" style="color: #335b74;">low</span><span class="fontstyle0">)/2<br />&nbsp; mergeSort(</span><span class="fontstyle0" style="color: #335b74;">A</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #335b74;">low</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #335b74;">mid</span><span class="fontstyle0">)<br />&nbsp; mergeSort(</span><span class="fontstyle0" style="color: #335b74;">A</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #335b74;">mid</span><span class="fontstyle0">+1, </span><span class="fontstyle0" style="color: #335b74;">high</span><span class="fontstyle0">)<br />&nbsp; merge(</span><span class="fontstyle0" style="color: #335b74;">A</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #335b74;">low</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #335b74;">mid</span><span class="fontstyle0">, </span><span class="fontstyle0" style="color: #335b74;">high</span><span class="fontstyle0">)</span></div><div><br /></div><div><br /></div><div><span class="fontstyle0">function merge(int low, int mid, int high)<br /><span style="color: #b45f06;">&nbsp;<span style="color: lime;"> for i = low to high<br />&nbsp; buffer[i] = A[i]<br />&nbsp; &nbsp;i = low<br />&nbsp; &nbsp;j = mid + 1<br />&nbsp; &nbsp;k = low</span></span></span><br /><span class="fontstyle0"><span style="color: #b45f06;">//Initialise</span></span><br /><span class="fontstyle0"><span style="color: #b45f06;"><br /></span><span style="color: #660000;">while i &lt;= middle and j &lt;= high<br />&nbsp; &nbsp; if buffer[i] &lt;= buffer[j]<br />&nbsp; &nbsp; &nbsp; &nbsp;A[k] = buffer[i]<br />&nbsp; &nbsp; &nbsp; &nbsp; i++<br />&nbsp; &nbsp; &nbsp;else<br />&nbsp; &nbsp; &nbsp;A[k] = buffer[j]<br />&nbsp; &nbsp; &nbsp; &nbsp; j++<br />&nbsp; &nbsp; &nbsp; &nbsp; k++</span></span><br /><span class="fontstyle0"><span style="color: #660000;">// Iterate through helper.</span></span><br /><span class="fontstyle0"><span style="color: #660000;">// At each iteration, compare elements in both segments and copy smaller element over</span></span><br /><span class="fontstyle0"><span style="color: #660000;"><br /></span><span style="color: blue;">&nbsp;while i &lt;= middle<br />&nbsp; &nbsp;A[k] = buffer[i]<br />&nbsp; &nbsp; k++<br />&nbsp; &nbsp; i++</span></span><span class="fontstyle2" style="color: blue;">&nbsp;</span><br /><span class="fontstyle2" style="color: blue;">//Copy remaining items from left segement</span><br /><span class="fontstyle2" style="color: blue;">&nbsp;&nbsp;</span><br /><span class="fontstyle2">L is buffer[low,...,mid]</span><br /><span class="fontstyle2">R is buffer[mid+1,...,high]</span><br />The array A contains sorted elements of L and R<br /><span class="fontstyle2" style="color: blue;"><br /></span>The loop invariant:</div><div>The pointer must be between 0 and mid</div><div>and another pointer between mid and high&nbsp;</div><div><br /></div><div><span style="color: red;">Time complexity: O(n) //from while</span></div><div><span style="color: red;"><br /></span></div><div><span style="color: red;">Total Time Complexity: O(nlogn)</span></div><div><span style="color: red;">Merge sort is logn</span></div><div><span style="color: red;">Merge is n</span></div><div><span style="color: red;"><br /></span></div><div><span style="color: red;"><br /></span></div><div>Mergesort:</div><div>Recurse Downwards</div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-GFeIBMqYrvo/XWS97MAHllI/AAAAAAAACDM/O9eqyjycJVY0P2flvvGUO3tB8ukIOvjHwCLcBGAs/s1600/2.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="378" data-original-width="877" height="275" src="https://1.bp.blogspot.com/-GFeIBMqYrvo/XWS97MAHllI/AAAAAAAACDM/O9eqyjycJVY0P2flvvGUO3tB8ukIOvjHwCLcBGAs/s640/2.PNG" width="640" /></a></div><div><span style="color: red;">n=2^h</span></div><div><span style="color: red;"><br /></span></div><div>O(nlogn) is the fastest for comparison based sort</div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-GB0k-a7Jq-o/XWS9Je7bFqI/AAAAAAAACDE/dH4P4baUqo8sGgqK5FO4HZq61C9Zf8wfgCLcBGAs/s1600/1.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="432" data-original-width="663" height="417" src="https://1.bp.blogspot.com/-GB0k-a7Jq-o/XWS9Je7bFqI/AAAAAAAACDE/dH4P4baUqo8sGgqK5FO4HZq61C9Zf8wfgCLcBGAs/s640/1.PNG" width="640" /></a></div><div><br /><br /><br /><br /><a href="https://nusmods.blogspot.com/2019/08/cs2040s-algo-analysis.html">&lt;Prev</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="https://nusmods.blogspot.com/2019/08/cs2040s-lecture-5-quicksort.html">Next&gt;</a></div>