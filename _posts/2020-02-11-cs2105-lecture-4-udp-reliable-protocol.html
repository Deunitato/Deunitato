---
layout: post
title: 'CS2105: Lecture 4 - UDP, Reliable Protocol'
date: '2020-02-11T19:49:00.000-08:00'
author: Charlotte Deunitato
tags: 
modified_time: '2020-03-07T23:35:11.457-08:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-7119015015786667965
blogger_orig_url: https://nusmods.blogspot.com/2020/02/cs2105-lecture-4-udp-reliable-protocol.html
---

<h2>Transport Layer Services</h2><h3>Transport services and protocols</h3><div>- Provide logical communication between app processes running different hosts.</div><div>They communicate though sockets</div><div><br /></div><div>- Run in end system</div><div>Send sides: Breaks app messages into segment passes to network</div><div>RCV side: Reassembles segments into messages passes to app layer.</div><div><br /></div><div><i>When the socket is called, the upper layer might be http that attach a large files, the transport layer will chop it up and assemble it (segment) at the recieving side</i></div><div><i>From the application pov, it makes it feels like they are directly connected to the other host.</i></div><div><i><br /></i></div><h3>Transport vs Network</h3><div>Transport: Logical Communication between PROCESSES</div><div>- Replies on, enhance network layer services</div><div><br /></div><div>Network Layer: Logical communication between HOSTS</div><div>- Unreliable "best effort"</div><div><i>This services is generically unreliable, there is no guarantee&nbsp;of the&nbsp;performance</i></div><div><i><br /></i></div><div>Difference between host and processes</div><div><i>One host can have multiple processes.</i></div><div><br /></div><h2>Connectionless Transport: UDP</h2><h3>UDP: User Datagram Protocol</h3><div>UDP adds very little service on top of IP</div><div>1. Connectionless multiplexing/ de-multiplexing</div><div><i>Connectionless means no handshaking before connecting</i></div><div><i>Process to process communcation</i></div><div><i>We use the port number to defereitaite the different types of processes</i></div><div>2. Checksum</div><div>IP is the network layer.</div><div><br /></div><div>UDP transmission is UNreliable</div><div>- Often for streaming multimedia</div><div><br /></div><div>To achieve reliable, need something on top of UDP</div><div>= Use TCP at transport layer</div><div>- Application implements error detection and recovery mechanisms</div><div><br /></div><h3>Connectionless De-Multiplexing</h3><div><u>&lt;Insert slide 8&gt;</u></div><div><u><br /></u></div><div>The operating system will gen the port number</div><div><i>But for server side, they must generate itself and let it known to the hosts</i></div><div><i>The server process will specify the ip address of itself such that when the server recieve the packet it will correctly be demultiplex.</i></div><div>The key point: For all the segments, as long as they are specifying the same destination, all packets well be delievered to the same socket.</div><div>This is not the same for TCP as for each TCP get a indiviudaul socket for individual client.</div><div><br /></div><div><b>Encapsulation</b></div><div>The transport layer will&nbsp;</div><div>- chop packet if its too large</div><div>- Addes a packet header</div><div>- This is when it is called a segment</div><div><br /></div><h3>UDP: Segment Header</h3><div>&lt;<u>Insert slide 10&gt;</u></div><div>Length: Entire of UDP packet in bytes</div><div>Checksum: Check if there is bit errors</div><div>Remaining: application data</div><div><br /></div><div>Reason why some app use UDP</div><div>- No need handshake</div><div>- Simple: No guarantee of anything</div><div>- Packet header is shorter than TCP</div><div><br /></div><h3>UDP: CheckSum</h3><div>Goal: Detect errors in recieved segments (ie flipped bits)</div><div>Computation:</div><div>1. Treat UDP segment as a sequence of 16 bit integer</div><div>2. Apply Binary addition on every 16 bit integer&nbsp;</div><div>(Check sum is init as 0)</div><div><i>Try to add all 16 bits together</i></div><div>3. Carry over sfb if any</div><div>4. Comput 1's complement to get UDP checksum</div><div><i><u>&lt;Insert slide 12 table&gt;</u></i></div><div><i><u><br /></u></i></div><div><i><u><br /></u></i></div><div><i><u><br /></u></i></div><div><b>How to use the checksum?</b><br />Use the binary summation of all the 16 bit integers,</div><div>You would expect to get the same final sum and when we add same check sum to see if we get the same sum.&nbsp;</div><div>If there is a bit flips, the sum will not be same.</div><div><br /></div><h2>Principles of reliable data transfer</h2><div>How can we provide a reliable data transfer at transport layer?</div><div><u>&lt;Insert 14&gt;</u></div><div><u><br /></u></div><div>If its realible , it means that all data be send in order and no data is lost.</div><div><i>We have a assumption that the layer below transport layer is relible and has already set up the connection (But in fact it isnt)</i></div><div><i><br /></i></div><h3>Reliable data transfer (RDT): Interface</h3><div>&lt;<u>Insert 17</u>&gt;</div><div><br /></div><div>udt_send() is called by rdt to transfer packet over unreliable channel to receiver</div><div>udt_rcv() is called when packet arrives on rcv side of channel</div><div>&lt;MiSssing info&gt;</div><div><br /></div><div><b>Getting started</b></div><div>- Consider only unidirectional data transfer</div><div>- Control info flow on both direction</div><div>- Use FSM (finite state machines) to specify sender and reciever</div><div><i>FSM diagrams shows the states which are defined as circle with arrows.&nbsp;</i></div><div><i>Any entity can be in any of the states at a point</i></div><div><i>During transition, we have a label (Denoted as an arrow) to show the state transition</i></div><div><i>This is specify by the corresponding actions</i></div><div><br /></div><h3>RDT1.0: Reliable transfer over reliable channel</h3><div><u>&lt;Insert slide 19&gt;</u></div><div><u><br /></u></div><div>- Underlying channel perfectly reliable</div><div>- Separate FSM for sender and receiver</div><div><i>Each side only have one transition to itself.</i></div><div><i>What the sender needs to do is to wait for call from above (the need to transfer data from upper application layer) When that happens,there is a transition where the sender use the data to make a packet. That includes checksum, packet header etc</i></div><div><i><br /></i></div><div><i>Receiver: When it is waiting, a transition happen when the lower side deliever a packet to the reicever. The layer will extract the actual application layer data from the packet and deliever the data upwards</i></div><div><i><br /></i></div><h3>RDT2.0: Channel with Bit Errors</h3><div><span style="font-weight: normal;">- Some of the bits get flipped</span></div><div><span style="font-weight: normal;">- Packets might be loss/dropped</span></div><div><span style="font-weight: normal;"><br /></span></div><div><span style="font-weight: normal;">How can we handle these bit error?</span></div><div>We can use checksum (receiver) to check if bit flipped happen?</div><div><span style="font-weight: normal;">How are we going to change to get the right packet.</span></div><div><span style="font-weight: normal;"><br /></span></div><div><b>We can give a feedback</b></div><div>- Acknowledge (ACKs) : Positive feedback, tells sender that received is OK</div><div>- Negative Acknowledgements (NAKs): receiver explicitly tells sender that pkt had errors</div><div><br /></div><div><b>Summary Mechanisms:</b></div><div>- Error detection</div><div>- Feedback</div><div><br /></div><div><b>RDT2.0 in actions</b></div><div><u>&lt;Insert 22&gt;</u></div><div><u><br /></u></div><div><u>Correct</u></div><div>1. sender send packet1</div><div>2. reciever send back a ACK</div><div>3 sender send next packet</div><div><br /></div><div><u>Corrupted</u></div><div>1. Sender send packet1</div><div>2. Receiver send back NAK</div><div>3. Sender resends the packet1</div><div><br /></div><div>Sender sends one packet at a time then waits for receiver to response</div><div><br /></div><h3>RDT2.0: FSM specification</h3><div><u>Insert 23&gt;</u></div><div><u><br /></u></div><div>The differences are shown in red</div><div><br /></div><div>Differences:</div><div><b>Sender</b></div><div>Have two states</div><div>It has to wait for the feedback from the reciever before sending the next packet</div><div>Checksum has to be place together to the packet when send to the reciever</div><div><br /></div><div>In waiting states, it depends on what kind of response from reciever</div><div>- ACKs : Next packet&nbsp;</div><div>- NAK: Resent the previous packet</div><div><br /></div><div><br /></div><div><b>Reciever</b></div><div><b><br /></b></div><div>When it receive, it checks if packet is corrupted.</div><div>If it isn't: Sends a ACK to sender, It extracts and send data to up to the upper layer</div><div><b><br /></b></div><div><b>But RDT2 has a fatal flaw!</b></div><div>What if the ACK and NAK is corrupted??</div><div><i>If we try to use feedback, there is always a chance that it will send a corrupted packet. It is like an infinite loop</i></div><div><i><br /></i></div><div>Corrupted ACK: We just have to make sure that the receiver do not detect the duplicate pkt</div><div><br /></div><div><b>To handle duplicates:</b></div><div>Attache a sequence number to each packet</div><div>Receiver discard duplicates</div><div><br /></div><h3>RTD2.1 In aCTION</h3><div>If a NAK/AK is corrupted, just resend</div><div><br /></div><div>&lt;<u>Insert 27&gt;</u></div><div>The number of states for 2.1 is double. But it is symmetric as now we need to attach a sequence number to the packet.</div><div>It needs to wait.&nbsp;</div><div>IT only need to differentiate to know if its is the previous or the next</div><div>2 states for sequence 0</div><div>2 states for sequence 1</div><div>This is to differentiate the packets</div><div><br /></div><div>Waiting states:</div><div>Recieve no corrupted: ACK, doesnt do anything, move to next stage to get packet</div><div>Recieve corrupted: Resend packet</div><div>Receive feedback is NAK: Resend packet</div><div><br /></div><div>The difference is so that the feedback also has an checksum.</div><div><br /></div><div><br /></div><div><b>Reciever</b></div><div>If the reciever is sequence 0, it is expecting a packet with sequence 0.&nbsp;</div><div>The reciever can use checksum to check if its corrupted and if it has the correct number of 0s</div><div>If it is correct, it will send an acknodlege witht eh chechksum and send the data to upper layer</div><div><br /></div><div>Feedback:<br />11. Recieve packet is not corrupt: Different sequence number,</div><div>This can happen when the reciever reciveve a duplicate pakcet</div><div>It sends an ack back to sender thats all</div><div><br /></div><div>Corrupted: Sends back Nak back with checksum</div><div><br /></div><div><br /></div><h3>RDT2.2: A NAk free Protocol</h3><div>Alternaive to 2.1</div><div>By specifying the sequence numbers we ack.</div><div><br /></div><div><b>How to ignore Nak?</b></div><div><b>Sender:</b></div><div>We will try to specify the sequence number in the ack.</div><div>e.g ACK0</div><div>This implies that we are expecting the next packet to be 1</div><div>If its corrupted, it will just resend the previous ACK0</div><div><br /></div><div><b>FSD</b></div><div><b><u>Insert slide 31</u></b></div><div><b><u><br /></u></b></div><div>Receiver:</div><div>Not corrupted: Just send the next ACK</div><div>Corrupted: Send the previous ACK</div><div><br /></div><div>Sender:</div><div>Just send the packet with the number of reciever's ACKN, n+1</div><div><br /></div><div>&lt;Insert 30&gt;</div><div><br /></div><h3>RDT 3.0 Channels with errors and loss</h3><div>New Assumption: Underlying channels can also <b>lose </b>packets (data,ACks)</div><div>- Checksum, seq</div><div><br /></div><div>Approach Sender waits "reasonable" amount of time for ACK</div><div>- Countdown timer</div><div>- Time out</div><div>- Retransmit if no ACK received in this time</div><div><br /></div><div><i>Use interrupts to implements a count down..&nbsp;</i></div><div><i>Use countdown timer to wait for the packet.</i></div><div><i><br /></i></div><div>If the packet get delayed, we treat it as lost, the retransmission will be duplicate but the seq number already handle this issues.</div><div><br /></div><div>&lt;Insert 33&gt;<br />The sender/receiver will start a timer after sending the packet/ack<br />If timer runs out and no response, it will resend again.<br /><br /></div><div><b>Premature Timeout</b><br />The ack got delayed, the sender sends because it thoughts its packet is lost or the receivers packet is lost.<br />But the receiver will see the duplicate and throw it away.<br /><br /></div><div><b>Duplicated ACKS?</b></div><div>- In the Textbooks<br /><h3>Performance of RDT3.0</h3></div><div>Even thou it is correct, it's performance is still not good.</div><div><br /></div><div>D(trans) = L / R</div><div>U(sender) = (L/R) / (RTT + L / R)</div><div><i>Fractuon of the time the sender waits to send</i></div><div><i><br /></i></div><div><i>It needs to take a whole round trip before the sender is able to send the next packet.</i></div><div><i>The RTT is too long and very inefficient.</i></div><div><i>In order to stop, we will send multiple packets (Pipelining)</i></div><div><i><br /></i></div><div><b>Pipelining&nbsp;Protocols</b></div><div>Allows senders to send multiples in flight yet to be acknowldge pkts</div><div>- Range of seq numbers must be increase</div><div>- Buffering at both sender and receiver side</div><div><br /><br /><br /><br /></div><h3>Go back N in action</h3><div><br /></div><div><br /></div><div>We allow N packets to be send without acknowledgements</div><div>These are "Sliding window protocols"</div><div><br /></div><div>When the receiver receives, it will send back the ACK but identify its an out of order packet.</div><div>It will discard the packets after the missing and send back the ACKn where n is the packet ID before the missing one.</div><div><br /></div><div>The sender will send the next corresponding packet base on the acks where the next packet is packet(n+N)</div><div><br /></div><div>The sender's time out will happen for the missing pkt and it will resend it to the receiver.</div><div><br /></div><div>GO-Back-N only use one timer.</div><div>This is under the assumption that the receiver will not accept the discarded packets</div><div>&lt;Inseet 40&gt;</div><div><br /></div><div><h4>Sender</h4></div><div>- Sends packets</div><div><div>- K-bit seq # in pkt header</div><div>- Window of up to N consecutive unack'ed packets allowed.</div></div><div>- One timer for oldest inflight packet (If pkt 0-3 is send and pkt 2 is lost, the timeout is for pkt0)</div><div>- If timeout: Resends all packets from latest ack received</div><div>- Waiting Ack delayed but recieved the next ACK: Mark all packets below received as sent</div><div>- Moves window everytime an ack is received correctly</div><div><br /></div><h4>Receiver</h4><div>- Receives packets</div><div>- Sends Ack of the next expected packet</div><div>- Discards out of order packets/Duplicated and resend the Ack of expected packet</div><div><br /><br /><br /><br /></div><div><br /></div><h3>Selective Repeats</h3><div><br /></div><div><br /></div><div><br /></div><div><b>Key Differences</b></div><div>Receiver individually acknowledges all correct received pkts</div><div>- Buffer out of order pkts&nbsp;</div><div><br /></div><div>Sender maintain timer for each unack</div><div><br /></div><div><br /><b>&lt;Insert 45&gt;</b></div><div><b><br /></b></div><div><br /></div><div><b>Sender</b><br />- Send packets<br />- Have a timer for each unACKed packet<br />- Timeout: Resent only that packet, restart timer<br />- Acked: Move window up, send the next packet.<br />- Moving window: If there are unACKed packets before the moving window, resent them</div><div><br /><b>Receiver</b><br /><br />pkt n in [rcvbase, rcvbase + N -1 ] (Sliding window)<br />- send ACK<br />- Out of order buffer: Buffer packets that are not in order, sends ACK for packets recieved<br />- Deliver all in order packets as soon as possible, move window<br />- Duplicated Packets: ReACK for that packet<br />- Corrupted Packet: Ignore<br />- Delayed ACK/Packet: Rely on timer on sender side<br /><br /><i>My sender probably did not recieve the ack so we send again so that sender will not get stuck</i><br /><br /><br /><br /><br /><br /><h2>Recap</h2>&lt;Insert slide 5-2&gt;<br />Stop and wait protocol: Summary<br /><br /><i>What happen if the received&nbsp;ack is thrown again?</i><br /><i>We are using to few bits to represent the sequence number of the packets. We cannot differentiate.&nbsp;</i><br /><i>Solution: Use a large number of packets (TCP)</i><br /><i><br /></i><b>Go back N</b><br />- Use cumulative ack to acknowledge the most recent pkt<br />- receiver does not buffer<br />- sender maintains only one timer and is for the most unknowlege<br />- But sender has to resent all transmitted packet since the last unacked pkt<br /><br /><b>Selective repeats</b><br />- Sliding window to buffer out of order for reciever<br />- Sender: only retransmit the missing ack packet (one only)\<br />- Sender has timer for each pkt<br /><br /><h2>Transport layer services</h2><h3>Overview:</h3><div>- Point to point: One sender and one receiver</div><div>- Connection oriented: Handshaking inits sender, received state before data exchange</div><div>- Full duplex: Sender can receive and send at the same connection</div><div>- Reliable, in order byte stream: No message boundaries</div><div>&nbsp; &nbsp; &nbsp; Assumes that input will be output in the same order</div><div>- Pipeline: dynamic window size set by congestion/flow control</div><div>&nbsp; &nbsp;It is different from go back n and selective n (fix sliding window), pipeline's can change</div><div><br /></div><h3>TCP: Buffers and Segments</h3><div>- Tcp send and receive buffers</div><div>Two buffer created after handshaking at any side</div><div>Should be regarded as a stream of bytes</div><div><i>The TCP will accumulate the bytes from the application layer above.</i></div><div>&lt;insert 8&gt;</div><div>The TCP create a segment to be send to the reciever</div><div><i>How large will each segment will be?</i></div><div><i>- 1460 bytes typically (From application)</i></div><div><i>- Limited by maximum transmission unit, largest link layer frame (1500 bytes for ethernet)</i></div><div><i><br /></i></div><h3>TCP segment structure</h3><div>Typically 20 bytes for header</div><div><b>&lt;Insert 10\13\21&gt;</b></div><div><br /></div><div>TCP needs to differentiate between clients. TCP will use a 4 tuple to match to different sockets. The server can be running over a single process with multiple threads each serving on different socket connections.&nbsp;</div><div><br /></div><div>- Source port</div><div>- Dest port</div><div>- Sequence number</div><div><br /></div><div>It tells the index of the first byte in the data segment</div><div>e.g send a file of 500000 bytes where MSS is 1000 bytes (Max num of bytes that can be carried in one seg)&nbsp;</div><div>Dividing the file into 1000 bytes, there are 500 segments&nbsp;</div><div>The first segment will be 1000 bytes (Index 0-999)</div><div>Second segment will be 1000- 1999</div><div><br /></div><div>TCP's sender implement a similar data structure as go back N</div><div>The difference is that each little piece, represent a packet (go back) while in tcp it represent a byte</div><div>&lt;Insert 15&gt;</div><div><br /></div><div><i>The sequence number will specify the first byte of the next tcp segment</i></div><div><br /></div><div>- ACK number</div><div><br /></div><div>Seq# of the next byte expected from the other side</div><div>This is express using cumulative ack</div><div><br /></div><div><i>Assuming the receiver&nbsp;has receive the first byte, in the ack, the receiver&nbsp;will put the index of the 2nd byte as the ack number. Cumulative means&nbsp;that&nbsp;all the bytes before that has been&nbsp;receiver. Sending this, tells the sender that that is the missing byte it does not have.</i></div><div><i><br /></i></div><div><i>How does the receiver handles out of order segments?<br />- TCP spec doesnt say, it is up to the implementer</i></div><div><i>&nbsp; &nbsp; - Can choose to buffer</i></div><div><i>- WE will still send back the next expected byte back to the sender&nbsp;</i></div><div><br /></div><div>Sequence and ACK is counted by bytes of data (Not segments)</div><div><br /></div><div><br /></div><h4>Selective repeat: Sender, receiver windows</h4><div><i>When receive&nbsp;send back the ack, it always send back the number if the first byte of the unreceived&nbsp;and expected byte.&nbsp;</i></div><div><i><br /></i></div><h4>TCP seq. numbers, ACKS</h4><div>Assume a echo server, the client sends a message with only one byte.&nbsp;</div><div>data = 'C', seq = 42 (Sequence number is randomly chosen) [Data message]</div><div>The server can choose to send something to the client as well since the connection is bi directional</div><div>When the server behaves like a client, it use a different sequence number</div><div><br /></div><div>The server side will expect something of 43, so it will send back an ack = 43, seq = 79 [Data message and ack]</div><div><br /></div><div>The client will put an ack = 80 and seq = 43</div><div><br /></div><h4>TCP flow Control</h4><div>When the receiver receive an ip packet at the ip layer, it will go through protocol stack upwards.</div><div>It is going to go through the ip protocol to be stripped before delivered to the transport layer. The tcp will look at the header and take out the data to be put in the buffer before sending it back to the application layer.</div><div><br /></div><div>If the application layer process is slower than the time use to fill buffer. (The host running alot of processes)</div><div>The receiver buffer might be overflowed by the sender side&nbsp;</div><div>This is why we need flow control. This is for the receiver side to informed the sending side to warn it of incoming overflow (Do not send too much)</div><div><br /></div><div>- receiver advertises free buffer space in TCP header</div><div>- RcvBuffer size set bia socket option</div><div>- Many operating system autoadjust</div><div>- Sender limits amounts of unacked data to receivers rwnd value (Window frame)</div><div>- This ensure that the buffer does not overflow at the receiver side</div><div><br /></div><div><br /></div><h4>Head Len</h4><div>Holds the typical header length of the header of tcp segment</div><div>There might be optional fields thus some tcp headers are longer than 20 bytes</div><div>This is only in theory, in practice it is not use</div><div><br /></div><h4>PSH: Push data now</h4><div>Due to the application data carrying important detail, it can set this bit to be 1 so that the reciever can know that this packet is important</div><div>(Not ise in practice)</div><div><br /></div><h4>URG: Urgent data</h4><div>Tells that some part of the data is urgent and need to be push to application layer of the receiver immediately</div><div><br /></div><div><br /></div><div>Has a corresponding pointer that show where the urgent part is</div><div><br /></div><h4>RST, SYN, FIN</h4><div>Rst - reset</div><div>When the sender and receiver try to start a connection. If the server is not available due to being down, the host side will send a feedback message with this bit set to be 1. This tells that the server/port is not running/open.&nbsp;</div><div><br /></div><h3>Connection Management</h3><div>Sender and receiver will handshake first before exhanging data:<br />- Agree on establish connection</div><div>- Agree on connection parameters</div><div><br /></div><div>Each side will reserve buffers and negotiate states for a connections.</div><div>e.g sequence number (init) for each direction</div><div><br /></div><h4>3 way handshake procedure</h4><div>The use of 3 packets to establish a connection</div><div><br /></div><div>1. Both sides are at listen</div><div>2. Client sent a syn packet and choose seq num</div><div>Sets synbit = 1, seg = x</div><div>This does not have any data</div><div>3. Client transition into syn sent</div><div>4. Server will try to create socket after receiving syn</div><div>5. Server will create a syn ack message which will set the synbit to be 1</div><div>Both the syn and ack bit will be 1, it will put the number x+1 (client seq) into the ack field</div><div>The server will also generate a seq number = y</div><div>This is for the other side</div><div><br /></div><div>What the server is saying that it expecting x+1 byte next.</div><div><br /></div><div>6. Client saw that the server agreed to have a connection, it will transition into the ESTAB stage</div><div><br /></div><div>7. But the server side have not transition to ESTAB stage, so the sender have to send another ACK</div><div>ACKNUM = y +1</div><div>//This is telling the server that the receiver is expecting y+1 to be the next packet</div><div><br /></div><div>8. The sender can either piggy bag or use x+1</div><div><br /></div><h4>TCP: Closing a connection</h4><div>- Client, server each close their side connection</div><div>Fin bit = 1</div><div>- Respond to received FIN with ACK</div><div><br /></div><div>Even if one side has close, it will keep its receiving up until the other side is ready to close (Clear its buffer)</div><div>Once the other side receive the ack, it will close as well</div><div><br /></div><h3>Reliable Data transfer</h3><div>- TCP creates a rdt service on top of IP udt service</div><div>&nbsp; &nbsp;- pipeline segments</div><div>&nbsp; &nbsp;- Cumulative Acks</div><div>&nbsp; &nbsp;- Single retransmission timer</div><div>- Retransmission are triggered by</div><div>&nbsp; &nbsp;- timeout events</div><div>&nbsp; &nbsp;- duplicate ack</div><div><br /></div><div><i>Go back N and TCP are similar&nbsp;due to both using one single transmission</i><i>&nbsp;timer and cumulative ack</i></div><h4>TCP sender events</h4><div>Ignoring flow control and congestion</div><div><br /></div><div>Data rcvd from application layer:</div><div>- Create segment with seq# (Byte stream number of first data byte in segment)</div><div>- Start timer if not already running</div><div>- pass segment to IP</div><div><br /></div><div>Timeout:</div><div>- retransmit segment that cause timeout</div><div>- Restart timer</div><div><br /></div><div>ack Rcvd (Receives ack):<br />- If ack acknowledges prev unacked segments</div><div>update what is known to be acked</div><div>- start timer if there are still unacked</div><div>Moving sliding window and restart the timer. ACK are cumulative thus we need to update.</div><div><br /></div><div><br /></div><div><u>If theres a lost ack</u></div><div>The sender will resent the same pkt</div><div><br /></div><div><u>If there is a premature timeout</u></div><div>Sender will resend again even if the receiver has already receive it already.</div><div>Receiver will resend the next expected packet</div><div><br /></div><div><u>Cumulative ack</u></div><div>If the ack got lost, upon receiving the later ack,&nbsp;</div><div>it will implicitly know that the missing ack has already been received</div><div><br /></div><h4>TCP Ack generation</h4><div>1.&nbsp;</div><div>Event at receiver: Arrival of in order segment with expected seq #. All data up to expected seg # already ACKED</div><div>TCP receiver action: delay ack, wait up to 500 ms. If during this time, there is no other packets, it will send the ack back</div><div><br /></div><div>2.&nbsp;</div><div>Event at receiver: In order but one seg has ack pending</div><div>Have not send the ack pending even thou i have receive it</div><div><br /></div><div>TCP at receiver: Send a single cumulative ack, ack both in order segments</div><div>Instead of sending 2, we can just send one latest one</div><div><br /></div><div>3.&nbsp;</div><div>Event at receiver: Arrival of out of order segment.&nbsp;</div><div>Gap detected</div><div><br /></div><div>TCP receiver: Immediately send duplicate ack indicating the next expecting byte via seq#</div><div><br /></div><div>4.</div><div>Event at receiver: Arrival of segment that partially or completely fills gap.</div><div><br /></div><div>TCP receiver action: Immediately send ack provided that segments starts at lower end grip</div><div><br /></div><h4>TCP round trip time, timeout</h4><div><i>How to set tcp timeout value?</i></div><div><i>- Longer than RTT (RTT varies)</i></div><div><i>- Too short: Premature timeout</i></div><div><i>- Too long: Slow reaction to segment loss</i></div><div><i><br /></i></div><div><i>How to estimate RTT?<br />- ignore retransmission (Measure time from segment transmission until ack receipt)</i></div><div><br /></div><div>EstimatedRTT = (1 -a) * estimatedRTT + a*sampleRTT</div><div>TimeoutInterval = EstimatedRTT + 4 *DevRTT&nbsp;</div><div>DevRTT is the safety margin</div><div><br /></div><h4>TCP fast retransmit</h4><div>- Sometimes the timeout can be very long due to the congestion/distance</div><div>- Detection of packet loss would let us not to wait for timeout</div><div>- Timeout is use to infer packet loss if we got no other methods</div><div>- Duplicated ACKS checks for missing packet losses before time out</div><div>= Sender often sends back many segment backto back</div><div>= There will likely be many duplicate acks</div><div>Since ACks will show the expecting packet, so if it got loss, the sender can infer which packet got loss if it recieve multiple acks showing the same next expecting packet</div><br /><br /></div>