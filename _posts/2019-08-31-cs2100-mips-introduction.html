---
layout: post
title: 'CS2100: MIPS Introduction'
date: '2019-08-31T08:14:00.001-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-09-17T02:09:19.793-07:00'
thumbnail: https://1.bp.blogspot.com/-w9W9TgevB50/XWvZ3a3Y__I/AAAAAAAACD0/r2eTredf9jolzToSSDXn-mKrg4N-jN8PwCLcBGAs/s72-c/1.PNG
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-5361839431512938366
blogger_orig_url: https://nusmods.blogspot.com/2019/08/cs2100-mips-introduction.html
---

<h3>MIPS Introduction</h3><div>We can retrieve the assembly code by running this command on a c prog</div><div>-&gt; gcc -s hello.c</div><div>//this will generate a .s file which is the assembly code</div><div>vim hello.s</div><div><br /></div><div><br /></div><h4>Execution walkthrough</h4><div>1. Read</div><div>2. Process Figure/ decode</div><div>3. Fetch oprands</div><div>4. Execute</div><div>5. Storeback</div><div><br /></div><div>However, memory access is slower than process speed thus we have to avoid memory storage by using temp register to store</div><div>Most processor now is at least ten times faster than the memory access</div><div>This is bad as processor would wait for the memory to access.</div><div><br /></div><h4>Memory Instruction</h4><div>Will move the memory into the register, this is to help with the time wasted in memory access</div><div>e.g load, store</div><h4>Reg-to-Reg Arithmetic</h4><div>Arithmetic operation only works on register, memory wont be touched</div><div><br /></div><div>The ALU will do the calculation</div><div><br /></div><h4>Loop</h4><div>Execute commands from top down.</div><div>To loop, we check a condition and if condition is true,</div><div>we jump back to the tag indicated</div><div><br /></div><div>Summary:</div><div>Both instruction and data are stored in memory</div><div>Limit memory access<br /><br /><h4>MIPS Assembly Language</h4><h4>General Purpose Register</h4><div>- Registers are useful as it helps access memory faster.</div><div>Data are transferred from memory to register for faster processing.</div><div>However, there are limited number of registers.</div><div><br /></div><div>- Registers have no data type</div><div>Machine/Assembly instruction assumes data is correct type</div><div><br /></div><div>Types of registers</div><div>$zero - Only stores 0, cannot be changed</div><div>$t0 - $t7 (8-15) - Temp for storing</div><div>$s0 -$s7 (16-23) - program variables<br />$t8 - $t9 (24-25)- Temp for Calculation</div><div><br /></div><div>We can reference the register by number or by the names.</div><div><br /></div><h4>Arithmetic Operation</h4><div>Addition:</div><div><br /></div><div>a = b + c</div><div><br /></div><div>add $s0, $s1, $s2</div><div><br /></div><div>This is called variable mapping.</div><div>The value is map into the register.</div><div><br /></div><div>However. Order is important</div><div><br /></div><div>Subtraction:</div><div><br /></div><div>a = b - c</div><div><br /></div><div>sub $s0, $s1, $s2</div><div><br /></div><div>$s1 -&gt; b</div><div>$s2 -&gt; c</div><div><br /></div><div>Note:</div><div>For complex expression such as&nbsp;</div><div>a = b - c + d</div><div>We can split it to multiple assembly codes.</div><div>Since + and - lies on the same precedence,</div><div>we evaluate left to right</div><div><br /></div><h4>Constant/ Immediate Operands</h4><div>addi:</div><div><br /></div><div>To add a constant to a number we use addi</div><div><br /></div><div>a = a+ 4</div><div><br /></div><div>addi $s0, $s1 , 4</div><div>However, the constant can only range from -2^15 to 2^15 - 1</div><div>Which is 16 bit 2s complement</div><div><br /></div><div>Register Zero:</div><div>f = g</div><div><br /></div><div>We can just run</div><div><br /></div><div><i>add $s0 , $s1 , $zero</i></div><div><br /></div><h4>Pseudo-Instruction</h4><div><i>move $s0, $s1</i></div><div><br /></div><div>is similar to&nbsp;</div><div><br /></div><div><i>add $s0 , $s1 , $zero</i></div><div><br /></div><h4>Logical Operation</h4><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-w9W9TgevB50/XWvZ3a3Y__I/AAAAAAAACD0/r2eTredf9jolzToSSDXn-mKrg4N-jN8PwCLcBGAs/s1600/1.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="557" data-original-width="872" height="255" src="https://1.bp.blogspot.com/-w9W9TgevB50/XWvZ3a3Y__I/AAAAAAAACD0/r2eTredf9jolzToSSDXn-mKrg4N-jN8PwCLcBGAs/s400/1.PNG" width="400" /></a></div><div class="separator" style="clear: both; text-align: left;">Nor is not (A or B)</div><div class="separator" style="clear: both; text-align: left;">Xor is exactly One</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;"><br /></div><h4 style="clear: both; text-align: left;">Shifting</h4><div>We use shifting to move the bits</div><div>This is useful for multiplication.</div><div><br /></div><div>By moving 4 bits to the left, its equivalent to multiplying x2^4</div><div><br /></div><div>Shifting to the right will divide instead.</div><div><br /></div><div><br /></div><div><h4>And Operator</h4></div><div>Using the logical operations to get the bits we want (Masking)<br /><br /><br /><b>Or Operator</b><br />- We force certain bits to 1s.<br /><br /><h4>Nor Operator</h4>- We can use this to not since there is no not operator<br />To not it, just apply a 0 to not the answer.<br /><br />nor $t0, $t1 , $zero<br />Where $t1 is the bit that we want to not<br /><br /><h4>XOR Operator</h4></div><div>If both bits are the same, return 0</div><div>If both bits are different. return 1</div><div><br /></div><div>We can do a not for xor bit by applying a 0xFFFFFFFF</div><div><br /></div><h4>Load upper immediate</h4><div>- LUI to set the upper 16 bit</div><div>- Set the lower bits as 0</div><div><br /></div><h4>Or Immediate</h4><div>- Apply to set lower order bits</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-fN8lLJHp8aA/XW9w5IUv5XI/AAAAAAAACEk/6t-fxO0Ycx8SvKvQEcyDkpTmGJn7tTIowCLcBGAs/s1600/2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="970" data-original-width="1345" height="286" src="https://1.bp.blogspot.com/-fN8lLJHp8aA/XW9w5IUv5XI/AAAAAAAACEk/6t-fxO0Ycx8SvKvQEcyDkpTmGJn7tTIowCLcBGAs/s400/2.png" width="400" /></a></div><div><br /></div><div><br /></div><div><br /></div><br /><br /><br /><a href="https://nusmods.blogspot.com/2019/08/cs2100-structure-and-array.html">&lt;Prev&nbsp;</a> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="https://nusmods.blogspot.com/2019/09/cs2100-mips-memory-and-branch.html">Next&gt;</a></div>