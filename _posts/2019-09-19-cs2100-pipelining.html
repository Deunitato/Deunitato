---
layout: post
title: 'CS2100: Pipelining'
date: '2019-09-19T03:35:00.002-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-09-24T00:47:34.610-07:00'
thumbnail: https://1.bp.blogspot.com/-8uon9D9AojQ/XYm9UyOdbuI/AAAAAAAACLk/FStTtQk56jY7Lg660AAybKUrA861QIVWQCLcBGAsYHQ/s72-c/4.png
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-7311464593046309835
blogger_orig_url: https://nusmods.blogspot.com/2019/09/cs2100-pipelining.html
---

<h2><span style="font-size: 50;">Pipelining</span></h2><h2><span style="font-size: x-large;">Mips Pipelining</span></h2><div>Can we go faster?<br />Instruction Execution =<br /><br /><ol><li>Read contents from storage elemts</li><li>Perform computation through some combination logic</li><li>Write result to storage element</li></ol><h3>Single-cycle processor</h3><h4>Performance</h4><div>We have to choose for the<u> longest instruction time total as our cycle time</u><br /><u><br /></u></div><div>But because we choose the longest, sometimes instruction will finish early</div><div>To execute 100 instruction = 100 * 8ns = 800ns</div><div>We will define a cycle time for a single cycle processor.<br />The clock frequency we select is a sum of&nbsp; Tk where n is the number of stages for each Tk<br /><br /></div><div>Tk: time that is taken for each step<br />n: Number of stages for each Tk<br /><br /></div><div>The total execution time for I instruction is cycle * cycleTime</div><div>Each Instruction takes <u>one cycle to execute</u></div><div><br /></div><h4>Multicycle Implementation</h4><div>- Break up instruction into execution steps</div><div>- Each execution steps takes one clock cycle (Shrinking cycle time, increase clock freq)</div><div>- Choose to enable certain stages for certain instruction</div><div>- Instructions don't take the same number of cycle to finish</div></div><div><br />Average CPI is the average number of cycles taken.<br /><br /><br /><ol><li>Determine cycle time by choosing max cycle time</li><li>Choose the avg CPI</li><li>Total execution = I * AverageCPI * CT(multi for each of the cycles)</li></ol><h2>Pipelining</h2><h4>Stages</h4><div><ol><li>IF (Instruction Fetch)</li><li>ID (Instruction decode and Register Read)</li><li>EX (Execute and Operation or calculate an address)</li><li>MEM (Access an Operand in Data memory)</li><li>WB (Write back the result into a register)</li></ol><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-8uon9D9AojQ/XYm9UyOdbuI/AAAAAAAACLk/FStTtQk56jY7Lg660AAybKUrA861QIVWQCLcBGAsYHQ/s1600/4.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="534" data-original-width="946" height="360" src="https://1.bp.blogspot.com/-8uon9D9AojQ/XYm9UyOdbuI/AAAAAAAACLk/FStTtQk56jY7Lg660AAybKUrA861QIVWQCLcBGAsYHQ/s640/4.png" width="640" /></a></div><div><br /></div>Realised that the Branch Target Address (To computer) and the result (To store) goes from right to left unlike the other instructions<br /><h3>Datapath</h3></div>We will use a latch that will maintain a stable value while other instructions are working<br />These are pipeline registers, a latch that updates only when the clock is on the upper edge<br />These pipeline registers allow us to isolate the stages<br />(Shaded right side = read)<br /><br /><b>IF/ID</b><br />Read the instruction memory from PC and store it into the pipeline register. We also realised we store the PC+4. Instruction bits (32) will be memorised.<br />Read data 1 and read data 2, 16 bit immediate will be sign-extended to 32 bits.<br /><br /><b>ID/EX</b><br />- Register values read<br />- 32 Immdeiate value<br />- PC+4<br /><br /><b>EX/MEM</b><br />PC+4 is used to calculate the branch instruction<br />Why can't we just route it? Because its a pipeline processor so each time its doing many other stuff. We cannot pass the value to another component which might be doing something at the moment<br />- ALU Result<br />- isZero signal<br />- Read data 2 from the register file<br /><br /><b>MEM/WB</b><br />If its a store word instruction, it will use to store memory<br />- ALU result<br />- Memory read data<br /><br /><b>END</b><br />ALU data or memory data<br />Passback<br />Or it can use to store memory location<br />Needed:<br />- Data to be written<br />- Register number<br /><br />We realised that the register number may not be correct because we use the current number in the decode stage to as the address but now we are <u>doing pipelining, it might be the wrong value</u> as it will be <u>overridden</u>.<br /><br />Solution:<br />SO we will pass the value in write value through the pipeline continuously until it is in WB stage<br /><br /><h3>Pipeline control</h3><div>Use control signals as a single cycle data path</div><div>Difference: When is that signal utilized</div><div><br /></div><div>Control unit will control the signal and pass the value along the pipeline until it reaches the designated place.</div><div><br /></div><h4>Grouping</h4><div>We ask when do we use the signals and group them at the stage where they are being used.</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-e3K6ngtRMvw/XYm6OmtP8RI/AAAAAAAACLQ/6rh4Uaw6ICI8E90p9ZvBF_U1iJh_75FzwCLcBGAsYHQ/s1600/2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="350" data-original-width="1136" height="197" src="https://1.bp.blogspot.com/-e3K6ngtRMvw/XYm6OmtP8RI/AAAAAAAACLQ/6rh4Uaw6ICI8E90p9ZvBF_U1iJh_75FzwCLcBGAsYHQ/s640/2.png" width="640" /></a></div>We group them so we know when to send a signal from the pipeline control to control the latches,</div><div><br /></div><h2>Pipeline Performance</h2><div>Td - pipeline overhead e.g pipeline register<br />max(Tk) - longest stage time among the N stages</div><div><br />Cycle time:<br />CTpipe = (max(Tk) + Td) * (I + N - 1 )<br />is the cycle needed for I instructions</div><div><br /></div><div>But what is the better speed up?</div><div><br /></div><h3>Ideal speedup</h3><div>- Each stage almost the same time</div><div>- The summation is the same * number of stage</div><div>- Assume there's no pipeline overhead</div><div>- Number of instruction I is much larger than number stags N</div><div><br /></div><div>These assumptions can also show how pipeline loses performance</div><div><br /></div><div><br /></div><div>Speedup = time (single cycle) / time (pipe)</div><div>= N (if I is very large compared to N)</div><div>Conclusion: To increase speedup, increase N where N is the number of stages</div><h3></h3><h2>Pipeline Hazard</h2><div>3 Problems:</div><div>- Structure hazard caused by hardware resources</div><div>- Data hazard caused by data dependency</div><div>- Control Hazard caused by the change in program flow</div><div><br /></div><h3>Structure Hazard</h3><div>Let say we only have one single memory module.</div><div>When we go through the pipeline, check if we use the same hardware twice in a clock cycle.<br />We cannot have two instructions using the same hardware.</div><div><br /></div><h4>Stall the pipeline</h4><div>Ask the instruction to stall until the problem goes away, then continue. Every instruction will have a NOP&nbsp; which is an or $0 $0 $0 which stall one cycle</div><div>But it will cause a bubble and will waste time</div><div><br /></div><div>Or it can use to store memory location</div><div><br /></div><div><b>Separate&nbsp;Memory</b></div><div>Split memory into 2 separate modules: data and instruction. Instructions like LW can use data memory while INST can use instruction memory</div><div><br /></div><div>Using this idea, even when they access, its two separate modules. Thus we can access the memory twice.<br /><br /></div><div><br /><b>Read after Write register</b><br /><b><br /></b>Occurs when a later instruction readds from destination register written by an earlier instruction. (True data dependency)<br /><b><br /></b><br /></div><div>Register file access is quick to access to read and write such that it can 2 instruction in one cycle. One cycle has an upper edge/lower edge, we can read/write during these two different cycles.</div><div><br /></div><div><br /></div><h3>Data Hazard (Data dependency)</h3><div>When the relationship between instruction prevents pipeline execution.&nbsp;</div><div><br /></div><h4>RAW (Read after Write)</h4><div>i1: add $1, $2, $3</div><div>i2: sub $4, $1, $5</div><div><br /></div><div>If the processor did not do properly, it will read the old data rather than the updated data.</div><div>There is no way we can avoid this (true data dependency).</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-h7S9BM2BG-g/XYnGcAIybyI/AAAAAAAACLw/1zMW5lYfGk0gZ2vOCD7Sf17qGggqZLBOQCLcBGAsYHQ/s1600/5.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="514" data-original-width="967" height="212" src="https://1.bp.blogspot.com/-h7S9BM2BG-g/XYnGcAIybyI/AAAAAAAACLw/1zMW5lYfGk0gZ2vOCD7Sf17qGggqZLBOQCLcBGAsYHQ/s400/5.png" width="400" /></a></div><br /></div><h4>Forwarding</h4><div>- Forward the result to any trailing instructions before it's reflected in the register file</div><div>Because the latest time we can get the value is right after ALU, we will store it in a latch (ex/mem or Mem/wb)</div><div>- Bypass the data read from the register file</div><div><br /></div><div><b>What if the instruction is a load word?</b></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-s3cBtyIPH18/XYm7J8GzRkI/AAAAAAAACLY/FY3pcy4VhsQZV53riVkr8IIrwiT41MHUQCLcBGAsYHQ/s1600/3.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="518" data-original-width="965" height="340" src="https://1.bp.blogspot.com/-s3cBtyIPH18/XYm7J8GzRkI/AAAAAAAACLY/FY3pcy4VhsQZV53riVkr8IIrwiT41MHUQCLcBGAsYHQ/s640/3.png" width="640" /></a></div><br /></div><div>The calculation is done one step away from the use of the register.&nbsp; We have no choice but to stall since lw at cycle 5 but needed in cycle 4.</div><div>We have to use a stall instead.<br /><br /><h3>Control hazard (Control dependency)</h3></div><div>An instruction depends on another instruction to know if it gets executed (e.g branch)</div><div>If control is not handled properly, it might cause an incorrect execution that might change values incorrectly.</div><div><br /></div><div>e.g</div><div>beq $1, $3, 7 (PC+4) + (7*4)</div><div><br /></div><div><b>IF&nbsp;</b></div><div>Branch will be store into latch at end of the cycle.</div><div>PC will produce 44 which is the next instruction</div><div>Branch will move to decode stage</div><div>PC will be 48</div><div>BEQ will move over while PC = 44 will move to IF stage</div><div>By the time we decided whether to take the branch, there will be other instruction in the processor already. -&gt; TOO LATE</div><div><br /></div><div><b>Stall</b></div><div>We need to stall until the branch reaches the mem stage (<u>3 cycles</u>)</div><div>But 3 cycles is very heavy.</div><div><br /></div><div><b>Early Branch resolution</b><br />Make the decision in ID stage instead of MEM</div><div><br /></div><div>1. Calculate branch target address&nbsp;</div><div>2. Check the condition of a branch instruction</div><div><br /></div><div>We will try to move the calculation earlier, make the decision in the ID stage rather than EX stage.</div><div>In the decode stage, at the end of cycle 2 we wait for branch outcome and reduce 1 clock cycle delay.</div><div><br /></div><div>But this will break the code which forwarding cannot solve (Due to past back in time)</div><div>We will use stalling as well.</div><div>Then we will then include a new path for the branch instruction from ALU to ID stage</div><div>This will add on another clock cycle delay.</div><div><br /></div><div>But we will realise when we load follow by branch since we only get the correct value in the register after it reads the memory, we have to forward the memory from mem/wr latch but it's going back in time again (decode stage of branch), so we need double stall.</div><div>This will add on another clock cycle delay</div><div><br /></div><div>-&gt; Total is<u> 3 clock cycle</u></div><div><br /></div><div>But compiler can do something useful in this case, we can do other instructions</div><div>-Theres no other ways to improve this method-</div><div><br /></div><div><br /></div><div><br /></div><div><b>Branch Prediction</b></div><div>We predict that all branches are not to be taken. We treat the branch as if it's not taken</div><div><br /></div><div>Not taken:</div><div>Guess correct</div><div>-no Pipeline stall</div><div><br /></div><div>Taken:</div><div>Guess wrongly</div><div>-&gt; Wrong instruction</div><div>-&gt; Flush successor</div><div>We set all the latch to 0</div><div>It's safe to let them go in and because the mem and write are at the later stage, the killed of instructions will not reach there.</div><div>Total instructions = 1 + 10*2 (loop) +1</div><div>Ideal pipeline = 4 + 22*1 = 26 cycle //only first instruction is overhead and we ran the code once</div><div><br /></div><div><b>Delayed Branching</b></div><div>Since we are waiting for X cycles,<br />why not do something meanwhile.<br />"Branch-delay slot"<br />We need to find another instruction to move into.<br /><br />e.g<br />When we see beq, we will need to delay 1 cycle,<br />We will look ahead from the branch for another independent instruction and execute them.<br />Those instructions are going to be executed regardless of the branch.<br /><br />e.g<br />or xxxxxxxx<br />beq&nbsp; xxxxxxxx, exit<br />(Empty slot for independent instruction here)<br />Xor xxxxxxxxxx<br />exit:<br /><br />- Because Or does not depend on the branch and will execute anyways, it is moved into the slot.<br />- So while the BEQ is calculating, it will run OR<br /><br />But what if we cant find an instruction?<br />- Nop<br /><br /><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div></div>