---
layout: post
title: 'CS2106: Lecture 2 - Process Abstraction'
date: '2020-01-21T19:41:00.001-08:00'
author: Charlotte Deunitato
tags: 
modified_time: '2020-02-05T00:57:37.255-08:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-1529365207649662765
blogger_orig_url: https://nusmods.blogspot.com/2020/01/cs2106-lecture-2-process-abstraction.html
---

<h2>Recap:</h2><h3>Efficient Hardware Utilization</h3><div>- OS should provide efficient use of hardware resource</div><div>- Allow multiple program to share the hardware</div><div>- OS provide abstraction to encapsulate the execution of a program</div><div><br /></div><h3>C sample Program and Assembly Code</h3><div><b>int i = 0</b></div><div><br /></div><div>Assume the address of i is at 4096</div><div>lw $1, 4096 #loads the value at 4096</div><div>addi $1, $0, 0 # store $1 = 0</div><div>sw $1 , 4096 # i =0</div><div><br /></div><div><br /></div><div><b>i = i +20</b></div><div><b><br /></b></div><div>lw $2, 4096 #store i in $2</div><div>addi $3, $2, 20 #add $3 = $2 +20</div><div>sw $3, 4096 #i = i +20</div><div><br /></div><h3>Program execution(Memory)</h3><div>There is a component in the memory that contains the text for instruction. Under the text memory is the data memory for global variables. The lifetime of these variables is the same as the life time of the function. The compiler has access to these memory.</div><div><br /></div><div>e.g int j;</div><div>The compiler is going to put this data into the BSS (Segment), it allocates a space in the data memory for this variable. The system auto sets it to 0.&nbsp;</div><div><br /></div><h3>Computer Organisation</h3><div>The computer contains 2 main pieces, the memory and processor.</div><div>The processor is on the CPU chip.&nbsp;</div><div>Because the memory is so slow, we have two cache components that are very fast. They are data cache and instrcution cache. The process fetches instruction by instruction and decodes them, it also fetches any data from memory if needed and decode it. Register is also use so that there is no need to keep going to caches to get the data.</div><div><br /></div><div><br /></div><div>Memory:</div><div>- Storage for instruction and data</div><div>- Manage by OS</div><div>Cache:</div><div>- Fast</div><div>- Hardware managed</div><div>- Duplicate memory for fast access</div><div>- Usually split into instruction and data cache</div><div><br /></div><div>Fetch unit:</div><div>- Load instruction to memory</div><div>- Location indicated by a special register (PC)</div><div><br /></div><div>Functional Units:</div><div>- Carry out instruction execution</div><div>- Dedicated to different instruction type</div><div><br /></div><div>The protocol is to fetch the instruction, read the operands if its needed.&nbsp;</div><div>Some instruction does not need operands, ie jump</div><div><br /></div><div>When a program is under execution, there are more information:<br />- Memory context: text and data</div><div>-Hardware context: General purpose register, program counter (PC)</div><div>Memory/storage hierarchy</div><div>- Size increases &gt; Speed decreases &gt; Cost per bit decreases</div><div><br /></div><div>Register: Access directly by instruction</div><div><br /></div><div>Cache: Not visible to software</div><div><br /></div><div>Main memory: Access through load store instructions</div><div><br /></div><h2>Process Abstraction</h2><div>Information describe an executing program</div><div><br /></div><div>A process/task/job is a dynamic abstraction for executing program.</div><div>The information required for running program contains:</div><div>- memory</div><div>- Hardware</div><div>- OS</div><div><i>Whatever the OS needs to keep track of the process</i></div><div><i><br /></i></div><h2>Function Calls</h2><div>How to allocate memory space for function declared variables?<br /><h3>Control flow</h3></div><div>- Recursive call?</div><div>- Calling functions?</div><div>Where to store the memory and the stack?</div><div><b>Issues</b></div><div>- Jump from function body</div><div>- Need resume when function call is done</div><div>- Store PC of the caller</div><div><br /></div><div><b>Data storage Issues</b></div><div>- Need to pass parameters to the functions</div><div>- Need to capture the return result</div><div>- May have local variables declaration</div><div><br /></div><div><i>Where are we gonna store all these?</i></div><div><i><br /></i></div><h3>Stack Memory</h3><div>The stack is a memory region to store information function invocation</div><div>- LIFO structure</div><div><br /></div><div><br /></div><div><i>The data is temporary.. once it gets push out of the stack, its out.</i></div><div><i><br /></i></div><h3>Stack frame</h3><div>The data that is stored onto the stack memory. It belongs to one particular function.</div><div><br /></div><div><div>Stack frame contains:<br />- Return address of caller</div><div>- Arguments (Para) for fn</div><div>- Storage for local variables</div></div><div><br /></div><h3>Stack Pointer</h3><div>A pointer that points to the top of the stack region.&nbsp;</div><div>Most CPU has a specialised register for this purpose.</div><div>The stack frame is added on top when a function is invoked.</div><div>Stack can grow towards higher or lower addresses</div><div>- platform dependent.</div><div><br /></div><h3>Setup stack frame</h3><div>- Called function call convention</div><div>- Main diff:</div><div><br /></div><div>Prepare to make function call<br />Caller: Pass para with register and /or stack&nbsp;</div><div>Caller: Save PC on stack&nbsp;</div><div><br /></div><div>Transfer control from caller to callee</div><div>Callee: Save the old stack pointer (SP)</div><div>Callee: Allocate space for local variable of callee on stack</div><div>Callee: Adjust SP to point to new stack top</div><div><br /></div><div><br /></div><div><span style="color: red;">Who does the setup?</span></div><div>=&gt; The compiler</div><div><br /></div><div>On returning from function call:<br />Callee: Place return result on stack</div><div>Callee: Restore saved stack pointer</div><div><br /></div><div>Transfer Control back to caller using saved PC</div><div>Caller: Utilize return result</div><div>Caller: Continues execution in caller</div><div><br /></div><div><i>Just decrement the stack pointer.&nbsp;</i></div><div><i><br /></i></div><h3>Frame pointer</h3><div>- To facilitate the access of various stack frame items</div><div>- Frame pointers points to a fixed location in a stack frame</div><div><br /></div><div><i>It is to access something that is in the middle of the stack. At some point, we will remember the value of the stack pointer and the frame pointer so we can remember values of other variables via referencing.</i></div><div><i>The stack is part of the memory!!!</i></div><div>The usage of these is platform dependent</div><div><br /></div><div><br /></div><h3>Saved Registers</h3><div>The number of GPR on most processor are limited.</div><div>When GPR are exhausted:<br />- Memory temporary hold value</div><div>- GPR value can be restored afterwards</div><div>- GPR can then be reused for other purpose</div><div>This is register spilling</div><div><br /></div><h2>Dynamically Allocated Memory</h2><div>Because the stack memory is only temporary, DAM is used to allocate a memory to be more permanent. DAM allow the memory to leave only when it wants.</div><div><br /></div><div>e.g</div><div>malloc() function call in C</div><div>new keyword in c++ and java</div><div><br /></div><div>The DAM is stored in a heap memory region.&nbsp;</div><div>Usually the heap will grow in the other direction towards the stack. Unlike stack, it can be fragmented.&nbsp;</div><div><br /></div><div>Memory context:&nbsp;</div><div>Text, data, stack and heap</div><div><br /></div><div>Hardware context:</div><div>GPR, PC, Stack pointer, Stack frame pointer</div><div><i>It needs to be protected (status), if any interruption, there will need to save</i></div><div><i><br /></i></div><div>Operating system:</div><div><br /></div><h3>Managing&nbsp;</h3><div>- Harder due to variable size</div><div>- ALlocation and deallocation timing is unknown<br /><br /><br />Extras:<br />1) Why does the compiler knows the address if a global variable?<br /><i>The compiler only know the size of the program and the size of the variables. Having two pointers,</i><br /><i>we can find the address using the relative position of two pointers.</i><br /><i>They do not need to know the exact address.</i><br /><i>There are many ways on finding the address.</i><br /><i>DIfferent compilers will come out with different address -&gt; Under memory management.</i><br /><br />2) Why not use data structures like heap to replace stack?<br /><i>There is another similar heap used to manage but no it does not allow for fragmentation.</i><br /><br /><br /></div><h2>IPC and Synchronization</h2><div>PI (Process identification) is use to distinguished process from each other and is often used even till the hardware level.&nbsp;</div><div>It is a software concept but is communicate till hardware.</div><div><br /></div><div><div><b>Process</b>:</div><div>Memory: Text, data, stack and heap</div><div>Hardware: GPR, PC, stack pointer, stack frame pointer</div></div><div>OS: PID, Process state</div><div><br /></div><div>Design decision:</div><div>- Reuse PID? =&gt; yes</div><div>(Can we run out of ID?)</div><div>- Are there reserved PID =&gt; yes<br />- Does it limit the max no. of processes =&gt; 2^64 (There is alot)</div><div><br /></div><h3>Process state</h3><div>- A process can be running or not running (running another process)</div><div>- A process can be ready to run but not executing</div><div>- State keep track on the status (indication of execution)</div><div><br /></div><div>Simplest model:<br /><u>insert 47</u></div><div><u><br /></u></div><div><i>The process of switching from one process to executing is called context switch. We are switching the context and by that we are switching everything, the memory.. hardware etc..</i></div><div><i><br /></i></div><div><i>Lets say we have process p1 running and p2 is ready. Some point in time, p1 may volunteer&nbsp;to relinquish&nbsp;the CPU. That is a system pause (eg.).</i></div><div><i>Every process is selfish and want to finish.</i></div><div><i>One reason that p1 want to stop is because it wants to wait for data or p2 interrupt.&nbsp;</i></div><div><br /></div><div><i>When interrupt, the process scheduler is invoked.&nbsp;</i></div><div><i><br /></i></div><div><i>(Preemption)</i></div><div><i><br /></i></div><div><i>P1's context is saved and stored somewhere before p2 is runned.</i></div><div><i><br /></i></div><div><u>Context switch involves saving everything is relevant into some data structure and loading the next process's screenshot.</u></div><div><br /></div><div><u><br /></u></div><div><b>Generic 5 state process model</b></div><div><b>&nbsp;</b><u>Insert 48</u></div><div><u><br /></u></div><div>This is a textbook model but is not generally used.</div><div><br /></div><div><b>New</b></div><div>- New process created</div><div>- Might be initialising</div><div><br /></div><div><br /></div><div><b>Ready</b></div><div>- waiting to run</div><div><br /></div><div><b>Running</b></div><div>Process being executed on CPU by scheduler&nbsp;</div><div><i>Scheduler decideds on which component is run.</i></div><div><i>&nbsp;How many process is running is defined by CPU component.</i></div><div><i><br /></i></div><div>Running -&gt; Ready</div><div>Can be voluntarily or involuntarily.</div><div><br /></div><div><br /></div><div><b>Blocked</b></div><div>Process waiting for event (Sleeping)</div><div>Cannot execute until event is available</div><div>We CANNOT go from blocked state to running, we need to go ready.</div><div>The process will wait to be picked up by the scheduler.</div><div><br /></div><div><i>Maybe we are waiting for some input or data (ie user io),</i></div><div><i>the process will not occupy the CPU while it is blocked and let other process to continue.</i></div><div><br /></div><div><b>Terminated</b></div><div>Can be terminated at any point, gracefully or forcefully.</div><div>May require OS cleanup</div><div><br /></div><div><br /></div><h3>State transition (5 stage model)</h3><div><b>Create (nil-&gt; new)</b></div><div>- New process is created</div><div><br /></div><div><b>Admit(New-&gt; ready)</b></div><div>- Process is ready to scheduled for running</div><div><br /></div><div><b>Switch(ready-&gt; running)</b></div><div>- Process selected to run</div><div><b><br /></b></div><div><b>Switch(Running-&gt; ready)</b></div><div>-Process gives up CPU voluntarily or preempted by scheduler</div><div><br /></div><div><b>Event wait(Running-&gt;blocked)</b></div><div>- Process request event/resrouces/service that is not availbale in prgress</div><div>ie syscall, waiting for io</div><div><b><br /></b></div><div><b>Event Occurs(Blocked-&gt;ready)</b></div><div>- Event occurs, process can continue</div><div><br /></div><div><br /></div><div>Given n process, with one cpu, less than one or equal process can be in running states, one transition at a time</div><div>With m cpu, less or equal to one process in running state and possibly parallel transition</div><div><br /></div><div><i>Transisioning in their own time.</i></div><div><br /></div><div><b>Queuing theory</b></div><div>Represent the process when it is admitted, goes into the queue.</div><div>When process released the CPU, it can either go into block, return to queue or terminate.</div><div>The block itself is a queue.</div><div><br /></div><div><u>Insert 54</u></div><div><u><br /></u></div><h2>Process table and Process control block</h2><div>PCB is used for storing the context of the process.&nbsp; (or PTE)</div><div>The kernel maintains PCB of all processes.</div><div><br /></div><div>Issues:<br />Scalability - How many concurrent process can we have?</div><div>Efficiency - Minimum space wastage</div><div><br /></div><div><u>Insert 57</u></div><div><u><br /></u></div><div>The process block have</div><div>- GPR<br />- Memory Info</div><div>- PID</div><div>- Process state</div><div><br /></div><div><i>This include memory mappings on where the memory space of the processes are.</i></div><div><i>They are often linked in with different data structures.</i></div><div><i><br /></i></div><h3>System call</h3><div>API to OS</div><div>- Provides ways of calling facilities and services in kernal (e.g talking to hardware)</div><div>- Not the same as normal function call</div><div>( Have to change from user mode to kernel mode)</div><div><br /></div><div><i>There are less restriction in kernel&nbsp;mode.</i></div><div><br /></div><div>- Majority of syscalls have a lib version with same name and parameters.</div><div>This is call the function wrapper.</div><div>e.g getPID()</div><div><br /></div><div>- There are few lib function that present a more user friendly version to programmer, this is a function adapter (Lesser para, more flexible para values)</div><div>e.g Printf -&gt; write</div><div><br /></div><div>- No wrapper</div><div>Direct&nbsp;</div><div>long syscall (.....)</div><div><br /></div><h3>General system call mechanism</h3><div>1. User prog invokes the lib call</div><div>2. Lib call places the sys call number in a location thats desinated</div><div>e.g reg</div><div>3. Lib call exe a special inst to switch from user mode to kernal mode</div><div>This is called TRAP or syscall.</div><div><i>This instruction depends on the architecture.</i></div><div>4. In jernal mode, the appropriate sys call hadnle is determine</div><div>5. Sys call handler is executed</div><div><i>We cannot directly call the function, we need a wrapper or interface to allow us to move to the kernal mode to exe the code in the syscall. The prog cannot directly invoke the kernel mode.</i></div><div>6. Sys call handler ended</div><div>7. Lib call return to user program</div><div><br /></div><div>User Mode:</div><div><i>Get pid will set up syscall num, call trap.</i></div><div><i>We put the number if the call into some register and execute instruction (ie syscall)</i></div><div><i>Most of the time it is in register 17</i></div><div><i><br /></i></div><div><i><br /></i></div><div><i>Kernel mode:</i></div><div><i>Dispatcher can be done is software or hardware. It can lead directly to syscallhandler which perform the task.</i></div><div><br /></div><div><i>User Mode:<br />return back&nbsp;</i></div><div><i>The value is intact</i></div><div><i><br /></i></div><div><i><br /></i></div><div><i>The boundary of the kernel and user mode is crossed only by hardware ensure that no user program fcan run something that is priveldge (System security)</i></div><div><i><br /></i></div><h2>Exceptions and Interrupt</h2><div>Executing a machine level instruction can cause exception</div><div>(ie, stack overflow, division by 0)</div><div><br /></div><div>Exception is synchoronous</div><div>- Occurs during program execution</div><div><br /></div><div>Effect of exception:</div><div>- An exception handler is executed automatically</div><div>- Similar to a forced function call</div><div><br /></div><div>Asynchronous is more complex to handle as it can happen anytime</div><div><br /></div><h3>Interrupt</h3><div>External events can interrupt execution of program</div><div><br /></div><div>Usually hardware related:</div><div>- Timer, mouse movement, keyboard press</div><div><br /></div><div>(Find out what is TRAP/EXCEPTION/INTERRUPT)</div><div><u>Interrupt is asynchoronous</u></div><div>- Happen anytime</div><div><br /></div><div><b>Handler</b></div><div>1. save register/cpu state</div><div>2. Perform handler routine</div><div>3. Restore</div><div>4. Return from interrupt</div><div><br /></div><div>Might behave as if nothing happen</div><div><br /></div><div><i>What if there is a memory data that is on route when suddenly, an interrupt of the highest priority appears.&nbsp; What does the OS do?</i></div><div><i>The operating system cannot be involve with the implementation of the&nbsp;instruction.</i></div><div><i>(it cannot control if the OS get dropped)</i></div><div><i>A software cannot copy data between hardware buffers, nor drop</i></div><div><i><br /></i></div><div>Interrupt e.g</div><div><br /></div><div>There is an interrupt vector table.&nbsp;</div><div>lets say there is some instruction at PC and we want to load this memory into register,&nbsp;</div><div>The stack will go downwards.</div><div><br /></div><div>lets say instruction load reg1, memA</div><div>3 byte</div><div>1. Code for load</div><div>2. Register number</div><div>3. Address for memA</div><div><br /></div><div>There are multiple hardware steps:<br />1) Read one byte from address found in PC</div><div>Put byte into temporary register (IR), increment PC by one</div><div>2) Decode and realised it is a load, it needs an address</div><div>3) Read two more bytes&nbsp;</div><div>Increment the PC by 2</div><div>4) Read the source operands</div><div>The actual execution of the instruction</div><div>&gt;Interrupt!!!&lt;</div><div>5) Ignore interrupt and perform ALU operation</div><div>6) Store result into dest operand</div><div>Interrupt pending</div><div>7) Check if there is any interrupt pending (software)</div><div>no? Go step 1</div><div>yes? Serve the interrupt</div><div><br /></div><div><i>We are not serving the interrupt at "anytime" but only at step 7, when the current instruction is being served finished.</i></div><div><i><br /></i></div><div><b>Handling steps</b></div><div>1. PUSH status register</div><div>2. PUSH PC</div><div>3. Disrupt interrupts in status register</div><div>4. Read interrupt vector table entry</div><div>Check where is the address of interrupt</div><div>5. PC&lt;- ISR1&nbsp;</div><div>Jump there</div><div>6. ISR1 execution</div><div>Call function, go back to reading byte</div><div><br /></div><div>(Step 1-5 is hardware, 6 is software)</div><div><br /></div><div><b>ISR1 execution</b></div><div>1. PUSH (reg to be modified)&nbsp; [software]</div><div>2. Optionally enable interrupt (all or some) [software]</div><div>depending on priority</div><div>3. Do the necessary stuff</div><div>Allow modify the push register</div><div>4. POP (Modified reg)</div><div>5.IRET&nbsp;</div><div>specialised return from interrupt instruction</div><div>- pop status reg</div><div>- pop pc, return the main code</div><div><br /></div><h2>UNIX Case study</h2><div>1) fork()</div><div>Create a new process, a copy of the same process but it is a child.</div><div>The child and the parent are in the same state so it continues.</div><div><br /></div><div>WHY?<br />- The only difference between child and parent is the return value of fork</div><div><u>In parent, the fork returns the ID but the child returns 0.</u></div><div><br /></div><div>Bth parent continue executing after fork()</div><div>Common usage is to use the parent/child process differently</div><div>e.g Parent spawn child to carry out some work</div><div>e.g Parent is ready to take another order</div><div><br /></div><div>result = fork() //the result is 0, then u are a child, else u are parent</div><div>If we use an if/else we can&nbsp; determine who is child and seperate the code accordingly</div><div><br /></div><div><b>Independent memory space</b></div><div><b><br /></b></div><div>IF we declare</div><div>int var =1234</div><div>and we do fork(),</div><div>var has it's own memory space rather than sharing the same.</div><div><br /></div><div><u>Different address space</u></div><div><u><br /></u></div><div><u><br /></u></div><div><b>Executing a new program/image</b></div><div>Fork() itself is not useful, we still need provide the full code for the child process.</div><div>We can make use of the exec() system calls family to execute another existing program.</div><div>One program to invoke the other. Exec replaces the process it is running with whatever you are running.<br /><br /><h3>Fork() + Exec()</h3><div>Let me create a new parent/process and then create a copy. Replace the child with some other process. My parent can then wait for child to finish.</div><div><i>The parent is responsible for the child cleanup.</i></div><div><i><br /></i></div><h3>The master Process</h3><div>- Every process have parent</div><div>- What is the last ancestors? - INIT</div><div><br /></div><div>- Special init:<br />&nbsp; &nbsp;- init process</div><div>&nbsp; &nbsp; - PID = 1</div><div>&nbsp; &nbsp;- Created in kernal at bootup time</div><div>&nbsp; &nbsp;- Watches other processes</div><br /><i>In the process tree, init is in the top of the hierachy and below it is other OS processes.</i></div><div><br /><h3>Process Termination in UNIX</h3><div>Return value will be return to the hierachy ontop.</div><div>We can always do echo ? to get the return value of the latest prog we execute</div><div><br /></div><div>The function does not return!</div><div><br /></div><h3>Process on Exit</h3><div>- Release most system resourccs on exit</div><div>- Some are not releasable</div><div>e.g PID, status (parent-child sync)</div><div>&nbsp; &nbsp; &nbsp; Process accounting info (CPU time)</div><div><br /></div><h4>Implicit exit()</h4><div>In main, it will implicitly calls exit()</div><div>- Open files get flushed</div><div><br /></div><div>0 - normal term</div><div>0! - to indicate problematic execution</div><div><br /></div><h3>Parent child Synch</h3><div>Parent create child A, it then can</div><div>- Wait for it to terminate&nbsp;</div><div>(If parent call wait, wait will wait for the child to finish and it gives a opportunity to sync with the child)</div><div>- Wait returns the PID of terminated child</div><div><br /></div><div><b>Behavior</b></div><div>- The call is blocking</div><div><br /></div><div><br /></div><div>1. Call fok</div><div>2. Call exec to replace child's code</div><div>3. Some point the child exit</div><div><br /></div><div>e.g what if the parent say wait after creating?</div><div>- The parent will get block</div><div>- When child finishes, the parent will continue</div><div><br /></div><div>e.g What if parent does not call wait when child finish</div><div>- Child process has already terminated</div><div>- It still remains present as a zombie process / Orphan</div><div>- No one to clean up</div><div>- Parent has not clean wait</div><div>- It will assign a new parent to the child</div><div>- It will demaster process</div><div>- This is to clean up the child</div><div><br /></div><div><b>Wait()</b></div><div>- One process exit: Becomes zombie</div><div>- Cannot kill something that is already killed</div><div><br /></div><div><b><u>INsert slide 23</u></b></div><br /></div><div><i><u><b>Insert slide 27</b></u></i><br /><i><u><b><br /></b></u></i><h3>Process state diagram in UNIX</h3></div><div>Fork() -&gt; Creates ready process</div><div>- Kicks current process or current process is suspended (block)</div><div>- send signal that it can be ready</div><div><br /></div><div>Why can't it go from suspended to ready: Other process might be running</div><div><br /></div><div>Scheduler looks at ready queue.</div><div><br /></div><div>Stop state -&gt; Linux can send a signal to process to stop it</div><div><br /></div><h2>Implementation Issues</h2><div>Memory region info:<br />- text</div><div>- data</div><div>- Heap</div><div>- Stack</div><div><br /></div><div>When doing a fork, they will create a PCB2 which clone the memory (replicated)<br />But because we call exec(), this memory that was replicated is thrown away (Not good)<br /></div><div>1. Create address space for child process</div><div>They have to be isolated</div><div>2. Allocated pointer to new PID</div><div>PID of child is different to parent</div><div>3. Create kernel process data structure</div><div>3. Copy kernel environment of parent process</div><div>5. Init child process context</div><div>6. Copy memory regions from parent</div><div>Code, data, stack</div><div>This is very expensive</div><div>7. Aqurieds shares resoruces</div><div>e.g Open files and dir</div><div>8. Init hardware context</div><div>Copy reg</div><div>9. Child can run now</div><div><br /></div><div><br /></div><h3>Memory operation copy</h3><div>Why are we copying these memory space if we are not going to use it? (child)<br />But it is not guaranteed that we will call exec after fork.</div><div>These are two system calls and are independent.</div><div><i>How do i deal with this problem of wastefully calling operation.</i></div><div><i><br /></i></div><div>The child is not able to access the whole memory range right away.</div><div>They do not need the data.</div><div><i>Perhaps we can trick the child? Trick the child that it is its own data but actually it is not.</i></div><div><i><br /></i></div><div>-&gt; The data is the same until someone modify something&nbsp;</div><div><br /></div><h4>Copy on write</h4><div>- Duplicate a memory location when it is written to</div><div><i>IF i have a parent data, and i want to copy the child data but do not actually want to copy. I want the child pointer to point to the same location. I am going to share this obj until one of them tries to modify. ONLY then, they will have individual copies.</i></div><div><i><br /></i></div><div>This is to make fork a lightweight process</div><div><br /></div><div>Note:<br />- Memory is org into mem pages</div><div>- Mem is manage on page level&nbsp;</div><div><br /></div><h2>Modern Take on fork</h2><div>Fork() is like clone but modern</div><div>A clone can create a copy of process without copying the entire address space</div><div>- Can decide what to share (key or stack)</div><div>This is useful when we create something lightweight (e.g Thread)</div><div><br /></div><div>Fork() is a wrap around for clone.</div><div>However, it is not versatile</div><div><br /></div><div><br /></div><div><br /></div><div><i>Lets say that we have a timer that generates an interrupt at some period,</i></div><div><i>when we said sleep(), it will be woken up by interrupt</i></div><div><i>Only if certain time</i></div><div><i>Someone needs to take care on when sleep is called, need to wake up</i></div><div><i><br /></i></div><div><i><br /></i></div><div><i>there is a sleeping queue that stores all the sleep queue process.</i></div><div><i>When interrupt is called, how to know which process to wake up without going through the entire queue</i></div><div><i><br /></i></div><div><i>We can create a following list,</i></div><div><i>sleep 100 - 20 - 30</i></div><div><i><br /></i></div><div><i>for the call:<br />sleep(100)</i></div><div><i>sleep (120)</i></div><div><i>sleep(130)</i></div><div><i>The following store the relatives from the first sleep call.</i></div><div><i>When the timer interrupt comes, we check the first one.</i></div><div><i>This structure works for processes that are waiting for some timer.</i></div><div><i><br /></i></div><div><i><br /></i></div><div>Wait vs Sleep</div><div><i>If we use wait, we are waiting for one of our child process to finish.</i></div><div><i>Sleep waits for sometime to pass</i></div><div><i><br /></i></div><div>How does fork relate to sleep queue</div><div><i>It is not, It is about the block process.&nbsp;</i></div><div><i><br /></i></div><div>Segmentation fault:</div><div>It is a generic fault.&nbsp;</div><div>Once you are done with the fault, it usually go back to the original instruction</div><div>It is a fault when you access the address that you did not have access.</div><div>The OS will not allow you to continue.</div><div><br /></div><div><br /></div><div><i><br /></i></div>