---
layout: post
title: 'CS2100: Encoding / Instruction Format'
date: '2019-09-05T02:07:00.002-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-09-25T00:39:26.642-07:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-8010734367249663798
blogger_orig_url: https://nusmods.blogspot.com/2019/09/cs2100-encoding-instruction-format.html
---

Why is addi only take 3 instruction?<br /><br /><h3>Encoding</h3><div><span style="color: red;">Each mips instruction is a fixed length of 32 bits</span>. Each register that is in letters will be translated into numbers from 0-31 (32 register). We need 5 bits for the register.<br /><br /><br /><div>Opcode -&nbsp; Specifies the instruction</div><div>funct - Combine with opcode to specify the inst more</div><div>rs - source register</div><div>rt - target</div><div>rd - destination</div><div>shamt - amount a shift instruction will shift by</div></div><div><br /></div><h4>R format</h4><div>(Register format: op $r1, $r2, $r3)</div><div>Use 2 source register, 1 destination register (3 Reg)</div><div>e.g add, sub, and, or ,nor, slt</div><div>Special : srl,sll</div><div><br /></div><div><span style="color: red;">Fields:</span></div><div><span style="color: red;">6/5/5/5/5/6</span></div><div><span style="color: red;">opcode/rs/rt/rd/shamt/funct</span></div><div><br /></div><div>add $8, $9,$10</div><div>add rd,rs,rt</div><div><br /></div><div>for sll, the shamt would contain the number of bits needed to shift (not 2 complements)<br />e.g 2=&gt; 00010</div><div><br /></div><h4>I Format</h4><div>(Immediate format: op $r1,$r2, immd)</div><div>Use 1 source, 1 immediate and 1 destination register<br />Its partially consistent with R format.</div><div>e.g addi<br /><br />For LW/SW,<br />LW $t0, 0($s1)<br />For LW/SW with 0($s1), the 0 is the immediate and $s1 is source register, $t0 is rt</div><div><br /></div><div><span style="color: red;">Fields:</span></div><div><span style="color: red;">6/5/5/16</span></div><div><span style="color: red;">opcode/rs/rt/immediate</span></div><div><br />addi $21, $22, -50<br />op rs, rt , immd (2s)<br />8&nbsp; &nbsp;22&nbsp; 21&nbsp; -50<br /><br />For load word, the offset is stored in the immediate.<br /><br />We can observed that everytime we multiply by 4 we will end up with 2 zeros and since the instructions are word aligned hence are in multiples of 4, we do not need to store the last two zeros<br />Now we can handle loops 4 times larger.<br />The computer would automatically add the 2 0s when it reads the immediate. Thus immediate can be stored as a 2^17 due to the extra 0s<br /><br /><b>Finding Hexadecimal representation&nbsp;of I format</b><br />1. Convert opcode<br />2. Convert source/target register based on register number (not values stored)<br />e.g &amp;t8 -&gt; 24(decimal) in binary<br />3. Convert immediate to 2 complements<br />4. Put them together<br /><br /></div><h4>J Format&nbsp;</h4><div>(Jump format: op immd)</div><div>J instruction uses only one immediate value<br />J can jump to anywhere in memory therefore we must have the entire 32 bit.<br />Similar to I format, we can assume the last two bits to be gone and due to consistency with all the address ending with 2 0s.<br /><br /></div><div><br /></div><div><span style="color: red;">Fields</span></div><div><span style="color: red;">6/26</span></div><div><span style="color: red;">opcode/target address</span><br /><span style="color: red;"><br /></span><span style="color: red;">Optimization:</span><br /><span style="color: red;">There is only 26 bits left so we can optimise to 28 by ignoring the last 2 bits due to consistency of all address ending with 2 0s.</span><br /><span style="color: red;"><br /></span><span style="color: red;">For the missing front 4 bits, it is taken from the PC, the address first byte. (Most sig 4 bits of PC)</span><br /><span style="color: red;">2^28 is 256 MB, thus we can only jump within 256 MB range (128MB up/down)</span><br /><span style="color: red;">Special instruction is needed if we want to jump outside this boundary. (JR instr)</span><br /><span style="color: red;"><br /></span><span style="color: red;"><br /></span><b>Finding target address</b><br />1. Check the first 4 bit, if they share then we can encode.<br />2. Add 2 0s<br />3. Take the rest of the 26 bits and put it into the immediate (target address)<br /><br /><b>Finding hexadecimal representation of Jump Instruction</b><br />Assuming we have address of jump instruction<br /><br />1. Count number of instruction from jump instruction physically<br />2. Convert address of Jump instruction to binary<br />3. Remove 2 0s at the back<br />4. Add/Subtract the number of jumps from Jump instruction address<br />-&gt;this is to get target address<br />5. Remove first 4 bits<br />6. Add opcode of jump<br />7. Convert back to Hex<br /><h3><span style="color: red;">Instruction address</span></h3><br />Instruction has memory address also<br /><div><span style="color: red;">Each memory instruction is 4 byte, that's why the difference between memory address is always 4 bytes.<br /></span></div><b>Program counter</b><br />A register that keeps address of instruction being executed in processor<br />After every instruction, it adds 4 bytes. Instructions are 32 bits long (word align).<br /><br /><b>Branching</b><br />beq $9,$0 ,loop<br /><br />The loop label is an address.<br />But the immediate is only 16 bits but our memory address is 32 bits.<br />(Not enough)<br /><br />A branch changes the PC by a small amount. So we will specify target address relative to the PC.<br /><br />Target address = PC + 16 bit imme field (can be -ve or +ve depending on direction)<br />Forward is positive, backwards is negative<br />Calculating the number of instruction:<br />[+-]2^15 bytes (Immediate size)/ 4 bytes (size of one instruction) = number of instruction between jumps<br /><br /><b>Enlarging it</b><br />We can observed that everytime we multiply by 4 we will end up with 2 zeros and since the instructions are word aligned hence are in multiples of 4, we do not need to store the last two zeros<br />Now we can handle loops 4 times larger<br /><br />Only branches interpret the immediate as bytes.<br /><br /><b>Address calculation (LW/SW/BNE/BEQ/J)</b><br /><b><br /></b><b>Only for Branching:</b><br />If branch is not taken (condition not pass):<br />PC = PC +4<br />PC + 4&nbsp; = address of next instruction<br />else if branch is taken<br />pc = (pc +4) + (imm *4)<br /><br /><br /><b>Counting relative:</b><br />Immediate field (Downwards):<br />1. Move one instruction forward<br />2.&nbsp; Start counting from the next<br /><br />Loop: beq $9, $0,&nbsp; END<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; add ...&nbsp; &nbsp; &nbsp; &nbsp; &lt;-&nbsp; (1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addi .....&nbsp; &nbsp; &nbsp; +1 (2)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j loop&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +2<br />END:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +3<br /><br />OPCODE: 4<br />RS: 9<br />RT:0<br />Imme: 3<br /><br />Immediate field (Upwards):<br />1. Count from myself<br />2.&nbsp; Start counting from the next<br /><br />Loop: beq $9, $0,&nbsp; END&nbsp; &nbsp; &nbsp;-4<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; add ...&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-3<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addi .....&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; beq $0,$0 loop&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-1&nbsp; (2)<br />END:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;- (1)<br /><br /><br /><br /><br /><br /><br /><br /><br /><span style="color: red;"></span><span style="color: red;"><br /></span><span style="color: red;"><a href="https://nusmods.blogspot.com/2019/09/cs2100-mips-memory-and-branch.html">&lt; Prev&nbsp;</a> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="https://nusmods.blogspot.com/2019/09/cs2100-processor-data-path.html">Next&gt;</a></span></div><div><br /></div><div><br /></div>