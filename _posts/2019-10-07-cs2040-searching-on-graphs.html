---
layout: post
title: 'CS2040s: Searching On Graphs'
date: '2019-10-07T22:10:00.000-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-10-23T03:22:07.972-07:00'
thumbnail: https://1.bp.blogspot.com/-FriQsHqjDcA/XbAAijwjtEI/AAAAAAAACN4/xL95JVERzhEJaqUY9I59nhM_U8Wm2yYDgCLcBGAsYHQ/s72-c/1.PNG
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-5278304741317749945
blogger_orig_url: https://nusmods.blogspot.com/2019/10/cs2040-searching-on-graphs.html
---

<h2>Searching.. Graph Edition</h2><div>Goals:</div><div>Starting at some vertex s and find some other vertex f (finish)</div><div>Visit all nodes in the graph</div><h2>Techniques</h2><h3>Breadth first Search (BFS)</h3><div>Explore level by level.</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-FriQsHqjDcA/XbAAijwjtEI/AAAAAAAACN4/xL95JVERzhEJaqUY9I59nhM_U8Wm2yYDgCLcBGAsYHQ/s1600/1.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="344" data-original-width="375" height="292" src="https://1.bp.blogspot.com/-FriQsHqjDcA/XbAAijwjtEI/AAAAAAAACN4/xL95JVERzhEJaqUY9I59nhM_U8Wm2yYDgCLcBGAsYHQ/s320/1.PNG" width="320" /></a></div><br /></div><div><br /></div><div>Always moving forward in the frontier (wave)</div><div>Initial = {s}</div><div>Do not go backwards&nbsp;</div><div><u><span style="color: red;">=&gt; <b>Find the shortest path</b></span></u></div><div><br /></div><div><b>Uses a Queue</b></div><div><br /></div><div>We keep looking at the neighbours at selected nodes at once each time we advance</div><div>Label the visited.</div><div><br /></div><div><span class="fontstyle0">BFS(G, s, f)<br />&nbsp; &nbsp; visit(s)<br />&nbsp; &nbsp; Queue.add(s)</span><br /><span class="fontstyle2">&nbsp; &nbsp; while not </span><span class="fontstyle0">Queue.empty()<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr = Queue.dequeue()</span><br /><span class="fontstyle2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if </span><span class="fontstyle0">curr == f</span><br /><span class="fontstyle2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return </span><span class="fontstyle0">curr</span><span class="fontstyle2">&nbsp;</span><br /><span class="fontstyle2">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for each </span><span class="fontstyle0">neighbor u of curr<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if u is </span><span class="fontstyle2">not </span><span class="fontstyle0">visited<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;visit(u)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Queue.enqueue(u)</span><br /><span class="fontstyle2">return </span><span class="fontstyle0">null</span>&nbsp;&nbsp;</div><div><br /></div><div>1. Run BFS&nbsp;</div><div>2. Start from s, put s in queue</div><div>3. Check if queue is empty else end</div><div>4. Not empty? =&gt; take out first node =&gt; curr<br />5. If curr is final, return curr<br />else</div><div>6. Look at the neighbours of curr,<br />if not visited, mark them as visited and add them in queue<br />else continue to next neighbour<br />7. go back to 3<br /><br />BFS will not work in an unconnected graph.</div><div><br /></div><div>The queue is use to add each frontier and pop each time we search the frontier's neighbours</div><div>During the execution, we explored the frontier level by level. We first explore the neighbours then explore our neighbours neighbour</div><div><br /></div><div><span style="color: red;"><b>BFS will fail in a &gt;1 Component&nbsp;</b></span></div><div>=&gt; BFS works by searching neighbours, &gt;1 component is an unconnected graph</div><div><br /></div><div><b><span style="color: red;">Running time of BFS? (Assume adj List) is O(V + E)</span></b></div><div>=&gt; Each vertex added once O(V) and for each node,&nbsp; we list the neighbours only once O(E)<br /><br /><div><b><span style="color: red;">Running time of BFS? (Assume adj matrix) is O(V^2)</span></b></div><div>=&gt; Looking through each neighbour takes v time, visiting is v</div></div><h3>Depth first Search (DFS)</h3><div>Look at at one path till reach dead end,<br />then we backtrack until reach an unexplored neighbour</div><div>Recursively explore till finish is found</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-Z5Q5wkrVZwI/XbAEnrAg-II/AAAAAAAACOE/I8057IWGVfkXYN0L4oGZ6JfGIbffSwKnQCLcBGAsYHQ/s1600/2.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="270" data-original-width="292" src="https://1.bp.blogspot.com/-Z5Q5wkrVZwI/XbAEnrAg-II/AAAAAAAACOE/I8057IWGVfkXYN0L4oGZ6JfGIbffSwKnQCLcBGAsYHQ/s1600/2.PNG" /></a></div><br /></div><div><u>Uses a Stack</u></div><div><br /></div><div><span class="fontstyle0">DFS</span><span class="fontstyle0" style="color: black;">(G, s, f)<br />&nbsp; &nbsp; visit(s)</span><br /><span class="fontstyle0">&nbsp; &nbsp; Stack.push(s)</span><br /><span class="fontstyle2">&nbsp; &nbsp; while not </span><span class="fontstyle0">Stack.empty()</span><br /><span class="fontstyle0" style="color: black;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;curr = </span><span class="fontstyle0">Stack.pop()</span><br /><span class="fontstyle2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if </span><span class="fontstyle0" style="color: black;">curr == f</span><br /><span class="fontstyle2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return </span><span class="fontstyle0" style="color: black;">curr</span><br /><span class="fontstyle2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for each </span><span class="fontstyle0" style="color: black;">neighbor u of curr<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if u is </span><span class="fontstyle2">not </span><span class="fontstyle0" style="color: black;">visited<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;visit(u)</span><br /><span class="fontstyle0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Stack.push(u)</span><br /><span class="fontstyle2">&nbsp; &nbsp; &nbsp;return </span><span class="fontstyle0" style="color: black;">null</span>  <br /><span class="fontstyle0" style="color: black;"><br /></span><span class="fontstyle0" style="color: black;"><br /></span><span class="fontstyle0" style="color: black;"><br /></span></div><div>1. Start from s, visit s</div><div>2. Store s in stack<br />3. while stack is not empty, else end<br />4. Pop stack, curr<br />5. If curr is finish, return curr<br />else<br />6. For each neighbour of curr,<br />if not visited =&gt; visit, push to stack<br />else =&gt; continue</div><div>If reach dead end (ie. all neighbours are visited), go backwards by polling the stack.<br />(Backtrack till find one path that was not taken yet by checking neighbours not visited)</div><div>7. Go back to 3</div><div><br /></div><div><span style="color: red;"><b>Running time of DFS (Adj List) is O(V+E)</b></span></div><div>=&gt; The algo is the same as BFS except the data structure. Each vertex is added one and for each vertex we enumerate the neighbours</div><div><br /></div><div>Recursion:</div><div><span class="fontstyle0"><br /></span></div><div><span class="fontstyle0">DFS(G, v, f)<br />&nbsp; &nbsp;visit(v)</span><br /><span class="fontstyle2">&nbsp; &nbsp; if </span><span class="fontstyle0">v == f<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return v</span><br /><span class="fontstyle2">&nbsp; &nbsp; for each </span><span class="fontstyle0">neighbor u of v<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if u is </span><span class="fontstyle2">not </span><span class="fontstyle0">visited<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;w = DFS(G, u, f)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if w is </span><span class="fontstyle2">not null</span><br /><span class="fontstyle0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return w</span><br /><span class="fontstyle2">&nbsp; &nbsp; &nbsp; return </span><span class="fontstyle0">null</span>&nbsp;&nbsp;</div><div><br /></div><div>1. Visit the v<br />2. Check if v is f, return if is<br />3. check all neighbours of v<br />not visited =&gt; DFS recursively<br />if w not null, return w<br />4. Go back to 3</div><div><br /></div><div><b><u>Both DFS and BFS visit every node and every edge once, not every path</u></b></div><div><br /></div><h3>Storing the Path</h3><div>To store the path we just need to add one line for DFS</div><div>Save the parent each time we iterate down</div><div><br />1. Store the parent in array<br />edgeTo[neighbour_unvisited] = curr<br /><br /></div><div>//check the path exist first<br /><br />Print path:</div><div><span class="fontstyle0">x = f</span><br /><span class="fontstyle2">while </span><span class="fontstyle0">(x != s)<br />&nbsp; &nbsp; path.pushFront(x)<br />&nbsp; &nbsp; x = edgeTo[x]&nbsp; &nbsp; <br />path.pushFront(s)</span>  <br /><span class="fontstyle0"><br /></span>Because the path is stored front back, we need to use this function to be in the correct order.<br /><span class="fontstyle0"><br /></span></div><h3>Shortest Path</h3><div>BFS Store the shortest path.</div><div>In DFS, we will find a possible path that we can encounter first</div><div>But for BFS, we will choose the possible path that each neighbour can bring simultaneously</div><div>(This is for unweighted graphs)</div><div><br /></div><div>We cannot search every path because it will take exponent time to search</div><div><br /></div><h2>Directed Acyclic Graph (DAG)</h2><div><b><span style="color: red;">Not every directed graph have a topological ordering =&gt; Cyclic graph</span></b><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-SPI7Uso2I6c/XbAJJncxMZI/AAAAAAAACOQ/Kxrn6ZqcpIAqzrJqiYLbBTtVC_BUqyiiACLcBGAsYHQ/s1600/3.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="351" data-original-width="632" height="177" src="https://1.bp.blogspot.com/-SPI7Uso2I6c/XbAJJncxMZI/AAAAAAAACOQ/Kxrn6ZqcpIAqzrJqiYLbBTtVC_BUqyiiACLcBGAsYHQ/s320/3.PNG" width="320" /></a></div><br /></div><div><div style="-webkit-text-stroke-width: 0px; color: black; font-family: &quot;Times New Roman&quot;; font-size: medium; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-decoration-color: initial; text-decoration-style: initial; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px;"><div style="margin: 0px;">Input:&nbsp;</div><div style="margin: 0px;">- An adjacency list (DAG)</div><div style="margin: 0px;"><br /></div><div style="margin: 0px;">Output:</div><div style="margin: 0px;">A list of nodes in topological order</div></div></div><div>A topological ordering is possible only with DAG</div><div><br /></div><div><h3>KAHN's Algorithm</h3></div><div><br /></div><div>1. Start with a node v with no incoming edges<br />2. Add v to list</div><div>3. Remove v and its outgoing edges</div><div>4. repeat 1</div><div><br /></div><div><span class="fontstyle0">L = list()<br />S = list()<br />add all nodes with no incoming edge to S<br />while S is not empty:<br />&nbsp; &nbsp; remove node v from S<br />&nbsp; &nbsp; add v to tail of L<br />&nbsp; &nbsp; for each of v’s neighbors u<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove edge e where source is v //remove edges<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if u has no other incoming edges //(1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; add u to S</span>&nbsp;&nbsp;</div><div><br /></div><div>This is similar to BFS because we move the frontier forward</div><div><span style="color: red;"><b>Time complexity (adj-list): O(V+E)</b></span><br /><span style="color: red;"><b>=&gt; O(v) add all nodes with no incoming edges to s</b></span><br /><span style="color: red;"><b>=&gt; O(E) loop through all the nodes in S</b></span></div><h3>Topological sort using DFS (Assume DAG)</h3><div><u>Process node when it is last visited</u></div><div>We could use the hashset to check visited nodes<br />Use this only for topological.</div><div><br />Base idea:<br /><br /></div><div>1. Start from any path (run DFS)</div><div>=&gt; Set the last node in that path as prev node</div><div>=&gt; There is no outgoing edges for this node<br />2. Back track from the prev node<br />=&gt; Pick any other unvisited node before</div><div>3.repeat<br /><br /><br /><br /><span class="fontstyle0">L = list()<br />while there are unvisited nodes<br />&nbsp; &nbsp; &nbsp;v = select unvisited node<br />&nbsp; &nbsp; &nbsp;DFS(G, v, L)</span><br />//this is to get the last node<br />====================<br /><span class="fontstyle0">DFS(G,v,L)</span><span class="fontstyle1">&nbsp; &nbsp;if </span><span class="fontstyle0">v is visited</span><span class="fontstyle1">&nbsp; &nbsp; &nbsp; return<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; for each </span><span class="fontstyle0">of v’s neighbor u<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DFS(G, u, L)<br />&nbsp; &nbsp; &nbsp;visit(v)<br />&nbsp; &nbsp; &nbsp;L.pushFront(v)</span><br /><br />1. If v is visited, return<br />else<br />2. Check every v neighbours and DFS it<br />3. Visit v<br />4. Add to list front</div><div><br /></div><div><b style="color: red;">Time complexity: O(V+E)</b><br /><b style="color: red;">=&gt; DFS</b><br /><b style="color: red;">=&gt; Visit each node once, enumerates the edges</b></div><div><b style="color: red;"><br /></b></div><div><b style="color: red;">Is Every topological ordering unique: No</b></div><div>=&gt; We can swap certain place<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-B23BTKrUnT8/XbAXU93qI9I/AAAAAAAACOc/RFhFBxUS-DMS68g3xIawPyux1KG0q2R3gCLcBGAsYHQ/s1600/4.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="442" data-original-width="1527" height="185" src="https://1.bp.blogspot.com/-B23BTKrUnT8/XbAXU93qI9I/AAAAAAAACOc/RFhFBxUS-DMS68g3xIawPyux1KG0q2R3gCLcBGAsYHQ/s640/4.png" width="640" /></a></div><br /><br /></div><div><br /></div><div><br /></div>