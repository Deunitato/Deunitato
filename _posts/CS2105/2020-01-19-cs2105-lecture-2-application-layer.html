---
layout: post
title: 'CS2105: Lecture 2 - Application Layer'
date: '2020-01-19T23:41:00.003-08:00'
author: Charlotte Deunitato
tags: 
modified_time: '2020-02-05T23:35:33.405-08:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-2823427189795004291
blogger_orig_url: https://nusmods.blogspot.com/2020/01/cs2105-lecture-2-application-layer.html
---

<h2>Previously on avatar....</h2><h3>Packet switching: Store and forward</h3><div>Information is chopped into small pieces called a packet.&nbsp;</div><div>Routers need to receive all the packet before being able to forward to the next router</div><div><br /></div><h3>Internet protocol stack</h3><div>An abstraction and seperation of the different layers and function of internet protocol</div><div><br /></div><h2>Principles of network applications</h2><h3>Creating a network app</h3><div>Write programs that&nbsp;</div><div>- run on different end system</div><div>- Communicates over network</div><div>e.g web server software, browser software</div><div><br /></div><div>Theres no need to write software for network core devices</div><div>-Allow rapid application development</div><div><br /></div><div><i>Softwares are running on end systems/hosts, thus we do need to write the software on network core&nbsp;</i></div><div><i>devices</i></div><div><i><br /></i></div><div><i>However, they have to talk to each other over the network.</i></div><div><i>e.g Web server software talking to browser software</i></div><div><i>to download infomation.</i></div><div><i><br /></i></div><div><i>The network core is only in the network layer, theres no need to worry about it in the application layer. Network core are like routers and switches</i></div><div><i>An upper layer is implemented by using the service by the layer below it, thus the application layer just have to use the service that is provided by the transport layer.</i></div><div><i>We can use the service by choosing the service type provided</i></div><div><i><br /></i></div><h3>Client server architecture</h3><div>Server</div><div>- Always on host</div><div>- Permanent IP address</div><div>- Data centers for scaling</div><div><br /></div><div>Clients:</div><div>- Communicate with server</div><div>- May be intermittently connected</div><div>- May have dynamic IP address</div><div>- Do not communicate directly with each other</div><div><br /></div><h3>Peer to peer architecture</h3><div>There is very minimum or no servers at all. The peers are allowed to talk to each other.</div><div>Advantages:<br />- Self scalable</div><div>More user that join, can automatically provide the information and service</div><div>So the demands is scalable</div><div><br /></div><div><br /></div><div>Disadvantages:<br />- Management is complex due to the changes of IP address</div><div><br /></div><h3>Process communicating</h3><div>Process: Program running within a host.</div><div>- Within same host, two process communicate using inter-process communication (OS)</div><div>- Process in different host communicate by exchanging message</div><div><br /></div><div>Client process: Initiate</div><div>Server: Waits to be contacted</div><div>EXTRA: application with p2p archi have client processes and server processes</div><div><br /></div><h3>Sockets</h3><div>- Process sends and receives message to and from its sockets</div><div>- Process relies on transport infrastructure on other side of the door to deliver message to socket at receiving process</div><div><br /></div><h3>Addressing processes</h3><div>- To receive message, process have identifier</div><div>- Host device have 32 bit IP address</div><div>- An identifier includes both IP address and port numbers associated with the process&nbsp;</div><div><br /></div><div><i>A host is like a building, we need to specify which apartment to send the letter</i></div><div><i><br /></i></div><h3>Transport Service</h3><div>- Data integrity</div><div>Data transfer must be reliable (for some apps)</div><div>Apps such as audio can tolerate some loss</div><div><br /></div><div>- Throughput</div><div>Some apps need minimum amount of throughput to be effective (e.g multimedia)</div><div>Some apps do not need, like email, it is okay to be delayed by 3 seconds</div><div><br /></div><div>- Timing</div><div>Some apps require low delay to be effective (e.g interactive games)</div><div><br /></div><div>- Security</div><div>encryption, data integrity</div><div><br /></div><div><br /></div><div><i><u>Insert slide 13</u></i></div><div><i><br /></i></div><div><i>It is very hard to have it all, we only need&nbsp;</i></div><div><i><u><br /></u></i></div><h3>Internet transport protocol service</h3><div><b>TCP</b></div><div>- Reliable transport</div><div>- Flow control</div><div>- Congestion control</div><div>- No timing, minimum throughput and security</div><div><b><br /></b></div><div><b>UDP</b></div><div>- Unreliable data transfer</div><div>- No congestion, security, connection setup</div><div><br /></div><div><i>UDP is more faster in setting up a connection as it does not need two sides to agree to have a connection. However, security is not under transport layer. UDP Is cheaper</i></div><div><i>UDP has a chance to lose packets so its better to use it for video. If the reliability is not needed strictly, there is no need to pay for TCP.</i></div><div><i><br /></i></div><div><i>Firewalls filter most UDP traffic, thus most internet providers use TCP</i></div><div><i><br /></i></div><div><i><u>Insert 15</u></i></div><div><i><u><br /></u></i></div><h3>App layer protocol</h3><div>- Types of message exchange</div><div>Request and response</div><div><br /></div><div>- Message syntax</div><div>what fields in message and how fields are delineated</div><div>The format</div><div><br /></div><div>- Message semantics</div><div>Meaning of information</div><div><br /></div><div>- Rules</div><div>The behavior, how and when process send and response to messgae</div><div><br /></div><div><br /></div><div><b>Types of protocol</b></div><div>- Open protocols</div><div>Defined by RFC(public)</div><div>e.g HTTP, SMTP</div><div><br /></div><div>- Proprietary protocols</div><div>e.g Skype</div><div><br /></div><div><br /></div><h2>Web and HTTP</h2><div>Web page consist of objects such as HTML file, JPEG image, Java applet, Audio file etc</div><div>The web page consist of base HTML files which included several reference objects</div><div>Each object is addressable by a URL</div><div><br /></div><div>e.g www.someschool.edu/someDept/pic.gif</div><div>&nbsp; &nbsp; &nbsp; ( Host name&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ) (&nbsp; &nbsp; &nbsp; path name&nbsp; &nbsp; )</div><div><br /></div><h3>HTTP overview</h3><div>Is a web application layer protocol.</div><div>Follows the client server model</div><div>Client: Browser that request and receivers using the HTTP protocols and shows the web objects</div><div>Servers: Sends the objects in response to request from client</div><div><br /></div><div><i>They must be running on the same protocol in order for them to understand each other, it does not have to be develop by you. Web server can send back the objects in response to the request of the client.</i></div><div><i>It defines the behavior and the rules.</i></div><div><i><br /></i></div><h4>Uses TCP</h4><div>- Clients initiate TCP connections (create socket)</div><div>- Server accepts TCP connection from client</div><div>- HTTP messages&nbsp;</div><div>- TCP connection closed</div><div><br /></div><div>HTTP is stateless, server maintains no info about past clients request</div><div><i>Keeping of information to maintain state is complex as if server or client crashes, their views of the state may be inconsistent.</i></div><div><i>It is stateless because we relied on TCP already which is reliable. TCP itself must be stateful.</i></div><div><br /></div><h3>HTTP connections</h3><h4>Non Persistent HTTP</h4><div>At <u>most one object</u> send over TCP connection, connection then close.</div><div>Downloading multiple objects require multiple connection</div><div><br /></div><div>e.g A user enters the URL,&nbsp;</div><div>1. the HTTP client initiates TCP connection to HTTP server (Process) at the server url at port&nbsp;</div><div>2.Once the HTTP accepts connection, it notify the client</div><div>3.The Client sends the HTTP request message into the TCP connection socket, asking from the client the object it wants to download</div><div>4. HTTP servers recieves request, forms response containing requested objects and sends message to its socket, server then close the TCP connection</div><div>5. HTTP client gets responses, and unpackage the file by parsing.</div><div><br /></div><div><br /></div><div>RTT:</div><div>Time for a small packet to travel from client to server and back</div><div><br /></div><div>HTTP response time:<br />One RTT to init TCP connection</div><div>Once it is confirm connected, then you send the file</div><div>In response the server will transfer the file to you depending on the size of the file.</div><div>Bigger file = more packets send</div><div>It will close the connection once it is done.</div><div><br /></div><div>The response time is = 2RTT + file transmission time</div><div><br /></div><div><br /></div><div><b>Persistent HTTP</b></div><div>- <u>Multiple objects</u> can be sent over single TCP connection between client and server</div><div><br /></div><div>Servers leaves connection open after sending response</div><div>Subsequent HTTP message between same client/server sent over open connection</div><div>Client sends request as soon as it encounters a reference object</div><div><br /></div><div>The response time = one RTT for all reference objects</div><div>(Only need to open once to get the objects)</div><div><br /></div><div><i>Persistent might be more efficient for user point of view but for server, if everyone use persistent, the server might be overloaded and might cause DOS attacks. (Denial of service)</i></div><div><i><br /></i></div><div><i>Protocols and states are stored in hosts.</i><br /><i><br /></i><i>v1.1 - persistent</i><br /><i>v1.0 - non persistent&nbsp;</i><br /><i>Can specify to change</i></div><div><br /></div><h3>HTTP Request Message</h3><div>Only two types: request and response</div><div>These are the message being sent by the server/client for HTTP</div><div>Format: <u>Insert 27</u></div><div>1. Method/Command</div><div>(GET/POST/HEAD)</div><div>2. What you want get</div><div>3. Version</div><div>4. Headerlines</div><div>Under connection, it defines if its persistent or non persistent</div><div>Host: Specify where the web server is. This is because the message might not be send directly to the webserver itself (web proxy)</div><div>For GET method, the body might be empty.</div><div>For POST method, we need to submit certain request to the server thus the body might not be empty.&nbsp;</div><div>e.g do a form or to do a search request.</div><div></div><h3>Uploading form input</h3><div><b>POST</b></div><div>- Webpage often includes form input</div><div>- Input is uploaded to server in entitiy body</div><div><br /></div><div><b>URL</b></div><div>- GET method</div><div>- INput is uploaded in URL field request line</div><h3>Method types</h3><div><b>HTTP/1.0</b></div><div>- GET</div><div>- POST<br />-HEAD</div><div>Default: Non persistent</div><div><br /></div><div><b>HTTP/1.1</b></div><div>-GET, POST, HEAD</div><div>- PUT</div><div>upload file in entity body to path specified in URL</div><div><br /></div><div>- DELETE</div><div>delete file specified in URL field</div><h3>HTTP response message</h3><div>1. Status line</div><div>- Version</div><div>- Protocol status code status phase</div><div><br /></div><div>2. Header line</div><div>- Date</div><div>- Server</div><div>- Modified last</div><div>- Connection</div><div><br /></div><div>3. Data requested</div><h3>HTTP response status codes</h3><div>Status code appears in 1st line in server to client response message</div><div>Sample codes:<br /><u>Insert 31</u></div><div><br /></div><h3>Cookies</h3><div>Cookies keep track of certain states for our client. (Since HTTP is stateless)</div><div>Many website use cookies. Cookie is initiated by server.</div><div><br /></div><div>1) Cookie header line of HTTP response message</div><div><br /></div><div>2) Cookie header line in next HTTP request message</div><div><br /></div><div>3) Cookie file kept on user's host, managed by user's browser</div><div>Cookie is kept in the local memory, the browser. Whenever the client wants to make another request with the same host, it will include the cookie so the server will know which client it is.</div><div><br /></div><div>4) Back-end database at website</div><div>Server keep all the cookies in their own local database so they can keep track of their browsing history. Keeps the ID</div><div>A new user will have a new cookie created.</div><div><br /></div><div><i>This sending of cookie allow the server to be able to keep track of the client search history and behavior so that they can provide better service for the client.</i></div><div><i>Cookies can be use to provide authentication, maintain shopping carts, recommendation, user session state.</i></div><div><i><br /></i></div><div><i>This is nothing to do with the protocol but the work of the cookie which allow the server to know who is the client. Cookies permit sites to learn a lot about us. (Privacy)</i></div><div><i>Cookie is built in network edges.</i></div><h3>Web Caches (Proxy Server)</h3><div>Goal: To satisfy client request without involving origin server.&nbsp;</div><div>When we use hTTP request, it might not be send directly to the server but to a proxy server provided by our service provider.&nbsp;</div><div>- The first time, the server will act like a client and submit a request to the origin server</div><div>- The proxy server will then store the content in its local memory, acting like a cache layer.</div><div>- When there is a second time, the proxy server will directly reply to the client without contacting the origin server.&nbsp;</div><div>- There is a possibility of a cache miss, which requires the proxy server to look at the origin server.</div><div>It is much faster to get info from the Proxy server rather than making multiple request to the original</div><div>server</div><div><br /></div><div><b>Conditional GET</b></div><div>Sometimes the cache is not up to date with the actual.</div><div>HTTP request: If-Modified-since: &lt;Date&gt;</div><div><br /></div><div>Cache: Specify the date of the copy in HTTP request</div><div>Server: Response contains no object if cache copy is up to date</div><div><br /></div><div>Server will send new content if its not up to date with the cache version,</div><h2>DNS: Domain Name System</h2><div>Used as identifiers for internet host.</div><div>- IP address use for addressing</div><div>- "name" use by humans</div><div>e.g yahoo.com</div><div><br /></div><div>This service is provided by DNS which is built at the application layer.</div><div>The mapping is provided by a hierarchy of many name servers which provide a central database.</div><div><br /></div><h3>Local DNS Name server</h3><div>Host makes a DNS query and its sent to its local DNS server.</div><div>&nbsp; &nbsp; - local cache of recent name to address translation pairs&nbsp;</div><div>&nbsp; &nbsp; - acts as proxy</div><div>Does not strictly belong to hierarchy.<br />It is implement by multiple server.</div><div><br /></div><div><b>Hierarchical Database of DNS</b></div><div>Note: is the right to left in reading URL<br />1. Root</div><div>The source of the entire directory.<br />The first point to be contacted when we cannot resolve the name<br />There are over 400 servers all over the world<br /><i>Root servers do not have an actual mapping.&nbsp;</i><br /><br /></div><div>2. Organization/Institution (Authoratative servers)<br />- Edu/Org/UK<br /><br /><i>The org will own these servers so that when outside ppl contact them, they will provide the actual mapping between host name and ip address.</i><br /><i>But if we are end user that one to publish our own website, the our website is our own authorative servers.</i><br /><br /></div><div>3. More specific<br /><br /><br /><h3>DNS Name Resolution Example</h3><div><i>Suppose a host at cls.poly.edu. wants to access the website of gia.cs.umasss.edu</i></div><div><i>It does not know the ip address of that host</i></div><div><i>It makes a local dns request to the dns server of that host</i></div><div><i>The local, lets say it does not have a mapping, it will contact one of the root server that it knows.</i></div><div><i>It returns an ip address&nbsp;of a top level dns server which takes care of the edu domain.</i></div><div><i>The local dns server will further&nbsp;contact the top level dns server</i></div><div><i>The top lelvel dns server take care of all so it does not know the detailed details but it return a mapping of an authoritative&nbsp;server that knows the mapping</i></div><div><i>The local dns server will make a query to that authoritative&nbsp;server&nbsp;that will return the ip address of the host that the client wants.</i></div><div><i><br /></i></div><div><i>&lt;<b><u>Insert slide 44&gt;</u></b></i></div><div><i><b><u><br /></u></b></i></div><div>Iterative query: Do not return the correct address but give you another server's ip address to contact (Immediatery contact)</div><div><br /></div><div>This local dns server will finally get the ipaddress and return to the client.</div><div>IF the root dns server is serving the recursive manner, even if it does not know, it will help the local dns server to make a query to the authorative server.</div><div><br /></div><div>ie. Each server will make a request for the server one level on top if it does not know what the response is.&nbsp;</div><div><i><br /></i></div><h3>DNS: Caching, updating record</h3><div>When client makes request and obtain the final answer, they will keep the answers in a cache. When other clients want to make similar request, it can just retrieve from the cache immdiately.&nbsp;</div><div><br /></div><div><b>Out of date</b></div><div>The host names can change however, the cache could be outdated. For DNS, they will use a time to lift value (TTL =2 days), after that the content might be obselete so the cache will be deleted.</div><div><br /></div><div><b>By passing the high level domain service</b></div><div>The top level domain service are often cache in local dns such that when dns do not know the mapping, they do not have to go to the root but just go directly to the highere level domain servuce,</div><div>(By pass the need to go to root)</div><div><br /></div><div><br /></div><div><br /></div><br /></div><div><br /></div>