---
layout: post
title: 'CS2100: Cache '
date: '2019-10-01T02:49:00.000-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-11-12T21:31:12.321-08:00'
thumbnail: https://1.bp.blogspot.com/-Jihu2UK3knM/Xcp_ZnsMFNI/AAAAAAAACQo/eUyc6g0rF-s9hJnksTD61xukdlsYIAiPgCLcBGAsYHQ/s72-c/2.png
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-498315398092089808
blogger_orig_url: https://nusmods.blogspot.com/2019/10/cs2100-cache-direct-mapped.html
---

<br /><h2><span style="font-size: x-large;">CACHE</span></h2><h2>Direct Mapped</h2><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-Jihu2UK3knM/Xcp_ZnsMFNI/AAAAAAAACQo/eUyc6g0rF-s9hJnksTD61xukdlsYIAiPgCLcBGAsYHQ/s1600/2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="509" data-original-width="770" height="211" src="https://1.bp.blogspot.com/-Jihu2UK3knM/Xcp_ZnsMFNI/AAAAAAAACQo/eUyc6g0rF-s9hJnksTD61xukdlsYIAiPgCLcBGAsYHQ/s320/2.png" width="320" /></a></div><br /></div><div><br /></div><div><h3>Non-volatile Memory</h3><div>- Storage that maintain information even without power</div><div>- ROM (Read - only memory)</div><div>- Store persistent information like file</div></div><h3>Volatile</h3><div>- Loses information when electrical power is interrupt</div><div>- RAM (Random Access Memory)</div><div>- Main storage of Process Memory discussed</div><div><br /></div><div><b>Dram</b></div><div><b><br /></b></div><div><b>- </b>Stores a single Bit</div><div>- High density</div><div>- Can pack a lot together to form many bits</div><div>- Access latency is very slow</div><div>- Energy consuming due to recharging of battery often as the memory will decay</div><div>- Delivers memory on positive and negative edge of a clock</div><div><br /></div><div>=&gt;We have a memory problem where the CPU would want more memory than the memory can give it.</div><div><br /></div><div><b>Sram</b></div><div><b><br /></b></div><div>- 6 transistors per memory cells</div><div>- Low density</div><div>- Fast Latency access (0.5 - 5 ns)</div><div><br /></div><div><b>Slow Memory: Magnetic Disk</b></div><div><b><br /></b></div><div>- Super Slow<br />- Latency (4-10ms)</div><div><br /></div><h3>Quality vs Quantity</h3><div>Components:<br />- Hard disk</div><div>- Memory (Dram)</div><div>- Register</div><div><br /></div><div>- Big fast memory</div><div>- 1GB&nbsp;</div><div>- Access 1ns time</div><div><br /></div><div>Key concept:</div><div>Use one whole hierarchy of memory technolgy</div><div>-&gt; Fast next to CPU</div><div>-&gt; Larger further away from CPU</div><div><br /></div><div>We will use cache for CPU (SRAM)<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-Cho37ieDmZc/XcqA5lBfB9I/AAAAAAAACQ0/2UNfAFSElHMXn-suuFmKC45ZLv4AliCNwCLcBGAsYHQ/s1600/3.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="504" data-original-width="881" height="366" src="https://1.bp.blogspot.com/-Cho37ieDmZc/XcqA5lBfB9I/AAAAAAAACQ0/2UNfAFSElHMXn-suuFmKC45ZLv4AliCNwCLcBGAsYHQ/s640/3.png" width="640" /></a></div><br /></div><div><br /></div><h3><b>Cache</b></h3><div><b><br /></b></div><div>- Keep the frequent and recently use data in the SRAM</div><div>- Access the bigger one only if you can't find it in the SRAM<br /><br /></div><div><b>Principle of Locality</b></div><div>- Program access only a small portion of the memory address space within a small time interval</div><h4>Temporal Locality</h4><div>When reference, the item tend to be reference again soon</div><div>e.g variables like int i, loops</div><div><br /></div><div><b>Spatial locality</b></div><div><b><br /></b></div><div>When reference, will tend to reference the nearby memory</div><div>e.g Arrays access, instructions</div><div><br /></div><div><b>Usage and Terminology</b></div><div><br /></div><div>1. Processor check if data in cache</div><div>2. Cache hit: Found data in cache</div><div>&nbsp; &nbsp; &nbsp; &nbsp;- Data is return to processor from cache</div><div>&nbsp; &nbsp; &nbsp; &nbsp;- Fast</div><div>&nbsp; &nbsp; Cache Miss:&nbsp; Data not in cache</div><div>&nbsp; &nbsp; &nbsp; &nbsp;- Data is loaded from memory</div><div>&nbsp; &nbsp; &nbsp; &nbsp;- Large chunk is loaded for future references</div><h3>Cache Mapping</h3><div><b>Cache Block/line</b></div><div>- Unit of transfer between memory and cache</div><div>Block size is typically more than 1 word (4 bytes)</div><div>16 byte block = 4 word block</div><div>32 byte = 8 word block</div><div><br /></div><div>When we transfer, we classify each word in blocks and transfer it. If we need one byte in one word, we transfer the entire block.</div><div><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-DKM60s1T5Lc/XcqEJA7mnyI/AAAAAAAACRA/MmMg0Ngp5ZY9xQ_Q8mc0mj4hCGlUoqZDgCLcBGAsYHQ/s1600/4.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="578" data-original-width="988" height="233" src="https://1.bp.blogspot.com/-DKM60s1T5Lc/XcqEJA7mnyI/AAAAAAAACRA/MmMg0Ngp5ZY9xQ_Q8mc0mj4hCGlUoqZDgCLcBGAsYHQ/s400/4.png" width="400" /></a></div><br /><br /></div><div><u>To find which block the byte is in:</u></div><div>byte(10) divide by 8</div><div>or byte(2) right shift 3</div><div><br /></div><div><u>To find where the byte is in the block:</u></div><div>The last 3 digits in the binary of the byte number (the memory starts from 0)</div><div><br /></div><h4>Direct Mapping</h4><div>Do round robin to map to SRAM</div><div>Each time do from 0 to 3</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-J9UBg_Q7P5c/XcqEfSYO0YI/AAAAAAAACRI/1LioA0MCYlMbRL_PxpqS3lVqoLcYh8cvQCLcBGAsYHQ/s1600/5.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="556" data-original-width="969" height="228" src="https://1.bp.blogspot.com/-J9UBg_Q7P5c/XcqEfSYO0YI/AAAAAAAACRI/1LioA0MCYlMbRL_PxpqS3lVqoLcYh8cvQCLcBGAsYHQ/s400/5.png" width="400" /></a></div><br /></div><div><br /></div><div>Cache index (dec) = blockNum(dec) % (numberOfCacheBlocks)<br />Cache index (bin) = blockNum&nbsp;last (numberOfCacheBlocks) bits</div><div><br /></div><div>The number of cache blocks = 2^m where m is the last m bits of the block number is the cache index</div><div><br /></div><div><b>Unique&nbsp;identifier</b></div><div><b><br /></b></div><div>We need to know which memory is inside the cache, using a unique tag number that can identify which block is which<br /><br /></div><div>tag = blockNumber/NumberofCacheBlocks</div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-vwNjvPY-_iY/XcqFcjkvjdI/AAAAAAAACRU/cyuwIZur2yYJh7ooZarHVxTcclxTkGgbwCLcBGAsYHQ/s1600/6.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="516" data-original-width="569" height="290" src="https://1.bp.blogspot.com/-vwNjvPY-_iY/XcqFcjkvjdI/AAAAAAAACRU/cyuwIZur2yYJh7ooZarHVxTcclxTkGgbwCLcBGAsYHQ/s320/6.png" width="320" /></a></div><br /></div><div>Cache contains:</div><div>1. Tag of memory block further identifies the memory in cache</div><div>2. Valid bit indicating whether the cache line contains loaded data</div><div><br /></div><div>Cache hit: 6.&nbsp;</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-ieJ2x8kUvWs/XcqFv1Tw-OI/AAAAAAAACRc/XVr2XRleIp8tztE0_JmCqqBz_5LEsBOOACLcBGAsYHQ/s1600/7.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="136" data-original-width="720" height="60" src="https://1.bp.blogspot.com/-ieJ2x8kUvWs/XcqFv1Tw-OI/AAAAAAAACRc/XVr2XRleIp8tztE0_JmCqqBz_5LEsBOOACLcBGAsYHQ/s320/7.png" width="320" /></a></div><br /></div><div><br /></div><div>Cache-&gt; 16KB</div><div>Memory -&gt; 4GB</div><div><br /></div><div>1 Block = 16 bytes</div><div><br /></div><h3>Memory load Instruction</h3><div><b>LOAD</b></div><div>Given a&nbsp;</div><div>lw $t0, 0($0)</div><div>The 0($0) is Mem Access</div><div><br /></div><div>1. Check index field</div><div>2. Go to index number and check if the location matches what we are trying to look for, Check valid</div><div>3. Check the tag ensure its the correct memory block<br />4. Cache miss if any of condition fails and cache hit if condition met.</div><div><br /></div><div>CACHE MISS</div><div>5. If its a cache miss,&nbsp;</div><div>- this a cold compulsory miss if it's the first time we are looking at it</div><div>- Conflict if it was there before but was replaced.</div><div>6. Load 16 byte from the memory, the last 4 bits is empty because we are loading the cache boundary</div><div>7. Load 4 words and return the word the register asking for by using the offset</div><div>e.g offset -&gt; 0100 -&gt; drop last two bits -&gt; 01 -&gt; load word 1</div><div>8. Set the valid to 1</div><div>9. Set tag</div><div><br /></div><div>CACHE HIT</div><div>5. Return the word to register by converting the offset</div><div>e.g offset -&gt; 1100 -&gt; drop last two bits -&gt; 11 -&gt; load word 3</div><div><br /></div><div>But if we have a cache miss and there is a value in the blocks, we will do cache eviction.</div><div><br /></div><div><br /></div><div><b>STORE (Write Policy)</b></div><div>Modified data in cache but not in memory.</div><div><br /></div><div><b>Write through&nbsp;Cache</b></div><div>Write data both to cache and main memory (Parallel)</div><div><br />Problem: Operate same speed as main memory<br />Solution: We will use a buffer called write buffer to run together<br /><div>Processor: Write data to cache and main memory</div><div>Memory controller: Write contents of buffers to memory</div><br /></div><div><b>Write back Cache</b></div><div>Write to cache only<br />Only write to memory when evicted</div><div>Problem: There will be a large memory overhead if all blocks evicted is replacement<br />Solution:</div><div>Use Dirty Bit to check if its being changed (extra bit), only write back to memory when dirty bit is 1</div><div><br /></div><div><br /></div><div><b>Handling Cache Misses (Store into address)</b></div><div>It is not inside the cache but we want to write it. Loading it again might evict previous and it will take some time to load it.</div><div>We do not need to see the previous value.</div><div><br /></div><div><b>Write allocate&nbsp;</b></div><div>Load the complete block to cache</div><div>Change only the require word in cache</div><div>Follow write policy</div><div><br /></div><div><b>Write around&nbsp;</b></div><div>Do not load the block to cache</div><div>Write directly to main memory only</div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-iLCrCArdSMA/XcqKD63zMsI/AAAAAAAACRo/O_kDCxRCuxIrnIQauFAVIRnpz5GgYZgZQCLcBGAsYHQ/s1600/8.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="538" data-original-width="830" height="258" src="https://1.bp.blogspot.com/-iLCrCArdSMA/XcqKD63zMsI/AAAAAAAACRo/O_kDCxRCuxIrnIQauFAVIRnpz5GgYZgZQCLcBGAsYHQ/s400/8.png" width="400" /></a></div><br /></div><div><br /></div><div><br /></div><div><h2>Set Associative and Fully Associative</h2></div><h3>Cache Performance</h3><div>Hit: Data is in cache</div><div>Miss: Data is not in cache</div><h4>Quantifying it:</h4><div>Hit rate: Fraction of mem address that hit</div><div>Hit time: Time to access Cache</div><div><br /></div><div>Miss rate: 1- hit rate</div><div>Miss penalty: Time to replace cache block + deliver data (stop when we go back to processpr)</div><div><br /></div><div><u>Average Access time = hit rate * hit time + (1-hitRate) * miss penalty</u></div><div><br /></div><div>This will get the average performance of our system.</div><div><br /></div><div>E.g</div><div>Suppose:</div><div>SRAM =0.8ns access time (Cache)</div><div>DRAM = 10ns access time (mem)</div><div>How high a hit rate we need to sustain avg access time of 1ns?</div><div><br /></div><div>1ns = 0.8*H + (1-H) * 10</div><div><br /></div><h3>Type Of Misses</h3><h4>Compulsory/Cold Miss&nbsp;</h4><div>Access the memory the first time.</div><div>Very hard to avoidable.</div><div><br /></div><div><i>Solution 1: Make the block size bigger so we have a largest range.</i></div><div>- Reduce miss rate</div><div>- Takes longer time to bring it to the cache (miss penalty will increase)</div><div>- Too few cache block space thus miss rate will go up eventually due to conflict miss.&nbsp;</div><div><br /></div><div>Conclusion: Its useful for earlier but eventually miss rate will be the same.</div><div><br /></div><h4>Conflict miss</h4><div>Wanted memory was previously in cache but was replaced by another memory.<br />Beware because it might not be a conflict miss if I access the memory even if it is the same location. [Lecture video - 8/10]</div><div><br /></div><div><i>Solution 1: N way Set associative</i></div><div>Give more slots per set that starts with a certain&nbsp;</div><div>Memory block can be place in a fixed number of location (N&gt;1) in cache</div><div>- Multiple duplication&nbsp;</div><div>- Memory block maps to an unique sets</div><div>- Search: search all n location within the set</div><div>- For same cache size, conflict miss goes down with increasing associativity<br /><br /></div><div>e.g 2 way set associative cache&nbsp;</div><div>there are 2 cache blocks in one set. Any mem block can be map into either of the cache blocks</div><div><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-txVAwc2rs7M/XcuKLVj2A0I/AAAAAAAACR0/UsHAb6pYeIssmG8sNLq5-gcUS3Dnsh3sACLcBGAsYHQ/s1600/9.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="579" data-original-width="854" height="270" src="https://1.bp.blogspot.com/-txVAwc2rs7M/XcuKLVj2A0I/AAAAAAAACR0/UsHAb6pYeIssmG8sNLq5-gcUS3Dnsh3sACLcBGAsYHQ/s400/9.png" width="400" /></a></div><br /><br /></div><div>Each block contains<br />- block number<br />- offsets<br />- set index (The set index is used to determine which duplicate to place the memory in)</div><div>There are now unique number of sets.</div><div><br /></div><div><br /></div><div>Given the memory<br />N = offset in bits<br />M = set index</div><div>1. Check the number of blocks&nbsp; = 2^ block number, block number = 32 -&nbsp; N</div><div><br /></div><div>2. No. of cache blocks = No. of bytes in cache/ No. bytes per block<br />e.g&nbsp; Cal number of cache blocks = cache / 4<br /><br /></div><div>3. No. of Sets =&nbsp; No. of cache blocks/No. of ways</div><div>e.g No. of cache block/4<br /><br /></div><div>4. Get set index by putting the No. of sets to 2^M<br />where M is set index.<br /><br /></div><div>5. Cache tag = 32 - M - N</div><div><br /></div><div>Advantages:</div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-51ecmgTJ2AY/XcuNQAtL-RI/AAAAAAAACSA/COqI86BSnQ0NoECLQvcJW15PB8aWPfrvACLcBGAsYHQ/s1600/10.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="406" data-original-width="620" height="209" src="https://1.bp.blogspot.com/-51ecmgTJ2AY/XcuNQAtL-RI/AAAAAAAACSA/COqI86BSnQ0NoECLQvcJW15PB8aWPfrvACLcBGAsYHQ/s320/10.png" width="320" /></a></div><br /></div><div><br /></div><div>Rule Of Thumb:</div><div>A direct mapped cache of size N has about the same miss rate as a 2 way set associative cache n/2</div><div>(On avg)</div><div><h3>Memory Load Instruction -&nbsp; Set associative</h3></div><div>1. Look at valid and tag valid</div><div>2. Bring block into cache and favor the first block</div><div>3. Set the tag and valid</div><div>4. Load from M[n] and M[n+4]<br />5. Depending on offset, if the msb is<br />1 - load to w1&nbsp;</div><div>6. Can load the content to processor</div><div><br /></div><div>Solution 2: Fully Associative cache</div><div>The memory block can go to any location in the cache as long as there's space</div><div>- Searching is difficult (Search for everyblock)</div><div>- Conflict miss is 0</div><div><br /></div><div>Since there's no indication, the tag is the entire block number.&nbsp;</div><div><br /></div><div><b>Capacity Miss (only for FA)</b></div><div><b><br /></b></div><div>The cache is smaller than the memory so we will run out of space eventually.</div><div>cache space &lt; memory space</div><div>- For same cache size, Capacity miss remains the same irrespective of associativity</div><div>- Capacity miss decreases with increasing cache size.</div><div><br /></div><div><br /></div><div><u><i><b>Total miss = cold miss + conflict miss + capacity Miss</b></i></u></div><div><u><i><b><br /></b></i></u></div><div><u><i><b>CAP Miss (FA) = total miss (FA) - Cold Miss(FA)</b></i></u></div><div><br /></div><div><br /></div><h3>Block Replacement Policy</h3><div>In SA and FA, we need to place a mem block.</div><div>- Which block to kick</div><div><br /></div><h4>LRU (Least recently used)</h4><div>- Check the one who is not been used recently</div><div>- Record the block that was accessed</div><div>- kick the one who was LRU</div><div>- Promote each time we use the value</div><div><br /></div><div>Issues:</div><div>- Hardware problem</div><div>- Hard to keep track if there are many block</div><div><br /></div><div><b>FIFO</b></div><div>- Kill the one who went in first</div><div>- Second chance variant<br />&nbsp; &nbsp;- Put it back if its used</div><div>&nbsp; &nbsp;- If two block is used, kill the older</div><div><br /></div><div><b>RR(Random replacement)</b></div><div>- Randomised</div><div><b><br /></b></div><div><b>LFU(Least frequently used)</b></div><div>- Killed off the one who was least used<br /><br /><h3>Cache Framework Summary:</h3><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-uaahomXFpN8/XcuU6MUs_KI/AAAAAAAACSM/o3vI7XJEEU0XVU7ztTI-J8ENaogD3xYzQCLcBGAsYHQ/s1600/11.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="540" data-original-width="862" height="250" src="https://1.bp.blogspot.com/-uaahomXFpN8/XcuU6MUs_KI/AAAAAAAACSM/o3vI7XJEEU0XVU7ztTI-J8ENaogD3xYzQCLcBGAsYHQ/s400/11.png" width="400" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-MQOEq3Vg0CE/XcuVAn1hyFI/AAAAAAAACSQ/CT--oOC-acQK-4RPxt7gDnA3V7lYC7WGQCLcBGAsYHQ/s1600/12.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="430" data-original-width="853" height="201" src="https://1.bp.blogspot.com/-MQOEq3Vg0CE/XcuVAn1hyFI/AAAAAAAACSQ/CT--oOC-acQK-4RPxt7gDnA3V7lYC7WGQCLcBGAsYHQ/s400/12.png" width="400" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div><br /></div><h2>Cache Mapping</h2></div><div><pre style="background-color: #eff0f1; border-radius: 3px; border: 0px; box-sizing: inherit; color: #242729; font-family: Consolas, Menlo, Monaco, &quot;Lucida Console&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, monospace, sans-serif; font-size: 13px; font-stretch: inherit; font-variant-east-asian: inherit; font-variant-numeric: inherit; line-height: inherit; margin-bottom: 1em; max-height: 600px; overflow-wrap: normal; overflow: auto; padding: 12px 8px; vertical-align: baseline; width: auto;"><code style="border: 0px; box-sizing: inherit; font-family: Consolas, Menlo, Monaco, &quot;Lucida Console&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, monospace, sans-serif; font-stretch: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; line-height: inherit; margin: 0px; padding: 0px; vertical-align: baseline; white-space: inherit;">C = cache capacity<br />b = block size<br />B = number of blocks<br />N = degree of associativity<br />S = number of set<br />tag_bits<br />set_bits (also called index)<br />byte_offset<br />v = valid bits</code></pre></div><div><pre style="background-color: #eff0f1; border-radius: 3px; border: 0px; box-sizing: inherit; color: #242729; font-family: Consolas, Menlo, Monaco, &quot;Lucida Console&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, monospace, sans-serif; font-size: 13px; font-stretch: inherit; font-variant-east-asian: inherit; font-variant-numeric: inherit; line-height: inherit; margin-bottom: 1em; max-height: 600px; overflow-wrap: normal; overflow: auto; padding: 12px 8px; vertical-align: baseline; width: auto;"><code style="border: 0px; box-sizing: inherit; font-family: Consolas, Menlo, Monaco, &quot;Lucida Console&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, monospace, sans-serif; font-stretch: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; line-height: inherit; margin: 0px; padding: 0px; vertical-align: baseline; white-space: inherit;">B = C/b<br />S = B/N<br />b = 2^(byte_offset)<br />S = 2^(set_bits)</code></pre></div><h3></h3><div><pre style="background-color: #eff0f1; border-radius: 3px; border: 0px; box-sizing: inherit; color: #242729; font-family: Consolas, Menlo, Monaco, &quot;Lucida Console&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, monospace, sans-serif; font-size: 13px; font-stretch: inherit; font-variant-east-asian: inherit; font-variant-numeric: inherit; line-height: inherit; margin-bottom: 1em; max-height: 600px; overflow-wrap: normal; overflow: auto; padding: 12px 8px; vertical-align: baseline; width: auto;"><code style="border: 0px; box-sizing: inherit; font-family: Consolas, Menlo, Monaco, &quot;Lucida Console&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Courier New&quot;, monospace, sans-serif; font-stretch: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; line-height: inherit; margin: 0px; padding: 0px; vertical-align: baseline; white-space: inherit;">|___tag________|____set___|___byte offset_|</code></pre></div>