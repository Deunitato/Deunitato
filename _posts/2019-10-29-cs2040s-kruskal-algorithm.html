---
layout: post
title: 'CS2040S: Kruskal Algorithm'
date: '2019-10-29T00:11:00.000-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-11-10T22:23:51.657-08:00'
thumbnail: https://1.bp.blogspot.com/-5_ZSRcCzGDE/XbgKBomB60I/AAAAAAAACQE/ibceXoLZ3KExvffcBxaNaqa3G0t5oKOCgCLcBGAsYHQ/s72-c/1.PNG
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-3163784049731879566
blogger_orig_url: https://nusmods.blogspot.com/2019/10/cs2040s-kruskal-algorithm.html
---

<h2>UFDS</h2><div>A data set that supports find and union.</div><div><br /></div><div>Union:</div><div>Replace the sets containing p and q with their union<br /></div><div>Find:<br />Check if p and q are same sets</div><div><br /></div><h3>Quick Find</h3><div>Using an integer array, assume that all object are integer label.</div><div>Each object is a node.</div><div>Label each obj with the component it belongs to<br />Tree is flat</div><div>[Insert im 12]</div><div><br /></div><div><span class="fontstyle0">find</span><span class="fontstyle1">(int </span><span class="fontstyle1" style="color: #7030a0;">p</span><span class="fontstyle1">, int </span><span class="fontstyle1" style="color: #7030a0;">q</span><span class="fontstyle1">)<br />return(</span><span class="fontstyle1" style="color: #7030a0;">componentId[p] </span><span class="fontstyle1">== </span><span class="fontstyle1" style="color: #7030a0;">componentId[q]</span><span class="fontstyle1">);</span>&nbsp;</div><div><br /></div><div><span style="color: red;"><b>Time complexity: O(1)</b></span></div><div><h3>Union</h3><div><br /></div><div><span class="fontstyle0">union</span><span class="fontstyle1">(int p, int q)<br />int s = componentId[q]</span><br /><span class="fontstyle1">for </span><span class="fontstyle1">(int i=0; i&lt;componentId.length; i++)</span><br /><span class="fontstyle1">&nbsp; &nbsp; &nbsp; if </span><span class="fontstyle1">(componentId[i] </span><span class="fontstyle1">== </span><span class="fontstyle1">s)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; componentId[i] </span><span class="fontstyle1">= </span><span class="fontstyle1">componentId[p];</span>&nbsp;&nbsp;</div><div><br /></div><div><br />Union(p,k)<br />e.g Union(1,4)<br /><br /></div>1. Look up component id of k<br />e.g s= 4 (object 4 = component identifier 4)<br /><br />2. Loop through all the items (object)<br />=&gt; Loop through 0 to 8<br /><br />3. Check all object's component id whose number is s,<br />Change it to the p's componentID<br />=&gt; change obj 4's component id to 1</div><div><span style="color: red;"><b>Time complexity: O(n)</b></span></div><div><span style="color: red;"><b><br /></b></span></div><h3>Quick Union</h3><div>Two things are connected if they are part of the same tree.</div><div>Instead of storing the component id, we store the parent.</div><div><br />Find checks if the two nodes belong in the same tree</div><div><b>Find</b></div><div><span class="fontstyle0">find</span><span class="fontstyle1">(int </span><span class="fontstyle1" style="color: #7030a0;">p</span><span class="fontstyle1">, int </span><span class="fontstyle1" style="color: #7030a0;">q</span><span class="fontstyle1">)<br />while (</span><span class="fontstyle1" style="color: #7030a0;">parent[p] </span><span class="fontstyle1">!= </span><span class="fontstyle1" style="color: #7030a0;">p) p = parent[p]</span><span class="fontstyle1">;<br />while (</span><span class="fontstyle1" style="color: #7030a0;">parent[q] </span><span class="fontstyle1">!= </span><span class="fontstyle1" style="color: #7030a0;">q) q = parent[q]</span><span class="fontstyle1">;<br />return (</span><span class="fontstyle1" style="color: #7030a0;">p </span><span class="fontstyle1">== </span><span class="fontstyle1" style="color: #7030a0;">q</span><span class="fontstyle1">);</span>&nbsp;</div><div><br /></div><div>Traverse upwards and compare root id if its the same.</div><div><br /></div><div><b><span style="color: red;">Time complexity: O(n)</span></b></div><div><b>=&gt; Worse case long chain</b><br /><b>=&gt; Trees may be too tall</b></div><div><br /></div><div><b>Quick Union</b></div><div><b><br /></b></div><div>Go all the way up to the root</div><div>Merge the tree by setting one of them to be a child of the other.</div><div><br /></div><div><span class="fontstyle0">union</span><span class="fontstyle1">(int </span><span class="fontstyle1" style="color: #7030a0;">p</span><span class="fontstyle1">, int </span><span class="fontstyle1" style="color: #7030a0;">q</span><span class="fontstyle1">)<br />while (</span><span class="fontstyle1" style="color: #7030a0;">parent[p] </span><span class="fontstyle1">!= </span><span class="fontstyle1" style="color: #7030a0;">p) p = parent[p]</span><span class="fontstyle1">;<br />while (</span><span class="fontstyle1" style="color: #7030a0;">parent[q] </span><span class="fontstyle1">!= </span><span class="fontstyle1" style="color: #7030a0;">q) q = parent[q]</span><span class="fontstyle1">;</span><span class="fontstyle1" style="color: #7030a0;">parent[p] </span><span class="fontstyle1">= </span><span class="fontstyle1" style="color: #7030a0;">q</span><span class="fontstyle1">;</span>&nbsp;&nbsp;</div><div><br /></div><div><b><span style="color: red;">Time complexity: O(n)</span></b></div><div><b><span style="color: red;">=&gt; Similar to find</span></b></div><div><b><span style="color: red;"><br /></span></b></div><h3>Weighted Union</h3><div>Ensure that the bigger tree become the main root such that when we union two trees, it won't increase the height by much.</div><div><br /></div><div>=&gt; Use size instead of heights</div><div><br /></div><div><span class="fontstyle0">union</span><span class="fontstyle1">(int </span><span class="fontstyle1" style="color: #7030a0;">p</span><span class="fontstyle1">, int </span><span class="fontstyle1" style="color: #7030a0;">q</span><span class="fontstyle1">)<br />while (</span><span class="fontstyle1" style="color: #7030a0;">parent[p] </span><span class="fontstyle1">!=</span><span class="fontstyle1" style="color: #7030a0;">p) p = parent[p]</span><span class="fontstyle1">;<br />while (</span><span class="fontstyle1" style="color: #7030a0;">parent[q] </span><span class="fontstyle1">!=</span><span class="fontstyle1" style="color: #7030a0;">q) q = parent[q]</span><span class="fontstyle1">;<br />if (</span><span class="fontstyle1" style="color: #7030a0;">size[p] </span><span class="fontstyle1">&gt; </span><span class="fontstyle1" style="color: #7030a0;">size[q] </span><span class="fontstyle1">{</span><br /><span class="fontstyle1" style="color: #7030a0;">&nbsp; &nbsp; parent[q] </span><span class="fontstyle1">= </span><span class="fontstyle1" style="color: #7030a0;">p</span><span class="fontstyle1">;</span><br /><span class="fontstyle1"></span><span class="fontstyle1" style="color: green;">// Link q to p</span><br /><span class="fontstyle1" style="color: #7030a0;">&nbsp; &nbsp; size[p] </span><span class="fontstyle1">= </span><span class="fontstyle1" style="color: #7030a0;">size[p] </span><span class="fontstyle1">+ </span><span class="fontstyle1" style="color: #7030a0;">size[q]</span><span class="fontstyle1">;<br />}<br />else {</span><br /><span class="fontstyle1" style="color: #7030a0;">&nbsp; &nbsp; &nbsp;parent[p] </span><span class="fontstyle1">= </span><span class="fontstyle1" style="color: #7030a0;">q</span><span class="fontstyle1">;</span><br /><span class="fontstyle1"></span><span class="fontstyle1" style="color: green;">// Link p to q</span><br /><span class="fontstyle1" style="color: #7030a0;">&nbsp; &nbsp; &nbsp;size[q] </span><span class="fontstyle1">= </span><span class="fontstyle1" style="color: #7030a0;">size[p] </span><span class="fontstyle1">+ </span><span class="fontstyle1" style="color: #7030a0;">size[q]</span><span class="fontstyle1">;<br />}</span>&nbsp;&nbsp;</div><div><br /></div><div><br />1. Iterate to root for both nodes<br />2. Compare size of both parents<br />3. Set the parent of the smaller node to the larger node<br />4. Update the size (small tree size + large tree size)</div><div><br /></div><div><b><span style="color: red;">Max height of a tree built using weighted union: O(logn)</span></b></div><div>=&gt; The overall height will increase if both merge tree is the same</div><div><br /></div><h4>Induction of Logn Property</h4><div>Base case:</div><div>Tree of height 0 contains 1 obj</div><div>Inductive:<br />Assume tree of size i has height of at most log i for all i &lt;= k</div><div><br /></div><div>1. Combine tree of size i with j where i &lt;= j</div><div>2. Tree is now size i+j</div><div>The new height of the tree is now bounded.</div><div><span class="fontstyle0">­ </span><span class="fontstyle2">Note that: </span><span class="fontstyle3">1 + log i = log 2i = log(i + i) ≤ log(i + j ) = log s&nbsp;</span></div><div><span class="fontstyle3"><br /></span></div><div><span class="fontstyle3">Conclusion:</span></div><div><span class="fontstyle3">Each tree of size n is of height at most logn</span></div><div><br /></div><div><b><span style="color: red;">Find Time complexity: O(logn)</span></b></div><div><b><span style="color: red;">Union Time complexity: O(logn)</span></b></div><div><b>=&gt; Trees are flatter</b></div><h3>Path Compression</h3><div>Idea: Flatten the tree after find</div><div>After finding the root, set the parent of each traverse node as the root.</div><div>[Insert image 81]</div><div><br /></div><div><span class="fontstyle0">findRoot</span><span class="fontstyle1">(int </span><span class="fontstyle1" style="color: #7030a0;">p</span><span class="fontstyle1">) {</span><br /><span class="fontstyle1" style="color: #7030a0;">root </span><span class="fontstyle1">= </span><span class="fontstyle1" style="color: #7030a0;">p</span><span class="fontstyle1">;<br />while (</span><span class="fontstyle1" style="color: #7030a0;">parent[root] </span><span class="fontstyle1">!= </span><span class="fontstyle1" style="color: #7030a0;">root</span><span class="fontstyle1">)</span><br /><span class="fontstyle1"></span><span class="fontstyle1" style="color: #7030a0;">root = parent[root]</span><span class="fontstyle1">;</span><br /><span class="fontstyle1" style="color: #3e8853;">// change the parents to the root</span><br /><span class="fontstyle1">while (</span><span class="fontstyle1" style="color: #7030a0;">parent[p] </span><span class="fontstyle1">!= </span><span class="fontstyle1" style="color: #7030a0;">p) </span><span class="fontstyle1">{</span><br /><span class="fontstyle1" style="color: #7030a0;">&nbsp; &nbsp; &nbsp;temp </span><span class="fontstyle1">= </span><span class="fontstyle1" style="color: #7030a0;">parent[p];<br />&nbsp; &nbsp; &nbsp;parent[p] </span><span class="fontstyle1">= </span><span class="fontstyle1" style="color: #7030a0;">root;<br />&nbsp; &nbsp; &nbsp;p </span><span class="fontstyle1">= </span><span class="fontstyle1" style="color: #7030a0;">temp</span><span class="fontstyle1">;<br />}<br />return </span><span class="fontstyle1" style="color: #7030a0;">root</span><span class="fontstyle1">;<br />}</span>&nbsp;</div><div><br /></div><div><h4>Alternative</h4>Make every other node in the path point to its grandparent<br /><br /><br /><span class="fontstyle0">findRoot</span><span class="fontstyle1">(int </span><span class="fontstyle1" style="color: #7030a0;">p) </span><span class="fontstyle1">{</span><span class="fontstyle1" style="color: #7030a0;">root </span><span class="fontstyle1">= </span><span class="fontstyle1" style="color: #7030a0;">p</span><span class="fontstyle1">;<br />while (</span><span class="fontstyle1" style="color: #7030a0;">parent[root] </span><span class="fontstyle1">!= </span><span class="fontstyle1" style="color: #7030a0;">root)</span><br /><span class="fontstyle1" style="color: #7030a0;"></span><span class="fontstyle1">{</span><br /><span class="fontstyle1" style="color: #7030a0;">parent[root] </span><span class="fontstyle1">= </span><span class="fontstyle1" style="color: #7030a0;">parent[parent[root]];<br />root </span><span class="fontstyle1">= </span><span class="fontstyle1" style="color: #7030a0;">parent[root]</span><span class="fontstyle1">;<br />}<br />return </span><span class="fontstyle1" style="color: #7030a0;">root</span><span class="fontstyle1">;</span><br /><table class="NormalTable"><tbody><tr><td width="196"><span class="fontstyle1">}</span><br /><h3><span class="fontstyle1">Weighted Union with Path Compression</span></h3></td></tr></tbody></table>Any sequence of m union/find operation on n object takes O(n+m<span style="background-color: white; font-family: &quot;whitney&quot; , &quot;helvetica neue&quot; , &quot;helvetica&quot; , &quot;arial&quot; , sans-serif; font-size: 16px; white-space: pre-wrap;">α</span>(m,n)) time<br />This is close to linear time.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-5_ZSRcCzGDE/XbgKBomB60I/AAAAAAAACQE/ibceXoLZ3KExvffcBxaNaqa3G0t5oKOCgCLcBGAsYHQ/s1600/1.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="274" data-original-width="397" height="220" src="https://1.bp.blogspot.com/-5_ZSRcCzGDE/XbgKBomB60I/AAAAAAAACQE/ibceXoLZ3KExvffcBxaNaqa3G0t5oKOCgCLcBGAsYHQ/s320/1.PNG" width="320" /></a></div><br /></div><div><br /></div><h2>Kruskal Algorithm</h2><h2><span style="font-weight: normal;"><span style="font-size: small;">To check if two trees are connected and connect them if they are not.<br />Idea:<br />1. Remove the min weight edge from s<br />2. If remove edge connects two trees<br />=&gt; Add it to the F (Combine trees)</span></span><br /><div><br style="font-size: medium; font-weight: 400;" /></div></h2><div><span class="fontstyle0">// Sort edges and initialize</span><br /><span class="fontstyle2">Edge[]</span>&nbsp;sortedEdges = sort(G.E());<br /><span class="fontstyle0" style="color: purple;">ArrayList&lt;Edge&gt; mstEdges = new ArrayList&lt;Edge&gt;();<br />UnionFind uf = new UnionFind(G.V());</span><span class="fontstyle0"><br /></span></div><div><span class="fontstyle0"><br /></span></div><div><span class="fontstyle0">// Iterate through all the edges, in order</span><br /><span class="fontstyle0" style="color: purple;">for (int i=0; i&lt;sortedEdges.length; i++) {<br />&nbsp; Edge e = sortedEdges[i];</span>// get edge<br /><span class="fontstyle0" style="color: purple;">&nbsp; Node v = e.one();</span>// get node endpoints<br /><span class="fontstyle0" style="color: purple;">&nbsp; Node w = e.two();</span></div><div><span class="fontstyle0" style="color: purple;"><br /></span><span class="fontstyle2">&nbsp; if (!uf.find(v,w)) {</span><span style="color: green;">// in the same tree?</span><br /><span class="fontstyle2">&nbsp; &nbsp; mstEdges.add(e);</span><span style="color: green;">// save edge</span><br /><span class="fontstyle2">&nbsp; &nbsp; uf.union(v,w);</span><span class="fontstyle2" style="color: green;">// combine trees</span><br /><span class="fontstyle2">&nbsp; }</span><br /><span class="fontstyle0" style="color: purple;">}</span>&nbsp;&nbsp;</div><div><br /></div><div><br />1. Sort via weight of edges</div><div>2. Check if the edge connect two trees</div><div>=&gt; When it is already connected, skip (By using find)</div><div>=&gt; Save edge to the arraylist</div><div>=&gt; If not connect, union</div><div>Use union find to fnd if the same tree</div><div><br /></div><div><br /></div><div><b><span style="color: red;">Time complexity for Kruskals is O(ELogV)</span></b></div><div>Sort takes O(ELogE)</div><div>Worst case is O(ElogV^2) = O(ElogV)</div><div>=&gt; Worst case for Edges if V^2</div><div><br /></div><div><b>Directed MST does not work for Prim's/Kruskals</b></div><div><b><br /></b></div><div><b><span style="color: red;">How fast can you find the MST if all edges have the equal weight:</span></b></div><div><b><span style="color: red;">O(V+E)</span></b></div><div>=&gt; Use BFS of DFS</div><div><br /></div><h2>Limited Edge Weights</h2><div>If we know the size of the array and they are all distinct</div><div>e.g {1-10}</div><div>There is no need to sort (Kruskals)</div><div>Our edges have integer weight, so we can just use an array size 10</div><div>=&gt; Eliminate ElogE time complexity</div><div>O(aE)</div><div><br /></div><div>(Prims)</div><div><br /></div><div>Vert added/remove -&gt; O(v)</div><div>Each edge One decreaseKey -&gt; O(E)</div><div>Time complexity: O(V+E) = O(E)</div><div><br /></div><div><br /></div>