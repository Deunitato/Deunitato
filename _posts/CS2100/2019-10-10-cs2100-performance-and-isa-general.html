---
layout: post
title: 'CS2100: Performance and ISA General Concepts'
date: '2019-10-10T02:40:00.000-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-11-12T22:26:31.135-08:00'
thumbnail: https://1.bp.blogspot.com/-r7h5xyTtfnA/XcubBW2CYCI/AAAAAAAACS4/B1P1njfX0Vcq1iaCfg2PWNVUUMrV818iACLcBGAsYHQ/s72-c/4.png
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-2731474030301188212
blogger_orig_url: https://nusmods.blogspot.com/2019/10/cs2100-performance-and-isa-general.html
---

<h2>Performance and ISA General Concepts</h2><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-r7h5xyTtfnA/XcubBW2CYCI/AAAAAAAACS4/B1P1njfX0Vcq1iaCfg2PWNVUUMrV818iACLcBGAsYHQ/s1600/4.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="536" data-original-width="886" height="193" src="https://1.bp.blogspot.com/-r7h5xyTtfnA/XcubBW2CYCI/AAAAAAAACS4/B1P1njfX0Vcq1iaCfg2PWNVUUMrV818iACLcBGAsYHQ/s320/4.png" width="320" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;">Response: Number of seconds per instruction</div><div class="separator" style="clear: both; text-align: center;">Performance: Number of instruction per one second</div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-MbXoaYgZAW8/XcubHyAXnaI/AAAAAAAACS8/aHh0QUhYYHEbzqf3PztNppLrhKT4hcX_gCLcBGAsYHQ/s1600/5.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="404" data-original-width="834" height="155" src="https://1.bp.blogspot.com/-MbXoaYgZAW8/XcubHyAXnaI/AAAAAAAACS8/aHh0QUhYYHEbzqf3PztNppLrhKT4hcX_gCLcBGAsYHQ/s320/5.png" width="320" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><br /></div><div>We can use this for pipeline</div><div><br /></div><h3>Average CPI</h3>CPI = sum of (cycles for each instructions * F)<br />F = instruction Freq / Instruction Count<br /><br />CPI = (CPUtime * Clock Rate) / Instruction Count<br />= Clock Cycles / Instruction Count<br /><br /><h3>Influencing Factors on Performance</h3><div>1. Compile the program to Binary</div><div>Depending on the compiler and the kind of instruction we have</div><div>We can change number of instruction we have<br />[AVG CPI]<br /><br /><div><b>Compiler:</b></div><div>Different compiler use different technique to compile</div><div>- gcc&nbsp;</div><div>- Clang</div><div>- icc</div><div>They will generate different binary and will optimise code by using -o(level) in the compile line</div><div>e.g -o4 will run level 4&nbsp;</div><div><br /><br /><div><b>Instruction Set Architecture:</b></div><div>The same high level statement is translated differently depending to ISA<br />e.g A*+B</div></div><br /></div><div>2. Binary Executes on Machine</div><div>[CYCLE TIME CPI]</div><div><br /></div><div><b>Machine:</b></div><div>&nbsp;- More accurately the hardware implementation</div><div>- Determine cycle time and cycle per instruction</div><div><br /></div><div><br /></div><div><b>Cycle time:</b><br />Different clock frequency</div><div><br /></div><div><b>Cycle per instruction</b></div><div>Design of internal mechanism</div><div><br /></div><div>Summary:</div><div>Performance is specific</div><div>- A given machine can have&nbsp; a different CPU</div><div>- Common misunderstanding: Expect improvement by changing one aspect machines purposes</div><div><br /></div><h3>Amdahl's Law</h3><div>Performance is limited to the non speedup portion of the program. When we improve it, we do not need to update. Optimise but there is a limit to the optimise.<br /><br />FP run 5x faster doesn't mean we have to divide.<br />We have to multiply the FP instruction and add back to the remaining time.<br />e.g<br />FP ins = 6 sec<br />Benchmark = 6 sec<br />Total : 12 sec<br />SpeedUp: 6/5&nbsp; (FP Ins) + 6<br /><br /><h3>Boolean Algebra</h3></div><div>Take a X Y to represent a set of logic</div><div>e.g X = A + B</div><div><br /></div><h3>RISC VS CISC</h3><div><b>CISC:</b></div><div>is like a matrix, each use a matrix multiplication</div><div>Give whatever the user wants.</div><div>EXE: small</div><div>Hardware: Complex</div><div><br /></div><div>e.g Intel x8b</div><div><br /></div><div><b>RISC:</b></div><div>Give them the simplest things, and the rest is build</div><div>e.g add, mul, branch</div><div>EXE: Big</div><div>Simple: optimise</div><div><br /></div><div>e.g MIPS, ARMS</div><div><br /></div><div><br /></div><h3>#1 Data Storage</h3><div>Storage architecture.</div><div>Von Neumann architecture, all the memory is in the memory and when processor needs it, we bring it</div><div><br /></div><div><h4>Standard register (GPR)</h4></div><div>There are instructions such as load and store to load and store the information from memory</div><div>This is the more popular</div><h4>Memory-Memory</h4><div>Specify the memory address in the instrcution and straight away</div><div>This is bad because memory takes very long to load</div><div><br /></div><div><b>Stack</b></div><div><b><br /></b></div><div>Last in first out data structure. The push and pop use to bring the infomation from the memory.</div><div>When we perform add, we will take the value from the stack and result is push into stack.</div><div>Popping it will store it back to the memory.</div><div>All the instruction here is very tiny</div><div><br /></div><div>e.g Java JVM</div><div><br /></div><div><b>Accumulator</b></div><div><br /></div><div>There is accumulator, what ever result that is calculated will be place as accumulator to preload everything when doing ALU execution.</div><div>Loading it back will take it from the accumulator</div><div><br /></div><div><br /></div><h3>#2 Memory and Addressing mode</h3><div>- Address size is different from the data.&nbsp;</div><div>2^k is means k different location</div><div>When reading, we will use a n-bit data bus but n may not be the same as k</div><div><br /></div><div>Loading:</div><div>Value place in MAR&nbsp;</div><div>Store</div><div>Value in MDR</div><div><br /></div><h4>Endianness</h4><div>The ordering of the bytes in multiple byte word store in memory</div><div><br /></div><div><b>Big endian:</b></div><div>Store the most significant in the lower address</div><div><br /></div><div><b>Little-endian</b></div><div>Store the least significant byte in the lower address</div><div><br /></div><div>The problems lies when you do a load, different machine will give return results.</div><div>Intel: Little Endian</div><div>Mips: Depends (Sim: Little Endian)</div><div>Network order: Big endian</div><div><br /></div><h4>Addressing modes</h4><div>3 kinds of addressing modes but in other there are more than 3</div><div>e.g Register indirect, auto increment</div><div><br /></div><h3>#3 Operation</h3><div>Standard operation in instruction set</div><div>- data movement</div><div>- Arithmetic</div><div>- Shift</div><div>- Branch</div><div>- Call</div><div><br /></div><div>Note: Load is the most used so optimise it first</div><div><br /></div><h3>#4 Instruction Format</h3><div><b>Instruction Length</b></div><div><b><br /></b></div><div>Variable length of instruction:</div><div>Used in most CISC</div><div>Require multi step Fetch and decoded</div><div><br /></div><div>Fixed-Length:</div><div>Use in RISC</div><div>Easy to decode/encode</div><div>Instruction bit are scarce</div><div><br /></div><div>Hybrid:</div><div>A mix of both</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div>