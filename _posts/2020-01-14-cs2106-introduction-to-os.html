---
layout: post
title: CS2106 - Introduction to OS
date: '2020-01-14T19:42:00.002-08:00'
author: Charlotte Deunitato
tags: 
modified_time: '2020-02-29T18:57:28.683-08:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-8045777200217450590
blogger_orig_url: https://nusmods.blogspot.com/2020/01/cs2106-introduction-to-os.html
---

<h2 style="height: 0px;">What is OS</h2><br />A program that acts an intermediary between a computer user and the computer hardware.<br /><br /><i>A system stack has a lot of layers and each of them can act as intermediary. It manages computer hardware, software resources and provides common services. It is a system software.</i><br /><i><br /></i><i>OS is an abstraction provided for the users.</i><br /><br />OS allow the user program to interact with the hardware.<br /><i>The first few computer invented does not have an OS to interact with the hardware. There is an advantage&nbsp;of minimal overhead but it is not portable and is inflexible. It is also efficient&nbsp;in its use of computer resources.</i><br /><br /><br /><h2>OS for Mainframes</h2><div><u>Insert 10</u></div><div><u><br /></u></div><div>Batch OS to execute the user program one job at a time<br /><br />Common features:<br />- No interactive interface<br />- Accepts programs in forms of tapes</div><h3>Improvements</h3><div>- CPU Idle when Performing I/O (Inefficient for simple batch processing)</div><div>- Multiprogramming&nbsp;</div><div><i>Multiple programs&nbsp;</i></div><div>- Time-sharing (1970s)</div><div><i>Multiple&nbsp;users</i></div><h3>Time-sharing OS</h3><div><u>Insert 13</u></div><div>Features:<br />- Allow multiple users</div><div>- Job schedule</div><div>- Memory management</div><div><i>The operating system have to give an illusion that you are alone and that no one else is using the same system. But the machine is running in parallel with someone. This is called parallel hardware.&nbsp;</i></div><div>- Multics</div><div>Parent of unix</div><div><br /></div><div><i>It is the job of the os to provude resources like memory to the users. Virtualisation means that the program can see the hardware as if it is running by itself. It is not impacted by other programs other than the speed.</i></div><h3>MiniComputer and UNIX</h3><div>- Evolution of moores law</div><div>- The smaller and cheaper mainframe</div><div><br /></div><div><br /></div><h3>Personal Computer</h3><div>Machine dedicaterd to user and not timeshared between mutliple users,&nbsp;</div><div>give rise to personal OS</div><div>- Windows model</div><div>-UNix model</div><h2>Motivation for Operating System</h2><div><i>"Things don't work without OS"</i></div><h3>Abstraction</h3><div>- Large variation in hardware configuration</div><div><i>The os Abstract away the complex features</i></div><div><i>OS give a uniform abstraction</i></div><div>Provides:<br />- Efficiency</div><div><i>Managing the system, the abstraction of allowing multiple users use the system makes it useful</i></div><div>- Portability</div><h3>Resource allocator</h3><div>The program execution requires many resources</div><div>Multiple programs allowed to execute simultaneously</div><div>- Manage all resources</div><div>- Arbitrate potentially conflicting request</div><div><i>To be fair and efficient between users&nbsp;</i></div><h3>Control Program</h3><div>Program can misuse the computer.<br /><br />Security and protection:</div><div>- Accidentally: Coding bugs</div><div>- Maliciously: Virus, malware</div><div><br />OS is a control program, it controls the execution of programs<br />- Prevent errors and improper use of computer<br />- Provides security and protection</div><div><br /></div><h2>OS Structure</h2><div>System Structure:<br />- Flexibility</div><div><i>How general and flexible</i></div><div>- Robustness</div><div><i>How extensive</i></div><div>- Maintainability</div><div><i>How much do we need to upgrade, is it easy to update, is it easy to add a new component</i></div><div>- Performance, scalability</div><div><i>Dimensions, the number of memory of number of threads supported.</i></div><div><br /></div><div><i><br /></i></div><div><u>Insert 27</u></div><div><br /></div><div><i>The kernal is the core of the OS that exposes some of the interface to the underlying&nbsp;hardware and the interfaces. There are some important system softwares that are not part of the kernel.</i><br /><i>Running in kernal mode means to have all the privileges.</i><br /><i><br /></i></div><div><br /></div><div><u>Insert 28</u></div><div><u><br /></u></div><div><br /></div><div><i>The User programs itself have its own API so the user can call, the library&nbsp;in return talk to other library. The library is a software and is a piece of precompiled code. Some lib needs to do a system call and talk to the os and in turn talk to the hardware. These calls are called syscalls.&nbsp;</i><br /><i>The reason why we have these calls is because sometimes we do not have time to call the OS.</i><br /><div><i><br /></i><i>The OS is not the only entity&nbsp;that talks to the hardware. (It is not all the time)</i></div><div><i>The user program can possibly talk to the hardware. It often happens because of the performance reason.&nbsp;</i><br /><i><br /></i></div>OS is like a software that manages other software. The OS acts like an abstraction for other running processes.<br />Abstraction makes things simpler and efficient.<br /><br /><br />There are different ways to structure an OS. (Architecture)<br /><h3>Monolithic</h3><div>Kernel:</div><div>- One big special program</div><div><i>Put everything into one, put all the different component into one&nbsp;kernel</i></div><div><i>Despite its so big, it is still able to develop proper abstraction.</i></div><div><i>Community built</i></div><div>- Traditional approach taken by:</div><div>Unix, Windows</div><div><br /></div><div>Advantages:</div><div>- Well understood</div><div><i>Allowed changes to modify the system into what we need</i></div><div><i><br /></i></div><div>- Good performance</div><div><i>All the components can talk to each other efficient</i></div><div><br /></div><div>Disadvantages:<br />- Highly coupled components</div><div>- Usually devolved into very complicated internal structure</div><div><br /></div><h3>Microkernel</h3>Kernel is:<br />- Very small and clean<br /><i>Anything that can be taken out is taken out</i><br />- Only provide basic and essential features<br />&nbsp; &nbsp; - IPC (Interprocess communication)<br /><i>This is important because several parts were taken out, so this process is needed for the OS to talk to other parts of system that is not part of the OS.</i><br /><i><br /></i><i><br /></i>Advantages:<br />- Kernel is generally more robust and more extendible<br />- Better isolation and protection between kernel and high level services<br /><br />Disadvantages:<br />- Lower performance<br /><i>But we have to involve the kernel to talk to other component so efficientcy is not good</i><br /><br /><br /><br />Extra:<br />Exokernel: the smallest kernel<br />Split kernel:<br />Physically split amongst several machines<br /><br /><h2>OS as a program</h2><div>OS is also known as the kernal, a program with special features.</div><div>The OS has to deal with hardware, interrupt handles and device drivers.</div><div>Provides system call interfaces and deal with hardware issues</div><div><br /></div><h3>Machine dependent HLL</h3><div>ifdefs&nbsp;</div><div>This is the architecture dependent code</div><div><br /></div><h3>Machine dependent assembly code</h3></div><h2>Virtual Machines</h2><div>A vm is a software emulation of hardware.</div><div>OS assumes total control of the hardware. But sometimes we want to run multiple OS at the same time on the same hardware. The virtual machine allow us to contain the errors.&nbsp;</div><div>Instead of having a real hardware, we can expose some fake hardware and trick the OS to think that it is real hardware.</div><div>The real hardware being exposed must seem very similar to the real hardware.</div><div><br /></div><h2>Hypervisors</h2><div>Exposes the fake hardware to the OS</div><div><br /></div><h3>Type 1</h3><div>- Provided individual virtual machine to guest OS</div><div><u>Insert 40</u></div><div><u><br /></u></div><div><u><br /></u></div><h3>Type 2</h3><div>Acts as the hardware for guest OS</div><div>- Runs in host OS</div><div>- Guest OS runs inside VM</div><div><br /></div><div>(Insert 41)</div><div><br /></div>