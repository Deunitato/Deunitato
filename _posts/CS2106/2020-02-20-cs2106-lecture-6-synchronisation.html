---
layout: post
title: 'CS2106: Lecture 6 - Synchronisation'
date: '2020-02-20T00:54:00.000-08:00'
author: Charlotte Deunitato
tags: 
modified_time: '2020-03-05T00:48:44.703-08:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-5811297542114500383
blogger_orig_url: https://nusmods.blogspot.com/2020/02/cs2106-lecture-6-synchronisation.html
---

<h2>Last week On archipelago</h2><div>1.&nbsp; Since non blocking receiver is rare, what is the purpose of a blocking receiver is asynch message passng?</div><div><br /></div><div>Recieve shld be blockin, non blocking is a feature for good programmer only.</div><div>receiver is blocking because u need to wait for the message.</div><div>UNIX Pipes is primitive way of message passing</div><div>You cannot proceed without the data we need thus blocking receive must exist</div><div><br /></div><div><br /></div><div>2.&nbsp; Is it possible for threads to use their own files and not share.</div><div>E.g each thread runs a different part of the code and responsible for writing in different files</div><div><br /></div><div>Different threads can open different files and work on them privately</div><div>However one thread can use a dile open by another.</div><div>unshare() is a new syscall that prevent one thread from oepning others</div><div><br /></div><div>3.&nbsp; Does using pthread_join in a for loop blocks the join infront</div><div><br /></div><div>The join operation will not block the main thread</div><div><br /></div><div>4. does multithreading run concurrently in the hardware context or is it more seq processing at a smaller scale?</div><div><br /></div><div>Every thread has a logical copy of the hardware context. We have to share the hardware context in a serial fashion.</div><div>If we have multiple threads/processes, we need to have parallesim in the hardware (ie multiple core)</div><div>each threads have to be running in different cores.</div><div><br /></div><div>5. What are the adv and disadv of simulat multi threading and multiple core system regarding running a single process with multiple threads?</div><div><br /></div><div>SMT = running software threads concurrently on a single hardware core</div><div><br /></div><div>That core has to be&nbsp;</div><div>- at least 2 physical copy of hardware context&nbsp;</div><div>- GPPR</div><div>- Special register</div><div><br /></div><div>We can run 2 threads on the same core if we have these two, we just need to map the context</div><div>What is the difference?</div><div>Two threads will still share ALU, caches</div><div><br /></div><div>These threads will have independent hardware context but they will compete for functional units like ALU</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><h2></h2><h2></h2><h2></h2><h2>Race Condition</h2><h3>Problems with concurrent execution</h3><div>When two process tries to&nbsp;</div><div>- Change a shared memory and uses it as well<br />- Can cause synchronization problems<br /><i>These are like examples of threads</i></div><div><br />The execution of single sequential process is deterministics<br />- Repeated execution gives the same results<br /><br />Execution of concurrent process may be non-deterministic<br />- Execution outcome depends on who access first<br />- Race condition<br /><br /><i>Problems happen when a context switch happen or processes are running in different cores and tries to access the same memory space</i><br /><i><br /></i><i>One problem is that when compiler add to a value</i><br /><i>ie x=x +100</i><br /><i><br /></i><i>This will do 3 instruction, load, add and store</i><br /><i><br /></i><i>What if we just add directly?</i><br /><i>It depends on the hardware..&nbsp;</i><br /><i>If we have a single core system,&nbsp;</i><br /><i>this statement will be running without intercept (Because of hardware)</i><br /><br /><i>If we have multicore,</i><br /><i>If core one 1 running p1 and core 2 p2,</i><br /><i>If the first instruction in core 1 is loading x in memory and we also load in c2</i><br /><i>At some point, they have to store.</i><br /><i>There will be some interleaving between execution phases in a single instruction.</i><br /><i>The interleaving cannot be help.</i><br /><i>This problem will exist even if we support a instruction like adding directly</i><br /><i>ie The access to memory might interleave even if we write directly</i><br /><i><br /></i>The problem with this happen when we have a statement that cnanot be executed in a single instrcutions. In multicore, it will definetely happen<br /><br /><br /><h4>Solution</h4></div><div>- Incorrect execution is due to unsynchronise access to a modified resourse that is shared</div><div><br /></div><div>Need: Synchronisation to control the interleaving of access</div><div>- Allow all correct interleavings</div><div>- Not allow any incorrect</div><div><br /></div><div><i>Imagine a process with shared variables with around 100 interleavings.&nbsp;</i></div><div><i>There might be some restriction that lose&nbsp;some efficiently</i></div><div><i>e.g X = X + 1000</i></div><div><i>One process execute load and store and so does the other process.</i></div><div><i>The only two correct interleaving is when p1 execute before p2</i></div><div><i>But what if p2 is running first? Then they will wait for p1 to come before p2 start.. It is a correct solution but it is not efficient</i></div><div><i><br /></i></div><div>The abstraction of a critical section will make sure that there is no interleaving in the code of the critical section. (Only one process is allow to run this part of the code) This simple abstraction, allow us to solve the synchronisation problems.&nbsp;</div><h2>Critical Section</h2><div>A code segment that only allow one process to execute in.<br />We should keep the critical section short.<br /><br />e.g<br />//Normal code<br /><br /><b>Enter CS</b><br /><u>//Critical work</u><br /><u>x = x +1000</u><br /><b>Exit CS</b><br /><u><br /></u>//Normal code</div><h3>Properties of correct implementation</h3><div>- Mutual Exclusion<br />If process p is executing in CS, all other process are prevented from entering the CS<br /><br />- Progress<br />If no process in cs, one of the waiting processes should be granted access<br /><br />- Bounded wait<br />Ensure that a waiting process will eventually get its chance<br /><i>There is a limit on how many times a process gets to run.</i><br /><br /><br />- Independence<br />Process not executing in CS should never block other process<br /><br /></div><h3>Symptoms of incorrect implementation</h3><div>- Incorrect output/behavior</div><div>Usually due to multiple programs in CS</div><div>- Deadlock</div><div>All process waiting for each other</div><div>All process are block</div><div><br /></div><div>- LiveLock</div><div>Process are not block and they can change the state</div><div>But the progress are not guaranteed</div><div>This lock usually happen when we are avoiding deadlock</div><div><br /></div><div>- Starvation</div><div>Some processes never get a chance to go to CS</div><h2>Implementation of critical section</h2><h3>Low level (Hardware) solution</h3><div>Previously the problem for attempt 1 is that the someone else can jump between the reading of lock.</div><div>What if we fix this? We ensure that there is only one instruction that can read and write of the lock variable</div><div><br /></div><div><i>TestAndSet Register, Memorylocation&nbsp;</i></div><div>This will load the value from memorylocation and write to register</div><div><br />Stores a 1 into memory location and this is a <u>single</u> atomic machine operation.</div><div>No one can intercept between reading and writing</div><div><br /></div><div>In multiplecores,</div><div>It is possible that two cores execute testandset at the same time, this will cause interleaving.</div><div>//Not talked in this course</div><div><br /></div><div>void EnterCS(*lock)</div><div>&nbsp; &nbsp;while(testandset(lock)==1);</div><div><br /></div><div>void exitCS(*lock)</div><div>&nbsp; &nbsp;*lock =0</div><div><br /></div><div>Only one process will be able to read lock and set it</div><div>The other process will not be able to rewrite it to 0.</div><div><br /></div><div>- There is mutex</div><div>Only one will read 0 and that must be the first one to invert and enter CS</div><div><br /></div><div>- If process P1 wants to enter, it can just eter</div><div>Progress and independence are ok</div><div><br /></div><div>- But there is no bounded wait</div><div>Might cause starvation if the process keep getting looped and the waiting process keep sleeping and waking up only to find that the lock is already taken by the looped process</div><div><br /></div><div><br /></div><div>The implementation works but it employs busy waiting (waste cpu)</div><div>Others:<br />- Compare and exchange</div><div>- Atomic swap</div><div>- Load link/store conditional</div><div>- Test and test and set</div><h3>High Level Programming language solution</h3><div>Making use of a boolean to set the lock to 1 once someone is inside.</div><div><br /></div><div>while(lock!=0)</div><div><br /></div><div>//critical sec</div><div>lock = 1</div><div><br /></div><div>//End of CS</div><div>lock = 0</div><div><br /></div><div>This solution does not guaranteed mutex.</div><div>There is a vulnerability that someone else will be able to read the value of lock before we set it.</div><div><br /></div><div><b>Fixed attempt 1:</b></div><div>&nbsp;We try to disable interrupts and enable interrupts once leave CS</div><div><u>this only works with single core</u></div><div>- Must have privilege to disable and enable interrupt</div><div><br /></div><div>However, this is bad to disable/enable interrupts. <u>It will affect some other part of the program</u></div><div><u><br /></u></div><div><b>Fixed attempt 2:</b></div><div>&nbsp;Each process is trying to both read and write the shared var before entering the CS</div><div>But someone else can jump in between the read and write.</div><div>Just fix this part</div><div><br /></div><div>We have another variable called turn which is 1 or 0</div><div>Turn will check which process is allowed to enter the CS</div><div>Turn acts like a switch that will only let one process at a time. This turn will make sure that the two process will not get confuse on who gets to go into CS<br />However, this turn forces that if p1 comes first, p1 must enter CS first even if p2 arrives first.</div><div><br /></div><div><br /></div><div>If turn =0, process can enter</div><div>1 , process cannot enter</div><div><br /></div><div><i>while(turn!=0); //wait here</i></div><div><br /></div><div>Once the process change to 0.</div><div>This solution guarantee mutex but it overly restricts the execution</div><div><br /></div><div>If p1 come and finds that it is not its turn, it will continue to wait. If the front process is stuck doing something, it is not efficient.</div><div>This solution also does not satisfy the independence property.</div><div>P1 cannot access because the process in front of it is processing some unrelated code</div><div><br /></div><div><i>There is no guarantee&nbsp;that p1 will get into the CS.</i></div><div><i><br /></i></div><div><b>Fixed Attempt 3:</b></div><div><b><br /></b></div><div>We will use two variables, want[2]</div><div>want[0] =&nbsp;</div><div>want[1] = p1 wants to enter the CS</div><div><br /></div><div>1. Indicate want enter CS (<i>want[1] = 1)</i></div><div>2. Wait if the other process want enter <i>while(want[1]);</i></div><div>3. Enter the CS</div><div>4. Finish, set the flag (<i>Want[0] = 0)</i></div><div><br /></div><div>- there is mutex</div><div>Guarantees that one process get to enter and not wait for another.</div><div>- There is a possibility that both processes are waiting for each other while they wait (livelock)</div><div>The processes are waiting for the other one to go, they are looping but they cannot progress.</div><div>Progress is not guaranteed</div><div>- Independence is guranteed</div><div>The process p1 will wait only if p2 wants to wait</div><div>- However, there might be a case where both process starve each other.</div><div><br /></div><div><b>Fixed attempt 4:</b><br />- Have want[2]</div><div>- Shared var turn</div><div><br /></div><div>1. Process will use want the same way (To show that they want to enter CS)</div><div>2. Both process are going to let the other go by setting turn to the ID of the other process</div><div>3. Wait only if the other process want to go into CS and it is our turn)&nbsp;</div><div>4. Reset want[0] =0</div><div><br /></div><div>- There is mutux</div><div><br /></div><div>case 1: one proccess enter before the otehr process executed the statement in the cs</div><div>case 2: Both want to enter together</div><div><br /></div><div>-Progress is satisfied</div><div>They will only wait if another wants to enter the CS</div><div><br /></div><div>- Bounded wait is satisfied</div><div>It will alternate</div><div><br /></div><div><u>this solution is call peterson algo</u></div><div><u><br /></u></div><div>Disadv:<br />- Busy waiting</div><div>Everything is waiting and doing nothing, not efficient.</div><div>We want to be able to block them and unblock when it is their turn</div><div><br /></div><div>- Low level</div><div>Basic primitive constructs can work</div><div><br /></div><div>- Not general</div><div>- complex</div><div><br /></div><div><br /></div><h3>High level OS abstraction</h3><div>What if we use the OS to ensure CS?</div><div><br /></div><div><b>Semaphores:</b><br />- A generalised synchronisation mechanism</div><div>- Only behaviors are specified -&gt; can have different implementation</div><div><br /></div><div>Provide:</div><div>- A way to block a number of process (sleeping)</div><div>- Way to unblock.wakeup one or more sleeping process</div><div><br /></div><div>Semaphore:</div><div>- wait(S)</div><div>if s&lt;=0 , blocks goes to sleep</div><div>Decrements S</div><div><br /></div><div>- Signal(S)</div><div>Increments S</div><div>Wakes up one more more processes</div><div>The operation never blocks the process that calls the signal</div><div>(Some will result in the rescheduling of the process after calling signal)</div><div>A semophore is an interger and a list of processess.</div><div>The value of int is set at 1</div><div>After p1 calls wait, p1 enter cs and dec the int to 0</div><div>If another p2 comes into cs, it will see the int to be 0 and will be added to the list</div><div><br /></div><div>s(current)= s(intitial) + signal(s) - wait(s)</div><div><br /></div><div><br /></div><div><b>General and binary semaphores</b></div><div><b><br /></b></div><div>General semaphores:<br />- Increment and decrement by 1</div><div>- For convienence</div><div><br /></div><div>Binary:</div><div>- Only allow two values</div><div>- This is sufficient</div><div>- Often have special implementation</div><div>- Mutex&nbsp;</div><div><br /></div><div>A binary can be use to implement to general and vice versa</div><div><br /></div><div><b>Semaphore example:</b><br />- Binary sem s= 1</div><div><br /></div><div>wait(s)</div><div>//CS</div><div>signal(s)</div><div><br /></div><div>S can only be 0 or 1.</div><div>This is a mutex</div><div><br /></div><div>1. First process exe 1 wait dec the sem to 0</div><div>2. Second will see the sem is 0 and is blocked and listed</div><div>3. when first process finish, it will increment sem and wake one process</div><div><br /></div><div><br /></div><div><br /></div><div><b>Mutex: Proof</b></div><div><b><br /></b></div><div>Ncs = num of process in the CS = process that completed wait() but not signal()</div><div>Ncs = wait - signal</div><div>Sinit = 1</div><div><br /></div><div>Scurrent = 1 + Signal(S) - wait(s)</div><div><br /></div><div><br /></div><div>Deadlock:<br />- Dead lock means all processes stuck at wait(S)</div><div>There is no processes in the critical section</div><div>Scurrent =0 amd Ncs = 0</div><div><br /></div><div>//This is not possible unless misuse because</div><div>Scurrent + Ncs = 1</div><div><br /></div><div><br /></div><div><u>Examples</u></div><div><br /></div><div><br /></div><div><br /></div><div>Starvation:<br />yes and no, depends on the signal operation.</div><div><br /></div><div>If the signal selects in FIFO then there is no starvation else there might be</div><div><br /></div><div>1. Suppose p1 is block at wait(s)</div><div>2. P1 is in a list of block processes</div><div>3. P2 calls signal and exits, it incremenet</div><div>4. Possible that p4 is woken up instead before p1 and run due to the way the next process is selected</div><div><br /></div><div><b>Semaphores as a general synchronisation tool</b></div><div><b><br /></b></div><div>2 processes must execute but section A must exe before section B in p2</div><div><br /></div><div>- Use semaphore to send a signal only after A is done.</div><div>- Wait in front of section B</div><div>//This ensure that B will always wait when A is not done yet</div><div><br /></div><div><u>Semaphores is the most powerful synchronisation solver.</u></div><div><u><br /></u></div><div>common alt: Conditional variable</div><div>- If some variable needs to have a certain value before exectuin,</div><div>the task can wait on that variable a</div><div>There is a ability to broadcast to other process that are waiting to change the value</div><div>Can choose which process to run</div><div><br /></div><div><br /></div><h2>Classical Synchronisation problems&nbsp; (3/5/20)</h2><h3>Crowded NightClub</h3><div>- A highly popular nightclub has limited space and strict regulations no more than N customers can be present in the club at any time.</div><div><br /></div><div>Semaphore sem = N</div><div>void client(){</div><div>&nbsp; &nbsp;wait(sem); /will decrease the N</div><div>&nbsp; &nbsp;dance();</div><div>&nbsp; &nbsp;signal(sem);&nbsp;</div><div>}</div><div><br /></div><div>I will block until someone leaves. This is where general semaphores is useful because we can let multiple processes enter.</div><div><br /></div><div>wait(mutex)</div><div>allowed++</div><div>if(allow&lt;=0)</div><div>&nbsp; &nbsp;signal(queue)</div><div>signal(mutex)</div><div><br /></div><div>Only allow if there is no waiting process outside.</div><div>Then we signal(queue)</div><div><br /></div><div>Potential problem for binary semaphores:<br />-&nbsp; It is possible for the program to block for a long time</div><div>-&nbsp; If i have multiple clients going in and a couple of clients are waiting in the queue, the value of the semaphore should be 0, lets say some clients are leaving, they are going to send a signal.</div><div>But what if there is a context switch whereby the process does not have time to decrement/increment the semaphores.</div><div>Since it is a binary, they cannot increase beyond 1. Two signals might be lost.</div><div><br /></div><div><br /></div><div>Conclusion:<br /><i>Given the most primitive sema, we can create a more general sema with some pros and cons.</i></div><div><br /></div><div><br /></div><h3>Producer-Consumer</h3><div>- Processes shared bounded buffer of size K</div><div>- Producer produce items to insert in buffer</div><div>&nbsp; &nbsp;- Only do so when the buffer is not full (&lt;K items)<br />- Consumers remove items from buffer</div><div>&nbsp; &nbsp;- Only when buffer is not empty</div><div><br /></div><div><br /></div><div>There is a concurrency issue when two consumers tries to pulls out of the same slot and two producer trying to put into the same slot in the buffer.</div><div><br /></div><div><b>Solving:</b></div><div><b>BUSY WAITING</b></div><div><br /></div><div>Producer:</div><div><br /><b>- </b>Use a loop,</div><div>&nbsp; if(count&lt;K)</div><div>&nbsp; &nbsp; buffer[in] = item;</div><div>&nbsp; &nbsp; in = (in+1)%k;</div><div>&nbsp; &nbsp;count++</div><div><br /></div><div><i>Count keep tracks of how many items we have.&nbsp;</i></div><div><br /></div><div>Consumer:</div><div><br /></div><div>if(count&gt;0)</div><div>&nbsp; &nbsp;item = buffer[out[</div><div>&nbsp; &nbsp;out = (out+1) % K<br />&nbsp; &nbsp;count --;</div><div><br /></div><div><br /></div><div>We can use busy waiting, every producer and consumer is going to block on the same mutex.</div><div>Workability: There is no correctness but there is performance.</div><div>If there is only a consumer, it will continue waiting since there is nothing produce</div><div><br /></div><div>Fix: We use a canConsume flag and conProduce flag</div><div>Allow the consumer to loop in while(!canConsume) when there is nothing being produced</div><div><br /></div><div>while(canProduce == false);</div><div>wait(mutex);</div><div><br /></div><div>Problem: When we have a customer that is waiting for the buffer to become non empty, we will wait. All the customer will be waiting in this while loop.</div><div>These is burning power for nothing.</div><div>These energy can be use to for some other processes that really needed it.</div><div><br /></div><div><br /></div><div><b>Second solution: BLOCKING</b></div><div><b><br /></b>Use semaphores to block producer when there is nothing to produce and consumer when there is nothing in the buffer. We want the producer to signal the consumer when a new item is place in the buffer.</div><div><br /></div><div><br /></div><div>- Mutex that will guard the variables(buffer, count)</div><div>- One semaphore to indicate if the buffer is full (If a producer can work)</div><div>- Another semaphores if the consumer can work (The buffer is not empty)</div><div>Both semaphores can be binary.</div><div><br /></div><div>When the producer produce something, it will signal to the consumer to go. The consumer should wait as long as the buffer is non empty. If some item is consumed, the consumer will signal to the producer.</div><div>The initial value of the&nbsp;</div><div>- semaphore is k (Length of the buffer)</div><div>- Binary lock: 1 (It is a lock)</div><div><br /></div><div><u>Work-ability:</u></div><div>Yes it does work.</div><div>They are not modifying the shared structure because there is a mutex guarding</div><div><br /></div><div>Homework: Think about another implementation. There are two circular buffer in implementation and the key difference is whether we need the variable count or not. Is this variable necessary?</div><div>-&gt; No it is not needed, the semaphore is eliminate the need for count.</div><div><br /></div><div>wait(Notfull) : force produce go to sleep</div><div>wait(noempty) : Force consumer to go sleep</div><div>Signal(notfull) : 1 consumer wake up 1 produce</div><div>signal(notEmpty): 1 produce wake up one consumer</div><div><br /></div><div><br /></div><div><b>Solving: Message Passing</b></div><div><br /></div><div>- Use message passing</div><div>mQueue.send(Item)</div><div>mQueue.recieve(item)</div><div><br /></div><div>The send and recieve will block the consumer if there is nothing to be recieved.</div><div><br /></div><div>For the sender, we want it to be block when the queue is full.&nbsp;</div><div>Thus we will use</div><div>messageQueue mQueue = new MessageQueue(K);</div><div>It is <u>asynchronous</u>, the sender is not normally blocking as it can continously produce next item as long as there is space in the buffer, the producer can produce K times.</div><div>This is a non blocking send.</div><div><br /></div><div>- The system handles mutex, the os ensures that the message are send coherrently. We do not need to worry about synchronisation.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><h3>Reader and writers</h3><div>- Processes shared data structure D</div><div>- Reader: Retrieves information from D</div><div>- Writer: Modifies information from D</div><div><br /></div><div>Specification:&nbsp;</div><div>Readers can read together</div><div>Only one writer to be writing</div><div>Reader cannot read when there is a writer writing</div><div><br /></div><div><br /></div><div>Problem:</div><div>- Detects when the room is empty, signal to the writer</div><div>- Readers to increment and decrement when it enters and leaves</div><div>- Readers to wait if theres a writer</div><div>- Reader to signal if it has finish reading.</div><div><br /></div><div>Mutex:</div><div>- One mutex to ensure local variables are not editied</div><div>- Another mutex to ensure that the reader reader do not try to read while file is being written</div><div><br /></div><div>Workability:</div><div>The problem with writer is not able to have a chance if there is a stream of readers.</div><div>Readers will starve the writers</div><h2>Deadlocks&nbsp;</h2><div><h3><span style="font-size: large;">Dining philosophers Problem</span></h3></div><div>- 5 philosophers sitting in circular table with 5 chairs and 5 chopsticks</div><div>- When one philosopher becomes hungry, they will pick up the chopsticks on their left and right.</div><div>- A philosopher can only pick chopsticks one at a time</div><div>- Must hold both to eat</div><div>- Finish eating, puts both down</div><div><br /></div><div><br /></div><div>semaphore choptick[5] = {1,1,1,1,1}</div><div><br /></div><div><b>Solution 1:</b><br />- When philo tries to get chopstick by calling wait,</div><div><br /></div><div>int left = i</div><div>int right = (i+1)%5</div><div>while(1){</div><div><br /></div><div>wait(chopstick[right])</div><div>wait(chopstick[left])</div><div>eat();</div><div><br /></div><div>signal(chopsstick[right])</div><div>signal(chopstick[left])</div><div><br /></div><div>think();</div><div>}</div><div><br /></div><div><br /></div><div>But, what if every philo have the left and they wait for the right. But.. there is no more left. That is a deadlock..</div><div><br /></div><div><br /></div><div><b>Solution 2: (Look at the avoid and prevent)</b></div><div><b>- </b>Have a boolean that checks that both chopsticks is free</div><div>- This might be not atomic, someone might be checking while someone took it</div><div><br /></div><div><br /></div><div><b>Solution 3:</b></div><div>- Wait at the left chopsticks</div><div>- If right chopstick is available, take it</div><div>- Else release left</div><div><br /></div><div>A livelock could happen and a deadlock</div><div>Live: Everyone take a left, tries to take right, instead of blocking ,drop the left and try again</div><div>Dead: Race condition where someone tries to get the chopstick while another is enquiring</div><div><br /></div><div><b>Solution 4:<br /></b></div><div>- while(test-and-set(chopstick(Left))==1);</div><div>- if(test-and-set(chopstick[right]==0)</div><div>- Ensure that no one can read while im reading/ writing</div><div>- This will solve the deadlock problem in <b>Solution 3</b></div><div><b><br /></b></div><div>However, livelock might still happen similar to <b>Solution 3</b></div><div><br /></div><div><br /></div><div><b>Modelling</b></div><div><b><br /></b></div><div>Resource type: Memory space, IO devices, locks</div><div>Each resource type has Wi identical instances</div><div>Each process utilizes a resource as follow:<br />- Request</div><div>- Use</div><div>- Release</div><div><br /></div><div>Using graphs</div><div>&lt;slide 30&gt;</div><div><br /></div><div>For deadlock to happen, there must be a loop and a limited amount of resources</div><div><br /></div><div>No cycles - no deadlocks</div><div>Got cycles:</div><div>- Every instance only one resource -&gt; Deadlock</div><div>- Multiple -&gt; Depends (Is the multiple resource in instance involved in the cycle? Run a detection algo)</div><div><br /></div><div><br /></div><h3><span style="font-size: large;">Conditions</span></h3><div>- Mutex: An instance of a resource can only be used by one process at a time</div><div>If a resource is shared, there is no reason for something to be block and entering into deadlock</div><div><br /></div><div>- Hold and wait: Process holding at least one resource, waiting to acquire additional resource held by other processes</div><div><br /></div><div>- No preemption: A resource can be released only voluntarily by the process holding it, after that process has finish using it</div><div><br /></div><div>- Circular wait: There exist a set of waiting processes such that p0 is waiting for a resource that is held by p1, p1 is waiting for p2..... pn-1 waiting for p0</div><div><br /></div><h3></h3><h3>Prevention&nbsp;</h3><div><div style="font-size: medium; font-weight: 400;">Prevent and avoid at least one of the four necessary condition for deadlock to happen</div></div><div style="font-size: medium; font-weight: 400;"><br /></div><div style="font-size: medium;">Avoid Mutual Exclusion</div><div style="font-size: medium;"><span style="font-weight: normal;">Allow sharing of resource</span></div><div style="font-size: medium;"><span style="font-weight: normal;">- Impossible for non sharable resources (Printers, data areas to be written, chopsticks)</span></div><div style="font-size: medium;"><span style="font-weight: normal;">- Minimise it, do not use till necessary</span></div><div style="font-size: medium;"><span style="font-weight: normal;">- Sharable: code section, read only data</span></div><div style="font-size: medium;"><span style="font-weight: normal;"><br /></span></div><div style="font-size: medium;">Avoid Hold and Wait</div><div style="font-size: medium;"><span style="font-weight: normal;">1. Allow processes to use only one at a time</span></div><div style="font-size: medium;"><span style="font-weight: normal;">- Very restricting</span></div><div style="font-size: medium;"><span style="font-weight: normal;"><br /></span></div><div style="font-size: medium;"><span style="font-weight: normal;">2. Preallocate all resource in advance</span></div><div style="font-size: medium;"><span style="font-weight: normal;">- Allow only when all needed resources is available&nbsp;</span></div><div style="font-size: medium;"><span style="font-weight: normal;">- Low resource utilization and low system throughput</span></div><div style="font-size: medium;"><span style="font-weight: normal;"><br /></span></div><div><span style="font-size: small;"><span style="font-weight: normal;">3, Use non </span><span style="font-weight: 400;">blocking</span><span style="font-weight: normal;">&nbsp;primitives</span></span></div><div><span style="font-size: small;"><span style="font-weight: normal;">- Check if the second is not available without blocking</span></span></div><div><span style="font-size: small;"><span style="font-weight: normal;">- Release the first chopstick if second is unavailable</span></span></div><div><span style="font-size: small;"><span style="font-weight: 400;">- Possible livelocks and starvation</span></span></div><div style="font-size: medium;"><span style="font-weight: normal;"><br /></span></div><div style="font-size: medium; font-weight: 400;"><br /></div><h3></h3><h3>Avoidance</h3><div><span style="font-size: small;"><span style="font-weight: normal;">Let processes execute as usual but tracks their resource request and releases. If a specific action can lead to a deadlock, do not execute it</span></span></div><h3>Detection and recovery</h3><div><span style="font-size: small; font-weight: 400;">Allow system to experience and recover</span></div><div><span style="font-weight: 400;"><span style="font-size: large;"><br /></span></span></div><h3><span style="font-size: large;"><span style="font-weight: 400;"><br /></span>Ostrich method</span></h3><h3><div style="font-size: medium; font-weight: 400;">Ignore the problem and pretend it never occured</div><div style="font-size: medium; font-weight: 400;">Unix does this</div><div style="font-size: medium; font-weight: 400;"><br /></div><div style="font-size: medium; font-weight: 400;"><br /></div></h3><h2><span style="font-size: x-large;">LiveLock</span></h2><div><span style="font-size: small;"><span style="font-weight: 400;">A situation in which a set of processes are not block but cannot progress.</span></span></div><div><span style="font-size: small;"><span style="font-weight: 400;">But this is less serious than a deadlock</span></span></div><div><span style="font-size: small;"><span style="font-weight: 400;"><br /></span></span></div><div><span style="font-size: small;"><span style="font-weight: 400;">- Often result of&nbsp; deadlock prevention/avoidance</span></span></div><div><span style="font-size: small;"><span style="font-weight: 400;">- Can be resolved by chance :(</span></span></div>