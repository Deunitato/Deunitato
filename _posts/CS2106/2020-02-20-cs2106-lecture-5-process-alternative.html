---
layout: post
title: 'CS2106: Lecture 5 -  Process Alternative, Threads'
date: '2020-02-20T00:44:00.001-08:00'
author: Charlotte Deunitato
tags: 
modified_time: '2020-02-20T00:44:14.684-08:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-7901960652306135356
blogger_orig_url: https://nusmods.blogspot.com/2020/02/cs2106-lecture-5-process-alternative.html
---

<h2>Threads</h2><h3>Motivation</h3><div>- Processes are expensive</div><div>Processes creation is use fork() model which causes a lot of duplicate memory space and process context</div><div>- Context switch</div><div>Requires saving and restoring of process information&nbsp;</div><div><br /></div><div>- Communication between process:<br />Independent -&gt; No easy way to pass info</div><div>IPC -&gt; OS involvement</div><div><br /></div><div>- Thread was invented to overcome the problems with process model</div><div>- Threads is use to do multitasking within a process: Waiting for IO, loading the graphics (can do together at the same time)</div><div><br /></div><h3>Basic Idea</h3><div>- Traditional process has one thread</div><div>The program does one instruction each time</div><div>Hardware can execute more through instruction level parallelism</div><div><br /></div><div>- Add more threads: Multiple parts of the program can be executed at the same time conceptually (Program is faster)</div><div><br /></div><div><br /></div><h3>Process and threads</h3><div>A single process have multiple threads (Multithreaded process)</div><div><br /></div><div><div><b>Between threads</b></div><div>Shared:</div><div>- Text segment (code)</div><div>- Heap</div><div>- Data</div><div>- PID</div><div>- Context</div><div><br /></div><div>Not shared:</div><div>- GPR</div><div>- Special register</div><div>- Stack (We do not want the parameters to be overwritten by different threads)</div></div><div>Unique info between each threads:</div><div>- thread id</div><div>- register</div><div>- Stack</div><div><br /></div><div><u><b>&lt;Insert slide 10/11&gt;</b></u></div><div><u><b><br /></b></u></div><div>When we are switching the thread, we are just manipulating the pointers.</div><div>We are not saving the context like in a process context switch</div><div><br /></div><div><br /></div><div><b>Benefits:</b><br />- Enconomy</div><div>Less resources</div><div><br /></div><div>- Resource sharing</div><div>Additional communcation (Could be problem)</div><div><br /></div><div>- Responsiveness</div><div>Can let other components do something else</div><div><br /></div><div>- Scalability</div><div>You can use one core. Multi core will not be useful in threads</div><div><br /></div><div><br /></div><div><b>Problems:</b><br />- Synch around shared memory is much worse</div><div>All memory except stack is shared (Race condition)</div><div><br /></div><div>- System call concurrency</div><div>Parallel system call is possible</div><div><br /></div><div>- Process behavior;</div><div>fork() duplicates process, what about threads</div><div>If a single thread does exit(), what about others?</div><div>If a single thread calls exec(), what about other threads</div><div>which thead receives a signal sent to process?</div><div><br /></div><h2>Threads Models</h2><h3>Kernel vs User Thread</h3><div><b>User thread</b></div><div>- Thread is implemented as user lib</div><div>- A runtime system handles thread related operation</div><div>- Kernel not aware of threads in process</div><div><br /></div><div><b><u>&lt;Insert slide 16&gt;</u></b></div><div><b><u><br /></u></b></div><div>OS sees it as one thread</div><div><br /></div><div><br /></div><div><div><b>Pros</b></div><div>- Any OS</div><div>- thread operations are just libcalls</div><div>- More configurable and flexible</div><div><br /></div><div><b>Cons:</b><br />- Limited to one core (OS does not know about different threads) (No scheduler)</div><div>- One thread using IO operation will block the entire process ( Threads is useless)</div></div><div><br /></div><div><b>Kernel thread</b></div><div>- Thread is implemented in OS<br />- Thread operation is handled as syscalls</div><div>- Thread level scheduling is possible:</div><div>Thread schedules thread not processes</div><div>- Kernel often use threads for its own execution</div><div><br /></div><div><b><i>&lt;<u>Insert slide 18&gt;</u></i></b></div><div><br /></div><div><b>Pros:</b><br />- kernal schedule on thread levels</div><div>More than one thread in same pricess can run sim on multiple cpu</div><div>One trhead can be block while another thread of same process is running</div><div><br /></div><div><b>Cons:</b><br />- Thread op are now syscalls</div><div>Slower and more resources</div><div>- Less flexible</div><div>Expensive and overkill</div><h3>Hybrid model</h3><div>- OS schedule on kernel threads</div><div>- Use thread can bind to kernel thread</div><div><br /></div><h2>Threads on modern processor</h2><div>- Threads started as software mechanism</div><div>(User space lib -&gt; OS aware mech)</div><div><br /></div><div>- There are hardware support on modern processors</div><div>(SMT) -&gt; Simultaneous multi threading aka hyperthreading</div><h2>Thread in UNIX</h2><h3>POSIX thread&nbsp;</h3><div><b>pthread</b></div><div>- can be implemented as user (Linux)/kernal thread</div><h4>Create, exit, synchronisation</h4><h4>Exploration</h4>