---
layout: post
title: 'CS2106: Lecture 6 - Interprocess Communication'
date: '2020-02-13T00:02:00.002-08:00'
author: Charlotte Deunitato
tags: 
modified_time: '2020-02-19T23:50:51.569-08:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-1899773257009609643
blogger_orig_url: https://nusmods.blogspot.com/2020/02/cs2106-lecture-6-interprocess.html
---

There are different type of IPC<br />- Shared memory<br />- Message passing<br />- Pipes<br />- Signals<br /><br />Hard for cooperating process to share information due to the independent memory space.<br />How can process talk?<br />- IPC is needed<br /><br /><h2>Shared memory</h2><div>Communication through read and writes to shared variables</div><div><br /></div><div>e.g&nbsp;</div><div>Process 1 creates shared memory region M&nbsp;</div><div>Process 2 attaches memory region M to its own memory space</div><div>p1 and p2 can now communicate through memory region M</div><div><br /></div><div>M behaves like a normal memory region&nbsp;</div><div><br /></div><div>The same model is applicable to multiple process sharing the same memory region.</div><div><br /></div><div><b>Advantages:</b><br />- Efficient: OS needed only to setup shared regions</div><div>- Ease of use: Simple reads and writes to arbitrary data types</div><div><br /></div><div><b>Disadv:</b><br />- Limited to single machine</div><div>- Requires synchronisation, which is hard</div><div><br /></div><div>e.g</div><div><i>If one process increment a counter and another process decrement counter,</i></div><div><i>Let the counter be the shared memory.</i></div><div><i>If both processes use different register,</i></div><div><i>The position of the process matters.. different position can lead to different outcomes (Race condition)</i></div><div>Because both process are reading and writing to shared variables</div><div><br /></div><div>4!/2*2 = 6 possible interleavings [Permutaations]</div><div>This is due to loading must come before storing.</div><div>This is synchronisation problem</div><div><br /></div><h3>Race condition</h3><div>- System behavior depends on exact interleavings</div><div>These system are incorrect</div><div><br /></div><div>- Possible huge number of interleaving scenarios</div><div><br /></div><div>- Some are ok but some are not</div><div><br /></div><div><br /></div><h3>POSIX Shared Memory in *nix</h3><div>- Basic steps of usage:<br />1. Create/locate a region M shared</div><div>2. Attached M to process memory space</div><div>3. Read/Write from M</div><div>4. Detach M from memory after Use</div><div>5. Destroy M</div><div>- Only one process need to do this</div><div>- Only allowed if no process is attached to this</div><div><br /></div><h2>Message Passing</h2><div>Process 1 prepares a message M and send it to Process 2</div><div>Process 2 receives the message M</div><div>Message sending and receiving are usually provides as syscalls</div><div><br /></div><div>Properties:</div><div>- Naming: Identifying the other party in communication</div><div>- Synch: The behavior of the sending/receiving operation</div><div><br /></div><div>This message is stored in the kernel memory space.</div><div>The OS is interacting with the process.<br /><br /><h3><b>Direct communication</b></h3></div><div><br /></div><div>However, this is not efficient as evert process needs to name the other party</div><div>e.g send(p2, msg)</div><div>e.g Recieve(p1,msg)</div><div>//the reciever and sender need to specify who to reciever and send from</div><div><br /></div><h3>Indirect communication</h3><div>Message are send to message storage</div><div>- Port or mailbox</div><div><br /></div><div>E.g Send(MB,msg)</div><div>E.g Receive(MB,msg)</div><div>MB is the mail box</div><div><br /></div><div>Characteristics:</div><div>One mailbox can be shared among many process</div><div><br /></div><h3>Two synchronization behaviors</h3><div><br /></div><div>- Non blocking primitives (Asynchronous)</div><div><i>The message could be buffering or the sender blocks until the receiver&nbsp;receives&nbsp;the message,</i></div><div><i>this is the point of synchronization. The sender process is stuck at the process of sending and the code will not be exe until the receiver&nbsp;receives the message.</i></div><div><i>This allow us to synchronise&nbsp;the processes</i><br /><i><br /></i>Usually recieve() is blocking<br />Send() Proceeds regardless<br /><br /></div><div><br />- Blocking primitives (Synchronous)<br />Send() blocks if matching receive() is not executed -&gt; Sync</div><div></div><div><h2>Last week Archi</h2></div><div>1. For SRT, given the case where new shorter jobs enter significant time gaps, wouldnt the overhead be very significant</div><div><i>There is no reason for it to be significant.</i></div><div><i>Context switch can only appear upon job arrival and termination</i></div><div><i>Larger time gaps means even&nbsp;fewer&nbsp;context switching</i></div><br />2. How does SRT deal with starvation<br /><i>It doesnt, it does suffer from starvation more so that SJF</i><br /><i><br /></i>3. Why dont we set the timer interrupt to be equal to time quantum so scheduler doesnt get invoke for nothing<br />Why is there a need to put time quantums as multiples of interval of timer interrupt? Should we not just make ITI = time quantum<br /><i>It is up to the scheduler to decide what to do with it, it can have multiple time quanta.</i><br /><i>Interval timer interrupts define the min time unit at which scheduler can be invoked</i><br /><i><br /></i>4. For RR, if there is only a single process, does the scheduler switch out the process and switch it back in each time quantum?<br /><br /><i>The process will stop, and the scheduler will run some code asynchronously..</i><br /><i>It will save the context then let the scheduler run.. in this case there is nothing.</i><br /><i>Thus it will restore the state of the register</i><br /><i>This is a partial context switch</i><br /><i>I am just storing and saving it.</i><br /><i>The scheduler will not continue from where it left off.</i><br /><i>It is invoke periodically</i><br /><i>There is no need to save the context of the scheduler.</i><br /><i>Routinely save the register.</i><br /><i>No but a big deal of the context will be save and stored</i><br /><br />5. For linux, higher priority have shorter time slice while lower priority have longer time slice<br />So if i have CPU intensive process and I want it to finish execution as soon as possible, should i set it to the lowest priority?<br /><br /><i>No, giving longer quantum does not means that you will get more cpu time.</i><br /><i>This is the same as q4 as the scheduler will intercept you anyways. It does not matter.</i><br /><i><br /></i>Q6 How priority affects responsive?<br />Does a higher pri process get exe more freq than lower priority <i>Yes</i><br />If not how does higher priority lead to better responsiveness just by being at the front of the queue<br /><br /><i>Responsiveness is important for interactive processes. These processes&nbsp;need little CPU time but when they need it, they need it immediately.</i><br /><i>Giving them higher pri means putting them to the front of the queue and not waiting for lower priority job to finish (If preemptive)</i><br /><i>They will be pick more often because it is always in front&nbsp;of the queue.</i><br /><i>When we measure&nbsp;responsiveness, we are measuring that for every cpu burst, we check how long it takes to execute.</i><br /><i><br /></i><i>We characterised the distribution of its response times for interactive system. How long does it take to get CPU time rather than how long it take as a whole.</i><br /><i><br /></i><i>Non interact is how long it takes to finish it all.</i><br /><i><br /></i><br /><h3>Shared memory vs Message passing</h3><div>Location of memory:</div><div>Shared memory uses an actual memory which is shared amongst both processes while message passage uses kernel buffers (Not shared variables)</div><div><br /></div><div><br /></div><h3>Synchronization model: Reciever</h3><div><b>Blocking&nbsp;receive</b></div><div>- COmmon</div><div>- Receiver mus wait for message if its not already available</div><div><b><br /></b></div><div><b>Non blocking&nbsp;receive</b></div><div>- Checks if msg is avail</div><div>- if mess avail, retrieves it and moves on</div><div>- If not avail, continues without a message</div><div><br /></div><h3>Non blocking send = async Message passing</h3><div>- Sender is never block</div><div>Even if the receiver has not execute the matching receive()</div><div>- System buffers the message to a certain capacity</div><div>- Receive() perform by the receiver later will be completed imm</div><div>- Async is good but it gives too much freedom to programmer and too complex</div><div>It has finite buffer size as well</div><div><br /></div><div><i>The receiver&nbsp;will wait for the message</i></div><div><br /></div><h3>Message buffers</h3><div>- This is not shared memory and it has finite space.</div><div><br /></div><div>- Under OS control -&gt; no synch needed</div><div>- No amount of buffering helps when sender is always faster thanr eciever</div><div>- User needs to declare in advance the cap of the mailbox</div><div><br /></div><h3>Synchronous message passing</h3><div>&nbsp;- Sender has to block till reciever performs matching recieve()</div><div>- Sender has to wait till receiver is ready</div><div>- Rendezvous&nbsp;</div><i>We can directly drag the message from the reciever address space without need to worry about the size of the buffer as it is directly put into the address space of the receiver.</i><br /><i>In contrast with async, where the sender does not wait,</i><br /><i>we need to buffer the message</i><br /><i><br /></i><h3>Pros of message passing</h3><div>- Applicable beyond single machine&nbsp;</div><div>Usually relies on shared memory</div><div>- Portable</div><div>- Easier synchronization</div><div><br /></div><h3>Disadvantages of Message passing</h3><div>- Inefficient</div><div>Requires OS intervention upon every send and recieve</div><div>- Hard to use</div><div>Requires packing/unpacking data into supported message format</div><div><br /></div><h2>Unix Pipes</h2><div>&lt;Slide 19&gt;</div><div>- One of the earliest IPC mechanism</div><div>- Communication channel with 2 ends (Write into and Read from)</div><h3>Piping in shell</h3><div>Unix provides the | symbol to link the input output channels of one process to another, this is known as piping</div><div><br /></div><h3>Unix pipes: IPC mech</h3><div>- Shared between 2 processes</div><div>- Producer and consumer relationship</div><div>- FIFO</div><div>-&nbsp;</div><h3>Blocking semantics</h3><div>- Circular bounded byte buffer with implicit synch</div><div>- Writers wait when buffer is full</div><div>- Readers wait when buffers is empty</div><div><br /></div><div>//Cher skip all these parts</div><div><br /></div><h2>Unix Signal</h2><div>It is a way for the OS to notify the process about something using the kill function. The process will handle it.</div><div>e.g Seg fault is caused by signal</div><div>The OS will treat execption generated by hardware and generate it as a signal</div><div><br /></div><div>- Interprocess communication</div><div>- Recipient of the signal must handle the signal by :<br />1. Default set of handlers</div><div>2. User supplied</div><div>- Common signs:<br />&nbsp; &nbsp;Kill,Stop, Continue, Memory error (segfault), Arithmetic error</div><div><br /></div><div><br /></div><i><br /></i>