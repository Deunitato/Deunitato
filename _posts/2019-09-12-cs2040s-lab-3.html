---
layout: post
title: 'CS2040s: DG 3'
date: '2019-09-12T04:24:00.000-07:00'
author: Charlotte Deunitato
tags: 
modified_time: '2019-10-02T22:36:46.241-07:00'
blogger_id: tag:blogger.com,1999:blog-4520250687931855860.post-8885983513124304630
blogger_orig_url: https://nusmods.blogspot.com/2019/09/cs2040s-lab-3.html
---

Recap:<br />Each Node can be a parent node and always have 2 child node.<br /><br />Normal BST:<br />If we insert and its not balancing, we will have to travel O(n) time.<br />This is an issue thus there exist an avl tree.<br />AVL tree will balance for us so searching is O(logn) time.<br /><br />AVL Tree:<br />Imagine we are plucking it up when balancing and letting it go which makes it fall down.<br /><br />Red Black Tree:<br />1. A node is either red or black<br />2. Roots and leaves are always black<br />3. If a node is red, the children is black<br />4. All paths from node to its NIL descendants contain the same number of black nodes.<br /><br />Nodes requires one storage bit to keep track of color<br />The shortest path is all black nodes and longest path is alternating red and black.<br /><br />Operation: All O(logn), Space is O(n)<br />Insert/Remove requires rotation<br /><br />Insertion:<br />Everytime we insert, we need to rebalance and ensure that the properties are met.<br />1. Insert node and colour it red<br />Case 0 : Z=root<br />Just colour z black<br />Case 1: Z.uncle = red<br />Recolour parent grandparent and uncle<br />Case 2 : Z.uncle = black (Triangle)<br />B - A - Z is a triangle<br />rotate Z<br />case 3: Z.uncle = black (Line)<br />B - A - Z<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- D<br />rotate z.grandparent<br />recolour<br />2. Fix violation<br /><br /><h4>Time complexity</h4>Insert - logn<br />Color - 1<br />fix violation: logn<br />&nbsp; &nbsp; recolo - 1<br />&nbsp; &nbsp; rotation - 1<br /><br /><span class="fontstyle0">Problem 1. Ranking and Selecting</span><span class="fontstyle2">In the previous Discussion Group, we figured out a data structure for the contestants on planet<br />Kronos. In today’s DG, consider that all the contestants are stored in a Binary Search Tree (BST)<br />and not a heap. Your employers now want two other operations to be included:</span><br /><span class="fontstyle2"><br /></span><span class="fontstyle3">• </span><span class="fontstyle4">select(int i) </span><span class="fontstyle2">which finds the </span><span class="fontstyle5">i</span><span class="fontstyle2">’th smallest element.</span><span class="fontstyle3">• </span><span class="fontstyle4">rank(contestant x) </span><span class="fontstyle2">which returns the rank of element </span><span class="fontstyle4">x</span><span class="fontstyle2">, i.e., its index in the sorted list of<br />all the elements.</span><br /><span class="fontstyle2"><br /></span><span class="fontstyle2"><br /></span><span class="fontstyle0">Problem 1.a. </span><span class="fontstyle2">Discuss how you can augment the BST to efficiently perform </span><span class="fontstyle4">select(int i) </span><span class="fontstyle2">and</span><span class="fontstyle4">rank(contestant x) </span><span class="fontstyle2">queries.</span><span class="fontstyle0">Hint: </span><span class="fontstyle6">In AVL trees, we stored the balance factor at each node to help us rebalance the tree. What<br />information can you store at each node that can help you quickly determine a node’s rank? Can<br />the information also be useful to perform a select?</span><br /><span class="fontstyle6"><br /></span><span class="fontstyle0">Problem 1.b. </span><span class="fontstyle2">Give pseudocode for </span><span class="fontstyle4">select(int i) </span><span class="fontstyle2">and </span><span class="fontstyle4">rank(contestant x) </span><span class="fontstyle2">and state their<br />asymptotic time complexities.</span><br /><br />rank:<br />Use size<br />Consider the case where we traverse right then left, then my next right node is larger than my child left<br /><br />Select:<br /><br /><br /><br /><br />